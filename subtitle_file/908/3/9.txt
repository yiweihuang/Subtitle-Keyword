1
00:00:08,041 --> 00:00:10,091
好 接下來我們來介紹說

2
00:00:10,091 --> 00:00:13,098
我們怎麼來設定所謂的NAV

3
00:00:13,098 --> 00:00:15,061
就是network allocation vector

4
00:00:15,061 --> 00:00:18,025
就是說 我們之前有介紹過說

5
00:00:18,025 --> 00:00:22,048
我們透過這個request to send跟clear to send的frame

6
00:00:22,048 --> 00:00:24,018
透過一個這樣的交握呢

7
00:00:24,018 --> 00:00:28,088
有點來宣告大家說我等下要送封包要送多久

8
00:00:28,088 --> 00:00:32,058
那我等下要收封包要收多久的時間

9
00:00:32,058 --> 00:00:36,018
那這個時間 到底是怎麼計算呢 我們說

10
00:00:36,018 --> 00:00:41,025
這個時間的計算是這樣子 如果針對RTS他送出來的話

11
00:00:41,025 --> 00:00:46,058
他就是說 我等下要預約的時間就是從RTS的封包結束

12
00:00:46,058 --> 00:00:49,018
然後到送data

13
00:00:49,018 --> 00:00:52,048
那我們說送一個data一定要回一個ACK嘛

14
00:00:52,048 --> 00:00:57,051
所以這個時間的計算 是從送一個data

15
00:00:57,051 --> 00:01:01,028
加上回一個ACK 這個都要算進去 還有中間

16
00:01:01,028 --> 00:01:06,098
我們知道data跟ACK中間 還有一個叫做short的IFS

17
00:01:06,098 --> 00:01:09,038
short inter frame space 這個都算進去

18
00:01:09,038 --> 00:01:14,091
就是說從這個RTS結束 到等下送一個封包結束

19
00:01:14,091 --> 00:01:19,081
到收到一個ACK結束 這個時間就是預約的時間

20
00:01:19,081 --> 00:01:24,091
那如果是clear to send 回答的CTS的話也是說

21
00:01:24,091 --> 00:01:28,085
好 CTS結束 到等一下呢 等下真的data送出來

22
00:01:28,085 --> 00:01:33,048
然後加上我的ACK回應 這個時間通通算進去

23
00:01:33,048 --> 00:01:38,068
就是一直要等到這個ACK frame的最尾巴

24
00:01:38,068 --> 00:01:42,091
這個才是我們的 所謂的這個duration的period

25
00:01:42,091 --> 00:01:47,055
就我們在這個RTS跟CTS裡面 這個時間的這個欄位

26
00:01:47,055 --> 00:01:52,028
是要填這段時間 我們用一個例子來說明一下

27
00:01:52,028 --> 00:01:55,051
那我們首先看這個例子裡面

28
00:01:55,051 --> 00:01:59,028
我們這邊左上角這邊是有一個source

29
00:01:59,028 --> 00:02:01,045
就是我有一個source在這個地方

30
00:02:01,045 --> 00:02:04,011
我有一個destination在這個地方

31
00:02:04,011 --> 00:02:07,098
那這邊是其他的工作站 就是這些其他工作站就代表說

32
00:02:07,098 --> 00:02:11,055
我可能會聽到RTS 可能會聽到CTS

33
00:02:11,055 --> 00:02:15,018
那當我聽到RTS或聽到CTS的時候

34
00:02:15,018 --> 00:02:17,048
我會發現中間有一個值叫duration

35
00:02:17,048 --> 00:02:20,095
那這個值我會把他設到 我們叫做NAV嘛

36
00:02:20,095 --> 00:02:24,021
就network allocation vector 那等下這個值就是說

37
00:02:24,021 --> 00:02:27,028
我即使待會我聽不到真正的

38
00:02:27,028 --> 00:02:30,011
所謂的physical的這種 這種所謂的carrier

39
00:02:30,011 --> 00:02:33,061
physical的signal 但是我會把它認定

40
00:02:33,061 --> 00:02:36,058
這個網路呢將會是busy的

41
00:02:36,058 --> 00:02:39,031
就是他是用virtual的這種busy的方法來做

42
00:02:39,031 --> 00:02:42,068
我們首先看 假設第一個

43
00:02:42,068 --> 00:02:48,008
這個source呢本身 我們講source本身要送封包

44
00:02:48,008 --> 00:02:52,058
首先他也可能是要聽一下這個 是不是busy嘛

45
00:02:52,058 --> 00:02:56,031
所以他等待一個 我們講 等一個DIFS的時間

46
00:02:56,031 --> 00:03:00,008
所以他就開始要送 可是因為他的封包可能比較長

47
00:03:00,008 --> 00:03:03,045
所以他先送一個RTS 那重點在於說

48
00:03:03,045 --> 00:03:07,008
好 那這個RTS本身 我們裡面會帶一個duration

49
00:03:07,008 --> 00:03:08,095
剛提到 我要帶一個時間

50
00:03:08,095 --> 00:03:11,098
代表說我待會要預約保留多久的時間

51
00:03:11,098 --> 00:03:17,035
我們說這個時間就是從他本身 RTS結束呢

52
00:03:17,035 --> 00:03:22,068
到 這個地方來 這個地方就是等一下

53
00:03:22,068 --> 00:03:25,081
ACK 這個結束的時間

54
00:03:25,081 --> 00:03:27,068
啊因為我們封包到底要送多長

55
00:03:27,068 --> 00:03:30,045
他知道 他也知道那個ACK的長度

56
00:03:30,045 --> 00:03:32,098
因為那個ACK是一個 我們講control frame

57
00:03:32,098 --> 00:03:34,051
他是一個固定長度的

58
00:03:34,051 --> 00:03:37,065
所以你的資料有多長 加上ACK的時間

59
00:03:37,065 --> 00:03:40,041
加上中間的這個inter frame space

60
00:03:40,041 --> 00:03:43,071
所以他可以算出這個T1到T3

61
00:03:43,071 --> 00:03:45,035
中間的時間把它算進去

62
00:03:45,035 --> 00:03:50,041
好那我們說 這個RTS呢 這個封包丟出去之後呢

63
00:03:50,041 --> 00:03:55,045
我們注意到 就其他的工作站 就聽到啦

64
00:03:55,045 --> 00:03:58,031
那其他的工作站呢 就是根據

65
00:03:58,031 --> 00:04:01,051
根據這個值 他上面的值呢

66
00:04:01,051 --> 00:04:07,028
就把它設定到他的所謂的network allocation vector

67
00:04:07,028 --> 00:04:10,065
這是聽到RTS的 那我們說 那接下來呢

68
00:04:10,065 --> 00:04:15,088
就是這個目的地收到RTS之後呢 他會回應一個CTS

69
00:04:15,088 --> 00:04:20,071
一樣 這個CTS本身 他也要放一個這個duration

70
00:04:20,071 --> 00:04:24,008
不過這個duration會比原來的RTS的duration稍微短一點

71
00:04:24,008 --> 00:04:28,038
因為他是從CTS結束 一直到等一下封包丟出來

72
00:04:28,038 --> 00:04:31,001
封包長度 然後再加上ACK

73
00:04:31,001 --> 00:04:34,031
那這個CTS呢 他送出來之後呢

74
00:04:34,031 --> 00:04:37,071
其他的工作站 聽得到CTS的 一樣

75
00:04:37,071 --> 00:04:42,021
那他們也會把這些值呢 把它放到所謂的

76
00:04:42,021 --> 00:04:45,075
這個所謂的allocation vector裡面

77
00:04:45,075 --> 00:04:48,025
就是說 聽到RTS的

78
00:04:48,025 --> 00:04:53,028
跟聽到CTS的 他們的這個NAV的值呢是不一樣

79
00:04:53,028 --> 00:04:57,088
因為聽到RTS是比較早嘛 那聽到CTS是比較晚一點

80
00:04:57,088 --> 00:05:00,005
所以他們的這個vector是不一樣

81
00:05:00,005 --> 00:05:02,028
不過在這個vector的期間

82
00:05:02,028 --> 00:05:06,005
相當於在這個期間

83
00:05:06,005 --> 00:05:11,041
我們這些node呢 都把它當成將來都是busy

84
00:05:11,041 --> 00:05:16,021
這個busy的時間是這麼長 接下來就可以開始送封包

85
00:05:16,021 --> 00:05:19,071
等於說待會這邊就開始把data丟出來

86
00:05:19,071 --> 00:05:23,028
然後經過一個short的IFS時間呢

87
00:05:23,028 --> 00:05:27,041
就把ACK丟出來 這樣就是一個完整的

88
00:05:27,041 --> 00:05:30,085
就是說我送一個RTS 先做一個reservation

89
00:05:30,085 --> 00:05:34,038
那我回一個CTS 也做一個reservation

90
00:05:34,038 --> 00:05:40,041
那我聽到RTS的人 就把它的這個NAV的值設定好

91
00:05:40,041 --> 00:05:42,071
然後聽到CTS的這個node

92
00:05:42,071 --> 00:05:45,081
就把它的這個NAV的值 也把它設好

93
00:05:45,081 --> 00:05:51,025
然後在這個時間之內 我們就雖然我聽不到這個封包在傳送

94
00:05:51,025 --> 00:05:55,061
但是呢我就把它當成現在是有封包在傳送

95
00:05:55,061 --> 00:05:59,041
因為剛剛已經預約了這段時間 所以我就

96
00:05:59,041 --> 00:06:02,011
雖然聽不到真正的訊號

97
00:06:02,011 --> 00:06:05,061
但是我把它認定這個時候是busy

98
00:06:05,061 --> 00:06:08,011
所以我也不會這個時候送封包

99
00:06:08,011 --> 00:06:10,001
我也不會來鬧他的意思啦

100
00:06:10,001 --> 00:06:13,055
好 那我們說 等到這個封包都送完啦

101
00:06:13,055 --> 00:06:18,051
相當於說 我們剛提到 我從這邊

102
00:06:18,051 --> 00:06:21,045
送一個RTS再送一個CTS

103
00:06:21,045 --> 00:06:23,038
然後送一個data 送一個ACK

104
00:06:23,038 --> 00:06:26,081
到這個時間點 這個時間點

105
00:06:26,081 --> 00:06:29,098
好這封包就正式送完了嘛

106
00:06:29,098 --> 00:06:32,005
因為我也送了RTS也送了CTS

107
00:06:32,005 --> 00:06:34,021
然後也送了data 也收到ACK

108
00:06:34,021 --> 00:06:36,028
所以這個是很完美的 就送完了

109
00:06:36,028 --> 00:06:38,065
那其他的node 我們講其他的node

110
00:06:38,065 --> 00:06:41,088
他們在這個時間之內 也都沒有來鬧

111
00:06:41,088 --> 00:06:44,048
因為都是busy 雖然他聽不到訊號

112
00:06:44,048 --> 00:06:46,008
可是他認為這是busy的

113
00:06:46,008 --> 00:06:49,035
好 那時間 這個時間點到了之後呢

114
00:06:49,035 --> 00:06:53,075
假設其他的node想要送 想要送

115
00:06:53,075 --> 00:06:58,051
就其他的node想要送 但是因為他們聽不到訊號

116
00:06:58,051 --> 00:07:01,048
可是呢他們也都把它當成busy

117
00:07:01,048 --> 00:07:03,085
這段期間都把他成當busy

118
00:07:03,085 --> 00:07:05,078
那busy相當於在結束了之後

119
00:07:05,078 --> 00:07:08,021
我們說 那你結束之後你要送

120
00:07:08,021 --> 00:07:11,038
你必須等待一個DIFS啊 一樣

121
00:07:11,038 --> 00:07:14,088
那等待完之後呢 還要加上一個random back-off time啊

122
00:07:14,088 --> 00:07:17,055
才能送 所以這個很特別就是說

123
00:07:17,055 --> 00:07:19,055
我們在802.11裡面

124
00:07:19,055 --> 00:07:23,031
如果你聽到一個RTS或你聽到一個CTS

125
00:07:23,031 --> 00:07:27,031
好 那上面有帶duration 你把這個duration的時間

126
00:07:27,031 --> 00:07:30,065
你就把它當成是說這個channel是busy的

127
00:07:30,065 --> 00:07:34,068
等到這個時間一結束 那也不能馬上送喔

128
00:07:34,068 --> 00:07:37,065
你必須等到一個DIFS

129
00:07:37,065 --> 00:07:40,068
等待這個時間之後 還是不能馬上送

130
00:07:40,068 --> 00:07:43,001
再加上一個random back-off time

131
00:07:43,001 --> 00:07:45,028
那這個random back-off time我們剛剛有提到

132
00:07:45,028 --> 00:07:48,001
這個時間到底多長  因為他是一個亂數嘛

133
00:07:48,001 --> 00:07:52,031
所以不一定 長短不一定 可是會跟你什麼有關

134
00:07:52,031 --> 00:07:56,081
跟你現在要送進去這個封包到底是第一次送 還是呢

135
00:07:56,081 --> 00:07:59,025
是在重送的過程 那因為

136
00:07:59,025 --> 00:08:02,058
這個牽涉到我們講那個contention window的值嘛

137
00:08:02,058 --> 00:08:05,041
第一次送 我們contention window等於7

138
00:08:05,041 --> 00:08:07,065
那你第一次重送 他就等於15

139
00:08:07,065 --> 00:08:10,071
第二次重送等於31 這樣等等等等等

140
00:08:10,071 --> 00:08:15,025
他是一個等於說 double double這樣上去 最多到255

141
00:08:15,025 --> 00:08:18,065
所以在算這個random back-off time的時候

142
00:08:18,065 --> 00:08:22,025
大家的back-off的時間 可能就不一樣了

143
00:08:22,025 --> 00:08:25,011
啊目的也就是因為這樣才可以把它錯開來嘛

144
00:08:25,011 --> 00:08:27,005
好 那底下我們再來看看說

145
00:08:27,005 --> 00:08:31,075
那到底我怎麼來控制這個所謂的channel的使用呢

146
00:08:31,075 --> 00:08:32,098
我們剛剛提到說

147
00:08:32,098 --> 00:08:36,041
因為我們用了這個所謂的inter frame space

148
00:08:36,041 --> 00:08:39,085
inter frame space 所以我們到目前為止介紹

149
00:08:39,085 --> 00:08:42,025
我們有三種的inter frame space

150
00:08:42,025 --> 00:08:44,081
那送data回ACK

151
00:08:44,081 --> 00:08:48,085
這是必須立刻而且連著發生的事情

152
00:08:48,085 --> 00:08:51,025
送data回ACK不可以被中斷

153
00:08:51,025 --> 00:08:55,001
中間不可以被插入任何其他的封包嘛 所以我們說

154
00:08:55,001 --> 00:08:59,018
送data回ACK 或者送RTS

155
00:08:59,018 --> 00:09:01,005
request to send回clear to send

156
00:09:01,005 --> 00:09:03,065
data, ACK, clear to send, request to send

157
00:09:03,065 --> 00:09:06,045
他們中間 他們都是用short的IFS

158
00:09:06,045 --> 00:09:11,015
都是最短的時間 然後等於說立刻要做一個這個交握

159
00:09:11,078 --> 00:09:14,051
好 那我們說 那一個station

160
00:09:14,051 --> 00:09:18,085
他如果真的爭取到這個所謂的channel的使用權

161
00:09:18,085 --> 00:09:21,098
就他開始送封包的時候 那接下來呢

162
00:09:21,098 --> 00:09:27,041
他可以連續的送一些fragment

163
00:09:27,041 --> 00:09:31,015
就是他好不容易才搶到一個封包的使用權

164
00:09:31,015 --> 00:09:34,061
我們剛剛提到 一個封包要丟出去

165
00:09:34,061 --> 00:09:38,045
這個時間點有時候不容易掌握啊

166
00:09:38,045 --> 00:09:42,045
譬如剛剛提到 我聽到是idle 你也不能馬上送

167
00:09:42,045 --> 00:09:46,001
idle 至少也要聽DIFS

168
00:09:46,001 --> 00:09:48,095
那如果是聽到busy 那你就更麻煩了

169
00:09:48,095 --> 00:09:54,071
聽到busy 還要等到他送完 然後再等一個DIFS

170
00:09:54,071 --> 00:09:57,048
然後再產生一個random back-off的時間

171
00:09:57,048 --> 00:10:01,041
random back-off才要開始慢慢的所謂的倒數計時到0

172
00:10:01,041 --> 00:10:04,078
倒數計時的過程當中 如果有人先送出去

173
00:10:04,078 --> 00:10:07,065
倒數計時還要暫停 也就是說

174
00:10:07,065 --> 00:10:10,091
如果你要送的時候 聽到是一個busy的時候

175
00:10:10,091 --> 00:10:13,078
那後面這個程序 你看有多複雜

176
00:10:13,078 --> 00:10:18,005
我必須等到他結束 等到一個DIFS

177
00:10:18,005 --> 00:10:20,065
然後再產生一個random back-off time

178
00:10:20,065 --> 00:10:23,031
random back-off time開始倒數計時到0

179
00:10:23,031 --> 00:10:26,045
那計時過程的當中 如果有人封包在送

180
00:10:26,045 --> 00:10:30,051
我倒數計時還要暫停 最後等到0了

181
00:10:30,051 --> 00:10:33,025
你終於可以把他送上去了 好

182
00:10:33,025 --> 00:10:36,088
那你終於把他送上去的時候 好 這個時候呢

183
00:10:36,088 --> 00:10:42,051
我們就說 我們可不可以終於搶到這個傳送權了

184
00:10:42,051 --> 00:10:44,071
我可不可以送多一點

185
00:10:44,071 --> 00:10:46,041
我可不可以送多一點封包

186
00:10:46,041 --> 00:10:49,018
不要只送一個 搶了半天才搶到一次機會

187
00:10:49,018 --> 00:10:53,031
一個封包丟出去 等下又重來 那這個很沒有效率啦

188
00:10:53,031 --> 00:10:56,068
也就是說我們事實上是可以允許這件事情

189
00:10:56,068 --> 00:10:59,041
就是說 我的封包 如果是比較大

190
00:10:59,041 --> 00:11:01,068
我通常會把它切成所謂的segment

191
00:11:01,068 --> 00:11:03,035
切成幾個小片段

192
00:11:03,035 --> 00:11:06,035
那我搶了半天 搶到這個傳送權

193
00:11:06,035 --> 00:11:10,018
是搶到第一個傳送權嘛 我後面可能會

194
00:11:10,018 --> 00:11:14,035
就是我們會把一個原來一個大封包

195
00:11:14,035 --> 00:11:16,091
如果我切成許多所謂的fragment

196
00:11:16,091 --> 00:11:19,051
我會把這個所有的fragment呢 把它送完

197
00:11:19,051 --> 00:11:21,061
如果我可以送完的話

198
00:11:21,061 --> 00:11:25,025
或者我在送這個fragment的過程當中

199
00:11:25,025 --> 00:11:26,045
我特別強調

200
00:11:26,045 --> 00:11:29,091
你送這個所有的fragment的過程當中也是一樣

201
00:11:29,091 --> 00:11:32,068
一個fragment一個ACK

202
00:11:32,068 --> 00:11:35,075
就是每一個fragment 他都要收到一個ACK

203
00:11:35,075 --> 00:11:38,061
那萬一中間有一個ACK不見了

204
00:11:38,061 --> 00:11:40,075
我們一個ACK如果沒有收到

205
00:11:40,075 --> 00:11:44,071
那就代表說啊你這個失敗啦 所以你這個傳輸就暫停

206
00:11:44,071 --> 00:11:48,011
等下就要重來啦 就是說 一定要等到一個ACK

207
00:11:48,011 --> 00:11:50,088
因為一個ACK沒有收到 就代表你是ERROR了嘛

208
00:11:50,088 --> 00:11:52,065
那ERROR等下就會重來

209
00:11:52,065 --> 00:11:55,035
或者是說呢 你這個所有的fragment

210
00:11:55,035 --> 00:11:57,001
all fragment要送

211
00:11:57,001 --> 00:11:58,071
可是這個all fragment實在是太多了

212
00:11:58,071 --> 00:12:03,048
那會超過這個 我們叫一個叫做 所謂的dwell time

213
00:12:03,048 --> 00:12:06,061
代表是說一個上限啦 就是說我們

214
00:12:06,061 --> 00:12:09,035
因為我們要考慮到所謂的公平性嘛

215
00:12:09,035 --> 00:12:14,038
雖然是說 我們一個station要搶這個傳送權

216
00:12:14,038 --> 00:12:19,018
是搶得很辛苦 那一旦搶到之後呢 可以讓你多送一點

217
00:12:19,018 --> 00:12:22,025
但是也不能送的太長啊 你送的太長

218
00:12:22,025 --> 00:12:25,031
後面的人就被你延到更後面去了嘛

219
00:12:25,031 --> 00:12:27,018
所以為了公平性來講的話

220
00:12:27,018 --> 00:12:31,028
我們會有一個機制就是說 一旦你搶到傳送權

221
00:12:31,028 --> 00:12:33,061
你可以多送幾個fragment

222
00:12:33,061 --> 00:12:36,021
一直到把這個fragment送完

223
00:12:36,021 --> 00:12:38,005
或者呢一個ACK lost掉

224
00:12:38,005 --> 00:12:42,001
或者最後的上限到了 就不能送了

225
00:12:42,001 --> 00:12:44,091
我們就看一個例子 在這個例子裡面呢

226
00:12:44,091 --> 00:12:49,045
一樣我們假設呢 有一個 有一對啦

227
00:12:49,045 --> 00:12:53,015
等於說有一個source呢等下要送封包 要送給這個destination

228
00:12:53,015 --> 00:12:56,078
那 我們在這個送的過程當中

229
00:12:56,078 --> 00:12:59,068
我們假設把一個封包呢切成好幾個fragment

230
00:12:59,068 --> 00:13:03,065
首先 第一個 他送一個我們叫做第一個fragment

231
00:13:03,065 --> 00:13:07,011
那送一個fragment呢 他一定要回一個ACK

232
00:13:07,011 --> 00:13:10,088
所以對方收到這個fragment的話 他就回一個ACK

233
00:13:10,088 --> 00:13:15,038
那我們注意到 這個中間的時間差 就是一樣

234
00:13:15,038 --> 00:13:19,075
data 或者叫做fragment跟中間的ACK的時間差

235
00:13:19,075 --> 00:13:24,021
都是一個short   short的IFS 好

236
00:13:24,021 --> 00:13:28,008
那接下來 如果ACK已經收到了嘛 我就送第二個

237
00:13:28,008 --> 00:13:33,011
注意到 這個data送完到這個fragment

238
00:13:33,011 --> 00:13:38,031
第二個fragment出來 他也是一個所謂的short IFS

239
00:13:38,031 --> 00:13:41,048
好 那這個fragment2送完之後呢

240
00:13:41,048 --> 00:13:45,045
對方收到的話 也要回一個ACK2

241
00:13:45,045 --> 00:13:48,085
一樣 再一次 這個也是一樣

242
00:13:48,085 --> 00:13:52,088
這個ACK 回答的時間呢

243
00:13:52,088 --> 00:13:58,025
也必須在一個SIFS的時間裡面出現 再後面也是一樣

244
00:13:58,025 --> 00:14:03,038
我就送fragment3 我就回 ACK3 就是說

245
00:14:03,038 --> 00:14:07,001
送一個fragment就回一個ACK 送一個

246
00:14:07,001 --> 00:14:09,001
等於說他這個過程就是

247
00:14:09,001 --> 00:14:12,018
等於說是這樣 這樣 這樣 這樣 這樣

248
00:14:12,018 --> 00:14:17,005
就是說 送一個fragment回一個ACK

249
00:14:17,005 --> 00:14:20,051
那一個一個一個這樣送 那這樣的話 我就等於說

250
00:14:20,051 --> 00:14:23,008
我好不容易搶到這個傳輸權的話

251
00:14:23,008 --> 00:14:26,008
我可以送一個叫做fragment的burst

252
00:14:26,008 --> 00:14:29,028
送一連串這個fragment的封包

253
00:14:29,028 --> 00:14:31,068
然後把我整個封包通通送完

254
00:14:31,068 --> 00:14:35,058
這個是 當我們好不容易搶到一個傳輸這個權的時候呢

255
00:14:35,058 --> 00:14:39,045
可以這樣子做 好 那接下來就來看說

256
00:14:39,045 --> 00:14:43,098
那萬一啦 萬一這個source station本身 如果他沒有收到

257
00:14:43,098 --> 00:14:47,088
我們講 如果沒有收到一個ACK

258
00:14:47,088 --> 00:14:50,018
那就必須傳輸必須中斷嘛

259
00:14:50,018 --> 00:14:51,091
因為你沒有收到一個ACK

260
00:14:51,091 --> 00:14:54,058
代表你這個前面這個封包已經

261
00:14:54,058 --> 00:14:57,075
就把它當成是ERROR了 可能是發生了collision

262
00:14:57,075 --> 00:14:59,071
可能是因為其他的原因

263
00:14:59,071 --> 00:15:01,081
譬如說被干擾 封包壞掉了

264
00:15:01,081 --> 00:15:05,088
好 那這個時候 等下他會嘗試的我們叫做retransmit

265
00:15:05,088 --> 00:15:08,078
你要重送 那重送的時候呢

266
00:15:08,078 --> 00:15:11,035
等到這個重送的時間到的時候

267
00:15:11,035 --> 00:15:14,081
我們要用進到那個所謂的contention window

268
00:15:14,081 --> 00:15:18,088
就進到那個重送的這個視窗裡面呢 再來搶一次

