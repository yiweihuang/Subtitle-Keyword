2
00:00:09,100 --> 00:00:12,400
好那我們用一張表

3
00:00:12,400 --> 00:00:15,980
來做最後的解釋就是說這個TCP本身

4
00:00:15,980 --> 00:00:18,520
這個sender怎麼做congestion control

5
00:00:18,520 --> 00:00:19,980
我們這個表裡面我們說

6
00:00:19,980 --> 00:00:23,380
最左邊我們叫做state 剛提到

7
00:00:23,380 --> 00:00:25,540
是在一開始就在slow start

8
00:00:25,540 --> 00:00:27,440
這個slow start state嘛

9
00:00:27,440 --> 00:00:30,180
然後他進到線性的時候呢我們叫做

10
00:00:30,180 --> 00:00:32,200
所謂的congestion-avoidance的state

11
00:00:33,200 --> 00:00:34,020
那這是左邊這邊

12
00:00:35,020 --> 00:00:37,500
然後接下來我們會介紹一下不同的event

13
00:00:38,500 --> 00:00:40,500
就是 發生了甚麼事

14
00:00:40,500 --> 00:00:41,940
比如說收到duplicated ack啦

15
00:00:41,940 --> 00:00:44,580
或者收到ack啦或者甚麼timeout等等

16
00:00:44,580 --> 00:00:47,480
然後我們就來看 TCP他sender

17
00:00:47,480 --> 00:00:49,920
他的action是甚麼 他到底

18
00:00:49,920 --> 00:00:52,440
怎麼來反映 針對這個發生的事情

19
00:00:52,440 --> 00:00:54,940
怎麼做反映 那最右邊這邊呢

20
00:00:54,940 --> 00:00:56,820
就是我們做一個解釋啦

21
00:00:56,820 --> 00:00:59,680
我們叫所謂的這個說明

22
00:00:59,680 --> 00:01:00,300
我們就來看第一個

23
00:01:01,300 --> 00:01:02,039
首先我們看第一個就是說

24
00:01:03,039 --> 00:01:05,099
ㄧ開始的時候呢 我們在這個slow start

25
00:01:06,099 --> 00:01:08,500
我們說slow start會發生甚麼事情

26
00:01:08,500 --> 00:01:11,780
就是說如果我們在slow start的這個

27
00:01:11,780 --> 00:01:13,620
phase 在這個階段呢

28
00:01:13,620 --> 00:01:16,160
我們如果說 好收到一個ack

29
00:01:17,160 --> 00:01:20,640
slow start的這個階段 收到一個ack

30
00:01:20,640 --> 00:01:22,360
我們說 每收到一個ack

31
00:01:22,360 --> 00:01:25,739
我們就會檢查 我們就會讓他的window呢

32
00:01:25,739 --> 00:01:28,040
congestion window 就加上一個MSS

33
00:01:29,040 --> 00:01:31,459
也就是在slow start的這個階段呢

34
00:01:31,459 --> 00:01:33,800
每收到一個ack我們的congestion window

35
00:01:33,800 --> 00:01:36,360
就會加上一個封包的大小

36
00:01:36,360 --> 00:01:37,000
但是我們也會檢查說

37
00:01:38,000 --> 00:01:40,220
這個時候的這個congestion window呢

38
00:01:40,220 --> 00:01:42,880
是不是已經大於threshold

39
00:01:42,880 --> 00:01:44,280
我們說 如果大於threshold

40
00:01:45,280 --> 00:01:46,620
就要改成linear嘛

41
00:01:46,620 --> 00:01:48,720
也就是如果所有congestion window已經大於

42
00:01:48,720 --> 00:01:51,200
threshold的話 我們就進入了

43
00:01:51,200 --> 00:01:53,959
這個congestion-avoidance的state

44
00:01:53,959 --> 00:01:55,300
就這樣我們再來看

45
00:01:55,300 --> 00:01:58,739
那在congestion-avoidance state的時候呢

46
00:01:58,739 --> 00:02:00,340
如果我們每收到一個ack

47
00:02:00,340 --> 00:02:03,220
因為這時候已經進到所謂的線性增加了

48
00:02:03,220 --> 00:02:07,019
那收到一個ack呢就不是加一個MSS囉

49
00:02:07,019 --> 00:02:08,880
而是只是加一個我們講一個

50
00:02:08,880 --> 00:02:11,680
ㄧ個faction嘛 好那加的faction是這樣子

51
00:02:11,680 --> 00:02:16,099
是MSS 乘上MSS over congestion window

52
00:02:17,099 --> 00:02:19,580
就是我們之前有介紹過 比如說

53
00:02:19,580 --> 00:02:21,940
這個時候congestion window如果是五個

54
00:02:21,940 --> 00:02:23,880
MSS我們就加五分之ㄧ

55
00:02:23,880 --> 00:02:27,840
如果是八個MSS呢我們就加八分之ㄧ嘛

56
00:02:27,840 --> 00:02:31,539
就很簡單就進到這個congestion-avoidance

57
00:02:31,539 --> 00:02:34,500
的時候呢我們這個congestion window的增加

58
00:02:34,500 --> 00:02:36,599
是用線性的方式來增加

59
00:02:36,599 --> 00:02:40,840
好那我們說不管是在哪一個state

60
00:02:40,840 --> 00:02:44,120
不管是在slow start或者congestion-avoidance

61
00:02:45,120 --> 00:02:47,660
我們接下來看那如果發生lost event

62
00:02:48,660 --> 00:02:50,440
就是發生packet lost

63
00:02:50,440 --> 00:02:53,759
阿這個packet lost本身呢是因為偵測到所謂的

64
00:02:53,759 --> 00:02:57,840
triple duplicated ack 就是這個是因為

65
00:02:57,840 --> 00:03:01,520
偵測到收到三個重複的ack這件事情

66
00:03:01,520 --> 00:03:05,440
代表封包lost 掉 不管是在哪一個狀態

67
00:03:05,440 --> 00:03:07,860
不管是在slow start 或者是在

68
00:03:07,860 --> 00:03:09,460
所謂的congestion-avoidance

69
00:03:09,460 --> 00:03:14,419
不管是在哪一個只要發生收到三個重複的ack

70
00:03:14,419 --> 00:03:16,639
好我們就說我們的threshold就會減半

71
00:03:16,639 --> 00:03:19,720
那congestion window呢就把他設為threshold

72
00:03:20,720 --> 00:03:23,340
然後來一樣 變成線性增加

73
00:03:23,340 --> 00:03:27,160
也就是這個時候只要是triple duplicated的話

74
00:03:27,160 --> 00:03:29,539
我們就等於像把window降ㄧ半

75
00:03:29,539 --> 00:03:31,199
然後再linear增加的意思

76
00:03:31,199 --> 00:03:33,020
所以降ㄧ半linear

77
00:03:33,020 --> 00:03:34,780
不管是那兩個state

78
00:03:34,780 --> 00:03:38,020
好再來一個那如果說不管是在哪一個state

79
00:03:39,020 --> 00:03:41,900
這裡那如果發生timeout呢

80
00:03:41,900 --> 00:03:44,099
timeout就更嚴重了 我們講timeout更嚴重

81
00:03:44,099 --> 00:03:46,740
不管是哪一個state 我們的congestion window呢

82
00:03:46,740 --> 00:03:49,139
全部都降為ㄧ 馬上就掉到ㄧ

83
00:03:50,139 --> 00:03:52,819
然後threshold呢設為原來的ㄧ半

84
00:03:52,819 --> 00:03:54,360
ㄧ半 然後降為ㄧ然後slow start

85
00:03:55,360 --> 00:03:58,099
那進到slow start 就來看

86
00:03:59,099 --> 00:04:02,060
每經過一個ack就加一個MSS嘛

87
00:04:02,060 --> 00:04:05,220
阿一直檢查到這個地方 就是說

88
00:04:05,220 --> 00:04:09,080
如果這個時候我們就所謂的指數增加

89
00:04:09,080 --> 00:04:11,240
但是這個增加的量

90
00:04:11,240 --> 00:04:14,440
只要超過原來的一半 就threshold啦

91
00:04:14,440 --> 00:04:16,180
超過threshold阿threshold是設定為原來的

92
00:04:17,180 --> 00:04:18,660
congestion window的一半嘛

93
00:04:18,660 --> 00:04:21,420
只要超過原來的一半就改成linear

94
00:04:21,420 --> 00:04:23,399
這個是他的做法我們從這邊

95
00:04:23,399 --> 00:04:24,360
這邊也可以看得到這個

96
00:04:25,360 --> 00:04:27,420
這個時間點就是在這個地方

97
00:04:27,420 --> 00:04:29,199
我是timeout 然後掉下來把他掉到一半

98
00:04:30,199 --> 00:04:32,959
那我的threshold呢就設為原來的一半

99
00:04:32,959 --> 00:04:35,060
我就exponential 碰到這個地方

100
00:04:35,060 --> 00:04:37,800
改成linear 所以這一段

101
00:04:37,800 --> 00:04:41,199
特別注意 這一段就是指在這個例子

102
00:04:42,199 --> 00:04:44,139
就是說我們如果發生timeout的話

103
00:04:44,139 --> 00:04:45,899
我怎麼去反應

104
00:04:45,899 --> 00:04:50,860
好那我們如果說 不管是在哪一個state

105
00:04:50,860 --> 00:04:53,279
不管哪一個state 我們說如果他

106
00:04:54,279 --> 00:04:55,940
收到一個duplicated ack

107
00:04:56,940 --> 00:04:59,740
就是說duplicated ack就是重複的ack

108
00:04:59,740 --> 00:05:03,459
當然這個時候如果是第一次 我們就把他

109
00:05:03,459 --> 00:05:04,779
只要算他的count

110
00:05:04,779 --> 00:05:07,139
就是累計的意思啦 累計

111
00:05:08,139 --> 00:05:09,019
一直到他第三次的意思

112
00:05:10,019 --> 00:05:12,620
前面第一次我們只是把他累加

113
00:05:12,620 --> 00:05:14,199
累計然後第二次也是累計

114
00:05:14,199 --> 00:05:17,240
到了第三次 第三次就是這個事件嘛

115
00:05:18,240 --> 00:05:20,500
那第一次跟第二次都不是事件

116
00:05:20,500 --> 00:05:22,000
只是把他累加起來就可以

117
00:05:23,000 --> 00:05:25,699
好這是所謂的TCP的sender

118
00:05:25,699 --> 00:05:28,079
這個congestion control的這個整個summary

119
00:05:29,079 --> 00:05:31,060
那我們再來看那TCP的

120
00:05:31,060 --> 00:05:32,980
throughput到底好不好呢

121
00:05:32,980 --> 00:05:35,380
TCP的連線他的throughput到底好不好

122
00:05:35,380 --> 00:05:38,300
我們說throughput怎麼算 很簡單

123
00:05:38,300 --> 00:05:40,660
throughput就是剛剛提到 就是一個

124
00:05:40,660 --> 00:05:43,360
window size然後除以你的RTT

125
00:05:43,360 --> 00:05:46,459
也代表說 在一個RTT的時間之內

126
00:05:46,459 --> 00:05:49,540
你可以傳送的量 就是所謂的throughput

127
00:05:49,540 --> 00:05:52,680
我們假設啦 說w呢就是我的window size

128
00:05:53,680 --> 00:05:58,680
那 當這個lost發生的時候 那也就是說

129
00:05:58,680 --> 00:06:02,120
當lost發生之前 這個windows w的時候

130
00:06:02,120 --> 00:06:03,240
我的throughput是不是這樣子

131
00:06:04,240 --> 00:06:08,079
就是代表一個RTT的時間我可以送w的byte嘛

132
00:06:08,079 --> 00:06:11,620
這是我的throughput可是呢他一旦發生lost之後

133
00:06:11,620 --> 00:06:15,440
他的那個我們講window呢馬上就降為ㄧ半阿

134
00:06:15,440 --> 00:06:17,560
降為ㄧ半你的throughput就降為ㄧ半

135
00:06:17,560 --> 00:06:19,339
throughput就變成這樣子

136
00:06:19,339 --> 00:06:23,399
變成說一個RTT的時間你只能送 二分之一的w

137
00:06:24,399 --> 00:06:28,060
那我們說沒有發生這個lost的時候呢

138
00:06:29,060 --> 00:06:34,420
我的throughput是 這個w over RTT嘛

139
00:06:34,420 --> 00:06:36,540
那發生lost的時候我降一半

140
00:06:36,540 --> 00:06:39,660
變成w over兩倍的RTT

141
00:06:39,660 --> 00:06:42,600
所以我的平均啦 throughput簡單的講

142
00:06:42,600 --> 00:06:46,579
就相當於是 0.75 就是四分之三

143
00:06:47,579 --> 00:06:50,240
的這個w 然後RTT這樣子

144
00:06:50,240 --> 00:06:52,579
所以我們的throughput呢可以這樣子很

145
00:06:52,579 --> 00:06:54,779
簡單的可以算得出來說

146
00:06:54,779 --> 00:06:57,519
那在沒有packet lost的時候

147
00:06:57,519 --> 00:06:59,940
throughput就是w over RTT

148
00:06:59,940 --> 00:07:01,759
那packet lost的時候變減半

149
00:07:01,759 --> 00:07:04,880
所以平均 大概就是0.75的w喔

150
00:07:04,880 --> 00:07:06,660
然後這個over RTT

151
00:07:06,660 --> 00:07:07,139
所以我們一個connection呢

152
00:07:08,139 --> 00:07:09,120
可以根據這個時間來算

153
00:07:10,120 --> 00:07:12,720
那w本身當然就隨著時間在那邊變啦

154
00:07:12,720 --> 00:07:15,220
我們講因為不管是slow start

155
00:07:15,220 --> 00:07:16,540
或者congestion-avoidance

156
00:07:16,540 --> 00:07:19,920
反正他不管是指數增加或者線性增加

157
00:07:19,920 --> 00:07:22,579
那他反正隨著時間會在這邊做調整

158
00:07:22,579 --> 00:07:25,120
那我們很簡單的 就可以把這個TCP的

159
00:07:25,120 --> 00:07:27,199
throughput呢可以做一個這個計算

160
00:07:28,199 --> 00:07:31,880
好那最後呢我們就 針對這一章

161
00:07:31,880 --> 00:07:33,819
來做一個所謂的總結

162
00:07:33,819 --> 00:07:36,880
那在這一章裡面呢我們介紹了說

163
00:07:36,880 --> 00:07:39,980
怎麼樣 從一個像Internet Working

164
00:07:39,980 --> 00:07:42,380
叫做IP網路 IP網路本身

165
00:07:42,380 --> 00:07:44,380
是強調所謂的Host to Host

166
00:07:44,380 --> 00:07:48,779
就是一般 某一台主機送到某一台主機嘛

167
00:07:48,779 --> 00:07:50,860
好那在transport layer呢就是等於說

168
00:07:50,860 --> 00:07:53,560
又加上一個所謂的port的觀念

169
00:07:53,560 --> 00:07:56,680
使得說我們的傳輸呢就可以變成所謂的

170
00:07:56,680 --> 00:08:00,959
process-to-process因為現在一個process呢

171
00:08:00,959 --> 00:08:04,420
是有一個IP加上一個port number

172
00:08:04,420 --> 00:08:06,800
變成說我們本來是IP對IP

173
00:08:06,800 --> 00:08:08,100
就會變成主機對主機的通訊

174
00:08:09,100 --> 00:08:12,040
現在再把他往上升一級 變成所謂的

175
00:08:13,040 --> 00:08:16,779
process對process而每一個process本身

176
00:08:16,779 --> 00:08:19,920
有一個IP加上一個port number

177
00:08:19,920 --> 00:08:22,980
也就是說我們把這個整個通訊的這個

178
00:08:22,980 --> 00:08:25,279
這個過程 從原來的layer three

179
00:08:26,279 --> 00:08:28,500
就介紹到layer four啦

180
00:08:28,500 --> 00:08:30,500
就介紹到所謂的transport layer

181
00:08:30,500 --> 00:08:33,019
那在這一章裡面呢 我們也介紹了

182
00:08:33,019 --> 00:08:37,720
所謂的UDP 我們叫user data grand protocol

183
00:08:37,720 --> 00:08:40,820
那UDP本身呢他也是提供

184
00:08:40,820 --> 00:08:42,320
剛剛reliable的transmission

185
00:08:42,320 --> 00:08:45,220
就是跟他IP一樣 所以UDP本身

186
00:08:45,220 --> 00:08:48,880
他雖然跟IP一樣 都是提供所謂的

187
00:08:48,880 --> 00:08:51,840
不可靠的傳輸 但是UDP因為

188
00:08:51,840 --> 00:08:53,100
他加了port number

189
00:08:54,100 --> 00:08:56,000
所以雖然是不可靠的傳輸

190
00:08:56,000 --> 00:08:57,299
但是呢他因為加了port number

191
00:08:58,299 --> 00:09:01,240
所以用UDP上面就可以有很多不同的application

192
00:09:02,240 --> 00:09:03,120
或者很多不同的process

193
00:09:04,120 --> 00:09:06,860
因為不同的process呢 可以有不同的

194
00:09:06,860 --> 00:09:08,759
port number 所以UDP

195
00:09:08,759 --> 00:09:11,440
雖然說他也是不可靠的傳輸

196
00:09:11,440 --> 00:09:14,600
可是呢他把這個服務的這個層次

197
00:09:14,600 --> 00:09:18,320
從原來的layer three就把他提升到layer four

198
00:09:18,320 --> 00:09:19,679
就是trsansport layer

199
00:09:19,679 --> 00:09:20,200
好那這一章的重點

200
00:09:21,200 --> 00:09:23,259
最重要的就是所謂的TCP

201
00:09:23,259 --> 00:09:26,940
我們介紹TCP裡面說他是一個reliable的

202
00:09:26,940 --> 00:09:28,399
trasmission的service

203
00:09:28,399 --> 00:09:31,960
TCP是一個可靠的傳輸服務

204
00:09:31,960 --> 00:09:36,620
但是我們說因為 TCP的下面他的底層

205
00:09:36,620 --> 00:09:38,600
是一個IP是不可靠的

206
00:09:38,600 --> 00:09:41,019
所以我們說TCP最大的挑戰就是說

207
00:09:42,019 --> 00:09:44,639
怎麼樣在不可靠的網路之下

208
00:09:44,639 --> 00:09:46,940
所謂提供可靠的服務

209
00:09:46,940 --> 00:09:49,360
那這個可靠呢我們說最主要是幾點

210
00:09:49,360 --> 00:09:53,080
第一個 第一個資料量 不能夠多

211
00:09:53,080 --> 00:09:55,820
不能少資料量完全一樣

212
00:09:55,820 --> 00:09:57,139
還有資料的內容也不能錯

213
00:09:58,139 --> 00:10:00,500
還有資料的順序也不能錯

214
00:10:00,500 --> 00:10:02,720
就是說 他要提供非常可靠的服務

215
00:10:03,720 --> 00:10:06,559
sender送了甚麼資料進來receiver

216
00:10:06,559 --> 00:10:07,960
就要收到甚麼資料

217
00:10:07,960 --> 00:10:10,380
不能多也不能少也不能亂

218
00:10:10,380 --> 00:10:13,039
順序都要正確 這個完全都要正確

219
00:10:14,039 --> 00:10:15,080
那我們就說TCP怎麼做呢

220
00:10:16,080 --> 00:10:18,759
我們就介紹 在這章裡面有跟各位提到

221
00:10:18,759 --> 00:10:20,220
TCP呢必須建連線

222
00:10:21,220 --> 00:10:23,720
建connection 那connection的建法呢

223
00:10:23,720 --> 00:10:25,440
我們叫做所謂的three way hand-shaking

224
00:10:26,440 --> 00:10:29,919
就是三四個交握 把連線建起來

225
00:10:29,919 --> 00:10:32,460
然後當然也引進了 所謂的sequence number

226
00:10:32,460 --> 00:10:35,759
我們特別強調 TCP本身是一個byte stream

227
00:10:35,759 --> 00:10:36,039
oriented protocol

228
00:10:37,039 --> 00:10:38,980
也就是說他的sequence number呢

229
00:10:38,980 --> 00:10:40,639
指的是某一個byte

230
00:10:40,639 --> 00:10:42,419
也就是說每一個byte

231
00:10:42,419 --> 00:10:43,179
都有一個sequence numer

232
00:10:44,179 --> 00:10:45,960
那建連線的時候呢

233
00:10:45,960 --> 00:10:47,360
用three way hand-shaking

234
00:10:47,360 --> 00:10:49,139
那你要把連線關掉

235
00:10:49,139 --> 00:10:51,019
也是一個state machine的概念

236
00:10:51,019 --> 00:10:55,200
所以我們也介紹了所謂的TCP connection的這種

237
00:10:55,200 --> 00:10:58,759
state diagram 就是sender這邊還有

238
00:10:58,759 --> 00:11:01,539
對不起這是client這邊跟server這一邊

239
00:11:01,539 --> 00:11:04,460
他們都各有自己的state machine

240
00:11:04,460 --> 00:11:07,980
然後根據這個state呢收到甚麼封包

241
00:11:07,980 --> 00:11:10,019
回應甚麼封包 這樣可以把連線建起來

242
00:11:11,019 --> 00:11:14,200
那也可以把連線呢比較正常的把他關閉掉

243
00:11:15,200 --> 00:11:16,860
好那我們也介紹說

244
00:11:16,860 --> 00:11:19,580
因為TCP本身在做這個所謂的

245
00:11:19,580 --> 00:11:21,120
可靠的傳輸的時候

246
00:11:21,120 --> 00:11:24,700
他一個很重要就是要收到對方的ack

247
00:11:25,700 --> 00:11:27,299
那如果沒有收到ack呢他就會timeout

248
00:11:28,299 --> 00:11:31,720
所以timeout的值 也是非常的關鍵的

249
00:11:31,720 --> 00:11:33,320
叫做timeout value的calculation

250
00:11:34,320 --> 00:11:36,519
那我們說 這個timeout的值

251
00:11:36,519 --> 00:11:41,740
一般是設成 來回的時間再加一些啦

252
00:11:41,740 --> 00:11:45,240
那我們說 TCP的原版的演算法裡面

253
00:11:45,240 --> 00:11:49,820
是把來回的時間 等於說乘上兩倍

254
00:11:49,820 --> 00:11:51,740
那這樣因為沒有辦法反應

255
00:11:51,740 --> 00:11:53,880
這個網路這個隨時

256
00:11:53,880 --> 00:11:55,840
可能會有變化的情況嘛

257
00:11:55,840 --> 00:11:57,100
所以有更新的方法來設計

258
00:11:58,100 --> 00:12:00,340
讓這個timeout的計算

259
00:12:00,340 --> 00:12:04,259
能夠更 貼切的反應這個網路的

260
00:12:04,259 --> 00:12:07,720
最新的狀況 那我們也提到說在TCP呢

261
00:12:07,720 --> 00:12:09,440
怎麼做retransmission

262
00:12:09,440 --> 00:12:11,200
因為TCP本身是一個

263
00:12:11,200 --> 00:12:13,279
byte oriented protocol所以他在

264
00:12:13,279 --> 00:12:16,600
重送的時候 不管是封包掉了

265
00:12:16,600 --> 00:12:18,179
或者ack掉了或者ack delay了

266
00:12:19,179 --> 00:12:21,940
他都會繼續這個重送

267
00:12:21,940 --> 00:12:23,120
會引發這個重送的過程

268
00:12:24,120 --> 00:12:26,039
好那在重送呢送到這個ack

269
00:12:26,039 --> 00:12:27,639
我們說這個ack本身

270
00:12:27,639 --> 00:12:30,440
是用所謂的cumulative ack

271
00:12:30,440 --> 00:12:32,220
就是說 我們可以送很多的封包

272
00:12:33,220 --> 00:12:35,139
但是呢一個ack就可以把所有的封包

273
00:12:36,139 --> 00:12:38,899
統統把他回應回覆的意思確認

274
00:12:38,899 --> 00:12:41,259
也就是說這個ack裡面的這個

275
00:12:41,259 --> 00:12:43,039
acknowledge number 他是所謂的

276
00:12:43,039 --> 00:12:45,740
cumulaive他是有累積作用的

277
00:12:45,740 --> 00:12:49,019
好那我們也提到說TCP呢他怎麼做

278
00:12:49,019 --> 00:12:51,200
fast retransmission 就是因為

279
00:12:52,200 --> 00:12:53,860
原來這個timeout的時間

280
00:12:53,860 --> 00:12:57,000
設計上就是說當你真的封包掉的時候

281
00:12:57,000 --> 00:12:59,880
要等他真的timeout才重送的話

282
00:12:59,880 --> 00:13:01,919
這個等待的時間可能太長

283
00:13:01,919 --> 00:13:03,320
整個throughput會降低

284
00:13:04,320 --> 00:13:06,279
所以有一個機制就是說可以讓

285
00:13:07,279 --> 00:13:09,820
這個封包掉的這個訊息

286
00:13:09,820 --> 00:13:12,460
讓sender呢可以早一點知道

287
00:13:12,460 --> 00:13:14,039
好那我們就是說就有

288
00:13:14,039 --> 00:13:16,279
所謂的three duplicated ack

289
00:13:16,279 --> 00:13:21,320
就是如果我們收到三次重複的ack

290
00:13:21,320 --> 00:13:22,960
就是一樣的ack

291
00:13:22,960 --> 00:13:25,960
收到三次就重覆三次的話

292
00:13:25,960 --> 00:13:29,960
我們就把他判定說那一個封包就已經掉了

293
00:13:29,960 --> 00:13:32,779
所以我們就提早retransmission

294
00:13:32,779 --> 00:13:35,360
這個叫所謂的fast retransmission的概念

295
00:13:35,360 --> 00:13:37,519
好那最後呢我們介紹了

296
00:13:37,519 --> 00:13:39,740
TCP的congestion control這是

297
00:13:39,740 --> 00:13:42,539
非常非常重要的一個機制 就是說

298
00:13:42,539 --> 00:13:45,960
TCP他必須知道網路到底有沒有壅擠

299
00:13:45,960 --> 00:13:48,220
那壅擠的時候他怎麼辦

300
00:13:48,220 --> 00:13:51,720
怎麼加速然後怎麼減速啦

301
00:13:51,720 --> 00:13:54,399
那我們說他的做法就是叫做AIMD

302
00:13:54,399 --> 00:13:56,600
叫做additive的increace

303
00:13:56,600 --> 00:13:59,759
然後multiplicative的這種decrease

304
00:13:59,759 --> 00:14:03,620
就是增加的時候呢是線性加速

305
00:14:03,620 --> 00:14:05,039
然後減速的時候呢是一次減一半

306
00:14:06,039 --> 00:14:10,279
就是快速減速 那我們說AIMD的做法呢

307
00:14:10,279 --> 00:14:14,740
是比較適合當我這個TCP傳送的這個速度

308
00:14:14,740 --> 00:14:17,500
已經快靠近網路的上限

309
00:14:17,500 --> 00:14:20,419
所以我就線性的慢慢的逼近

310
00:14:20,419 --> 00:14:21,080
網路的上限啦

311
00:14:22,080 --> 00:14:24,899
可是呢TCP剛剛建連線的時候呢

312
00:14:24,899 --> 00:14:27,240
如果也是這麼慢的靠近的話

313
00:14:27,240 --> 00:14:28,899
這個時間拖太久

314
00:14:28,899 --> 00:14:30,080
所以連線剛建立的時候呢

315
00:14:31,080 --> 00:14:33,380
我們說會用一個叫做slow start

316
00:14:33,380 --> 00:14:36,000
就是比較指數的快速的逼近

317
00:14:37,000 --> 00:14:39,980
就是所謂的指數性的加速

318
00:14:39,980 --> 00:14:43,440
好那slow start呢讓我們這個TCP連線

319
00:14:43,440 --> 00:14:45,919
剛建立的時候就可以快速的接近這個

320
00:14:45,919 --> 00:14:46,120
網路的上限

321
00:14:47,120 --> 00:14:49,740
好那我們說不管是slow start

322
00:14:49,740 --> 00:14:51,380
或者AIMD的方法

323
00:14:51,380 --> 00:14:54,019
不管哪一個方法 不管是指數增加

324
00:14:55,019 --> 00:14:57,720
指數加速或者是線性加速

325
00:14:57,720 --> 00:15:00,799
我們都要知道說那萬一網路

326
00:15:00,799 --> 00:15:02,600
已經開始阻塞的時候

327
00:15:02,600 --> 00:15:04,139
那網路開始阻塞的時候有兩個

328
00:15:05,139 --> 00:15:08,240
一個就是如果發生triple duplicated ack

329
00:15:09,240 --> 00:15:10,100
我們代表示packet lost

330
00:15:11,100 --> 00:15:13,679
那我們說 他實作congestion的這個減半

331
00:15:14,679 --> 00:15:17,980
但如果發生timeout我們認定說

332
00:15:17,980 --> 00:15:20,759
發生timeout通常是網路的這個情形

333
00:15:20,759 --> 00:15:21,200
阻塞的更嚴重

334
00:15:22,200 --> 00:15:23,720
所以我們就把那個congestion window

335
00:15:23,720 --> 00:15:26,259
直接降為ㄧ 就是timeout的時候

336
00:15:26,259 --> 00:15:27,159
不管原來是多少

337
00:15:27,159 --> 00:15:29,880
我就降為ㄧ然後再exponential長

338
00:15:29,880 --> 00:15:32,419
長到原來的一半然後變成linear

339
00:15:32,419 --> 00:15:33,940
這就是timeout的時候呢

340
00:15:33,940 --> 00:15:35,320
最典型的做法就是把

341
00:15:36,320 --> 00:15:38,980
congestion window的值直接降為一個MSS

342
00:15:38,980 --> 00:15:41,360
然後exponential的增加

343
00:15:41,360 --> 00:15:42,880
一直到他碰到這個

344
00:15:42,880 --> 00:15:44,980
這個這個我們叫做threshold

345
00:15:44,980 --> 00:15:47,179
threshold是原來這個window的一半

346
00:15:47,179 --> 00:15:48,019
然後變成linear

347
00:15:49,019 --> 00:15:51,039
這樣的做法就是所謂的timeout的時候呢

348
00:15:52,039 --> 00:15:53,019
TCP怎麼做congestion window

349
00:15:54,019 --> 00:15:57,340
好所以總結來說 TCP是一個

350
00:15:57,340 --> 00:16:00,980
非常可靠的服務 他提供了非常

351
00:16:00,980 --> 00:16:03,860
reliable的service可是TCP本身

352
00:16:03,860 --> 00:16:05,899
必須自己知道去判斷

353
00:16:05,899 --> 00:16:07,659
這個網路是不是壅擠

354
00:16:07,659 --> 00:16:09,659
沒有壅擠的時候他開始加速

355
00:16:09,659 --> 00:16:11,659
壅擠的時候開始減速

356
00:16:11,659 --> 00:16:12,940
這樣的機制的話

357
00:16:12,940 --> 00:16:16,820
讓TCP呢就變成說一個 非常非常強韌

358
00:16:16,820 --> 00:16:18,880
那可以根據這個網路的狀態

359
00:16:18,880 --> 00:16:21,600
隨時調整他傳送的這個速度

360
00:16:21,600 --> 00:16:23,740
這個就是整個TCP的這個做法

361
00:16:23,740 --> 00:16:25,419
也就是我們在這章裡面

362
00:16:25,419 --> 00:16:27,279
介紹了transport layer protocol

363
00:16:27,279 --> 00:16:28,759
的運作的這個原理啦
