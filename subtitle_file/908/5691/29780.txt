2
00:00:09,450 --> 00:00:10,250
在接下來這章呢

3
00:00:11,250 --> 00:00:14,410
我們要跟各位介紹呢就是所謂的Transport Layer protocol

4
00:00:14,410 --> 00:00:18,180
就是在我們網路這個所謂的七層的結構裡面呢

5
00:00:18,180 --> 00:00:21,010
所謂的第四層 所謂的Transport Layer

6
00:00:21,010 --> 00:00:24,650
好在這章裡面呢 我們要跟各位介紹的

7
00:00:24,650 --> 00:00:28,580
首先我們先做一個所謂的end to end protocol的簡介

8
00:00:28,580 --> 00:00:32,210
就是說因為在Transport Layer 他所牽涉到的就是

9
00:00:32,210 --> 00:00:35,650
主機對主機 就是我們的host 對 host

10
00:00:35,650 --> 00:00:37,880
一般也就是所謂的end to end

11
00:00:37,880 --> 00:00:41,079
因為end代表說他已經是最邊邊的啦

12
00:00:41,079 --> 00:00:44,750
就是一般我們的筆電啊 手機啊 像這種server

13
00:00:44,750 --> 00:00:48,610
那他們之間怎麼溝通 那叫end to end protocol。

14
00:00:48,610 --> 00:00:50,380
然後呢我們也會介紹

15
00:00:50,380 --> 00:00:54,510
所謂Transport Layer裡面兩個最具代表性的protocol

16
00:00:54,510 --> 00:00:57,310
一個叫做ＵＤＰ 一個叫做ＴＣＰ

17
00:00:57,310 --> 00:01:02,310
ＵＤＰ本身呢 他還是提供unreliable 的service

18
00:01:02,310 --> 00:01:06,410
那ＴＣＰ呢就提供了所謂的reliable可靠的service。

19
00:01:06,410 --> 00:01:09,849
那我們首先呢 先來介紹一下基本的背景

20
00:01:09,849 --> 00:01:14,450
我們說啊 在一個Transport Layer protocol

21
00:01:14,450 --> 00:01:19,650
第四層的protocol 通常我們是希望他能夠提供

22
00:01:19,650 --> 00:01:21,750
我們說哪一些的service

23
00:01:21,750 --> 00:01:25,780
第一個我們說 我們希望這個Transport Layer protocol

24
00:01:25,780 --> 00:01:29,410
能夠提供所謂的guarantee 的message的delivery

25
00:01:29,410 --> 00:01:34,980
是比較保證說這個傳輸呢是非常的可靠

26
00:01:34,980 --> 00:01:38,980
他保證這個資料可以成功送到對方

27
00:01:38,980 --> 00:01:42,110
因為例如說以ＴＣＰ來講的話

28
00:01:42,110 --> 00:01:44,709
他是一個非常可靠的傳輸的protocol

29
00:01:44,709 --> 00:01:47,450
那我們什麼時候會用到TCP呢

30
00:01:47,450 --> 00:01:51,550
如說我們做檔案的傳輸 我們知道說

31
00:01:51,550 --> 00:01:54,450
這個檔案的傳輸是絕對不能錯的

32
00:01:54,450 --> 00:01:57,250
因為檔案如果傳輸的過程當中發生錯誤

33
00:01:57,250 --> 00:02:02,110
這就麻煩了 所以檔案的傳輸一定要百分之百完全正確

34
00:02:02,110 --> 00:02:05,049
所以如果你交給internet

35
00:02:05,049 --> 00:02:08,750
那我們說internet是一個unreliable的 這個封包會掉

36
00:02:08,750 --> 00:02:11,349
可能會延遲 順序也會不對等等

37
00:02:11,349 --> 00:02:15,479
但是呢我們如果交給所謂的Transport protocol

38
00:02:15,479 --> 00:02:22,080
他就我們希望他能夠做到第一個可靠保證的傳輸

39
00:02:22,080 --> 00:02:26,979
第二個呢 我們希望same order 就是順序也要對

40
00:02:26,979 --> 00:02:30,050
就是我這個檔案 如果要做傳輸的時候

41
00:02:30,050 --> 00:02:33,080
我把這個檔案的內容 因為我檔案可能很大

42
00:02:33,080 --> 00:02:36,150
我的內容譬如說會切成一部分一部分

43
00:02:36,150 --> 00:02:40,650
丟給這個所謂的Transport Layer 他透過網路送出來

44
00:02:40,650 --> 00:02:43,449
就是說怎麼進去跟怎麼出來

45
00:02:43,449 --> 00:02:50,050
這個進去的順序跟出來的順序至少我的內容的順序要完全一樣

46
00:02:50,050 --> 00:02:53,310
我們說same order 就他的順序不可能亂掉

47
00:02:53,310 --> 00:02:56,509
這是指我的內容的順序不能亂掉

48
00:02:57,509 --> 00:03:01,580
然後呢對於每一個message最多只收到一個copy

49
00:03:01,580 --> 00:03:07,810
就是我們在送的這個過程當中 因為可能有發生問題

50
00:03:07,810 --> 00:03:11,880
重送啊等等 但是呢對於每一個message

51
00:03:11,880 --> 00:03:16,849
最多只能收到一份 重複接收就會發生錯誤

52
00:03:16,849 --> 00:03:22,509
然後希望能夠support任意大的message

53
00:03:22,509 --> 00:03:27,979
就是因為我們的檔案可能非常大 可能是幾百個byte

54
00:03:27,979 --> 00:03:33,180
甚至幾個GB或是更大更大的幾十個GB都有可能

55
00:03:33,180 --> 00:03:38,349
譬如說video檔案很大 這麼大的檔案我們都可以送

56
00:03:38,349 --> 00:03:41,410
就是說你的message很大也沒有關係

57
00:03:41,410 --> 00:03:44,479
因為我們會把它切割 就是說大的message

58
00:03:44,479 --> 00:03:46,979
我們會把他切割 所以沒有問題

59
00:03:46,979 --> 00:03:51,610
接下來我們希望一個Transport protocol能夠提供

60
00:03:51,610 --> 00:03:56,150
所謂的synchronization between sender and receiver

61
00:03:56,150 --> 00:04:00,550
就是送的這端跟收的這端他們能夠保持同步的關係

62
00:04:00,550 --> 00:04:03,580
就是說我們的那個狀態 我們的步調

63
00:04:03,580 --> 00:04:06,880
我們的節奏 希望能夠維持同步

64
00:04:06,880 --> 00:04:12,780
還有希望說 這個receiver他可以用所謂的

65
00:04:12,780 --> 00:04:21,410
flow control來控制這個sender因為送收等於說是合作的夥伴

66
00:04:21,410 --> 00:04:27,550
這個receiver他能不能收這個封包完全看他的resource

67
00:04:27,550 --> 00:04:30,449
那所謂他的resource就是說 他有一個buffer

68
00:04:30,449 --> 00:04:34,850
可以把這個從sender過來的封包呢 先把它存起來

69
00:04:34,850 --> 00:04:42,009
那這個buffer的大小就決定了說這個sender到底可以送多少的量進來

70
00:04:42,009 --> 00:04:45,779
因為如果說buffer太小 那sender送的太多

71
00:04:45,779 --> 00:04:50,980
就有可能因為容納不下可能會被丟掉 這很麻煩

72
00:04:50,980 --> 00:04:57,649
所以我們說receiver本身他通常可以做一個叫做flow control

73
00:04:57,649 --> 00:04:59,949
flow control就是流量控制

74
00:04:59,949 --> 00:05:05,180
就是receiver他控制sender送出來的流量

75
00:05:05,180 --> 00:05:11,750
例如說流量的多寡 甚至說流量的速度 就是那個節奏

76
00:05:11,750 --> 00:05:14,050
sender到底什麼時候可以送封包進來

77
00:05:14,050 --> 00:05:18,509
或者說可以送多少的資料量進來

78
00:05:18,509 --> 00:05:23,709
由receiver來管控 receiver他有這個主控權

79
00:05:23,709 --> 00:05:32,579
他想讓sender暫時不要送他就讓sender停住不要送

80
00:05:32,579 --> 00:05:39,880
就是receiver要有一個機制可以做所謂的flow control

81
00:05:39,880 --> 00:05:39,880
還有就是說j我們希望每一個host

82
00:05:41,880 --> 00:05:50,350
每一台主機上面可以run多個不同的application 的process

83
00:05:50,350 --> 00:05:53,850
每一台電腦上面可以run不同的application

84
00:05:53,850 --> 00:05:57,009
我可以run FTP 做檔案傳輸

85
00:05:57,009 --> 00:06:02,680
我可以run telnet 譬如說所謂的bbs做這個遠端連線

86
00:06:02,680 --> 00:06:05,579
我可以run browser  我可以做瀏覽器

87
00:06:05,579 --> 00:06:10,509
可以看stream 看電影 看視頻等等

88
00:06:10,509 --> 00:06:14,079
就我們的主機上面會有同時很多application在run

89
00:06:14,079 --> 00:06:18,449
那我們這個Transport layer也要能夠提供這樣的服務

90
00:06:18,449 --> 00:06:21,180
就是說雖然說有很多application同時run

91
00:06:22,180 --> 00:06:25,180
但是我的封包進來的時候呢 我可以知道說

92
00:06:25,180 --> 00:06:29,509
這個封包到底是要給哪一個application的意思

93
00:06:29,509 --> 00:06:33,279
也就是說我們這個Transport layer希望能夠support

94
00:06:33,279 --> 00:06:36,110
能夠multiple application 的process

95
00:06:36,110 --> 00:06:38,579
同時在一個host上面執行

96
00:06:39,579 --> 00:06:44,079
我們對一個Transport layer的要求就是剛剛介紹的

97
00:06:44,079 --> 00:06:49,110
我們要可靠的傳輸 要保證 順序不能錯

98
00:06:49,110 --> 00:06:57,310
資料也不可以不一樣還要提供所謂的multiple application

99
00:06:57,310 --> 00:06:59,110
但是我們如果往下看

100
00:06:59,110 --> 00:07:03,380
說我們的internet本身到底提供什麼樣的服務呢

101
00:07:03,380 --> 00:07:07,380
我們希望Transport提供很好的服務

102
00:07:07,380 --> 00:07:11,480
可是他的下一層 就是所謂的internet本身

103
00:07:11,480 --> 00:07:13,410
提供的服務是什麼呢

104
00:07:13,410 --> 00:07:19,750
我們說他是一個會drop message的服務因為ip internet本身

105
00:07:19,750 --> 00:07:26,250
我們講她的封包會被router因為所謂的overflow或者因為congestion

106
00:07:26,250 --> 00:07:28,880
他的封包可能會被router drop掉

107
00:07:28,880 --> 00:07:34,209
然後他會reorder 因為我們說在internet上面每一個封包

108
00:07:34,209 --> 00:07:39,209
他到底會走哪一條路徑每個封包可能都是獨立的 都不一樣的

109
00:07:39,209 --> 00:07:43,779
所以先送不一定就先到 可能先送後到

110
00:07:43,779 --> 00:07:47,949
後送先到 所以他的順序會不一樣

111
00:07:47,949 --> 00:07:51,880
第三個有可能會發生duplicate copies

112
00:07:51,880 --> 00:07:57,250
就是一個封包丟出去可能這個destination會收到兩個 或兩個以上。

113
00:07:57,250 --> 00:08:03,550
還有封包要經過一個網路的時候 會有一個大小限制

114
00:08:03,550 --> 00:08:06,649
我們叫做MTU Maximum Transmission Unit

115
00:08:06,649 --> 00:08:12,449
因為不同網路他能夠接受的最大封包的這個size不一樣

116
00:08:12,449 --> 00:08:14,810
所以我們說一個封包如果太大

117
00:08:14,810 --> 00:08:17,550
他要進到某一個網路進不去的時候

118
00:08:17,550 --> 00:08:20,550
我們說router會做fragmentation

119
00:08:20,550 --> 00:08:25,980
他會把它切割成小片段 小片段送到目的地再去做組合

120
00:08:25,980 --> 00:08:28,250
還有一個最關鍵的就是說

121
00:08:28,250 --> 00:08:31,009
這個封包丟給這個network layer

122
00:08:31,009 --> 00:08:35,850
他可能會經歷我們叫做非常非常長的delay

123
00:08:35,850 --> 00:08:38,580
就是因為每一個封包在傳送的時候

124
00:08:38,580 --> 00:08:40,580
因為他都被獨立的轉送

125
00:08:40,580 --> 00:08:42,909
那轉送本身就給router

126
00:08:42,909 --> 00:08:44,409
那router他會有routing table

127
00:08:44,409 --> 00:08:48,009
那我們說這個routing table他是動態變更的

128
00:08:48,009 --> 00:08:49,880
因為他會交換 或是怎麼樣

129
00:08:49,880 --> 00:08:54,850
那routing protocol他隨時會去更新這個routing table

130
00:08:54,850 --> 00:08:58,009
所以這個封包進來的時候走這條路

131
00:08:58,009 --> 00:09:02,509
同樣一個source要到同樣一個destination的封包

132
00:09:02,509 --> 00:09:05,480
可能會繞到別的路 可能這樣繞繞繞

133
00:09:05,480 --> 00:09:10,049
所以有可能在網路上面會經歷非常非常長的delay

134
00:09:10,049 --> 00:09:11,179
也就是說呢

135
00:09:11,179 --> 00:09:14,149
事實上我們講這個network layer的service

136
00:09:14,149 --> 00:09:19,480
網路層的服務呢 我們說他是unreliable 的service

137
00:09:19,480 --> 00:09:24,409
network的service是unreliable 是不可靠的

138
00:09:24,409 --> 00:09:29,610
但是我們希望我們的Transport protocol是可靠的

139
00:09:29,610 --> 00:09:32,450
變成說在不可靠的環境之下

140
00:09:32,450 --> 00:09:35,309
我們講network layer是不可靠的

141
00:09:35,309 --> 00:09:37,679
可是Transport layer要可靠的

142
00:09:37,679 --> 00:09:43,009
就是說他的挑戰在於說 我們說所以呢

143
00:09:43,009 --> 00:09:45,450
Transport layer protocol最大的挑戰

144
00:09:45,450 --> 00:09:47,450
就是他必須有一個方法

145
00:09:47,450 --> 00:09:53,210
這個方法就是說他的底層是unreliable 的service

146
00:09:53,210 --> 00:09:59,110
他要把一個不可靠的服務把它變成可靠的服務

147
00:09:59,110 --> 00:10:01,250
這就是他的挑戰

148
00:10:01,250 --> 00:10:04,549
也就是說這個network layer 的底層是不可靠的

149
00:10:04,549 --> 00:10:09,309
你丟給他 他可能會掉 順序可能不對 可能會重複

150
00:10:09,309 --> 00:10:15,409
可能會delay很久 但是我要提供給我的這個application

151
00:10:15,409 --> 00:10:17,149
我的服務呢是可靠的

152
00:10:17,149 --> 00:10:20,610
你送給我什麼我就丟給上面什麼 我非常可靠

153
00:10:20,610 --> 00:10:25,710
我的順序也會對 我也不會掉你給我什麼就送給你什麼

154
00:10:25,710 --> 00:10:31,279
等於說在不可靠的環境之下 要提供可靠的服務

155
00:10:31,279 --> 00:10:35,980
那我們說當然在第四層Transport layer裡面有兩類

156
00:10:35,980 --> 00:10:39,350
一個是ＵＤＰ 那ＵＤＰ呢

157
00:10:39,350 --> 00:10:43,880
因為他本身也是提供所謂不可靠的服務

158
00:10:43,880 --> 00:10:48,580
所以如果我們第四層是ＵＤＰ 那就比較單純

159
00:10:48,580 --> 00:10:51,710
因為不可靠的服務變成不可靠的服務

160
00:10:51,710 --> 00:10:56,450
所以這個ＵＤＰ相對就簡單 反正下層是不可靠

161
00:10:56,450 --> 00:10:59,549
我提供的服務也是不可靠 所以我幾乎什麼事都不用做

162
00:10:59,549 --> 00:11:03,580
我只要把封包打包好 就丟下去就是了

163
00:11:03,580 --> 00:11:06,549
反正我是依賴下層 下層不可靠

164
00:11:06,549 --> 00:11:11,380
反正UDP也是不可靠啊 那所以這個關係就比較直接

165
00:11:12,380 --> 00:11:12,380
比較簡單

166
00:11:12,880 --> 00:11:16,179
但是我們剛剛提到 對於如果是ＴＣＰ

167
00:11:16,179 --> 00:11:18,309
這問題就比較沒那麼簡單了齁

168
00:11:18,309 --> 00:11:22,149
因為ＴＣＰ提供的是可靠的服務

169
00:11:22,149 --> 00:11:26,779
可是他的下層他的底層是不可靠的服務

170
00:11:26,779 --> 00:11:30,909
那我們說這個才是最大的challenge 最大的挑戰

171
00:11:30,909 --> 00:11:36,250
就是我怎麼樣在一個不可靠的環境之下能夠設計出一個方法來

172
00:11:36,250 --> 00:11:40,110
提供非常可靠的服務 這是ＴＣＰ的挑戰

173
00:11:40,110 --> 00:11:44,980
那底下我們就來介紹所謂的ＵＤＰ

174
00:11:44,980 --> 00:11:49,809
ＵＤＰ本身剛才提到他是不可靠的服務

175
00:11:49,809 --> 00:11:53,880
也就是說他是用不可靠的服務來提供不可靠的服務

176
00:11:53,880 --> 00:11:58,580
那為什麼要有這種東西 就是說已經第三層已經不可靠

177
00:11:58,580 --> 00:12:00,779
第四層還弄一個不可靠的

178
00:12:00,779 --> 00:12:08,809
是因為我們至少在第四層的服務裡面我們需要把第三層

179
00:12:08,809 --> 00:12:13,649
我們講第三層是host to host 就像internet裡面

180
00:12:13,649 --> 00:12:18,509
我們的ip這個封包 都是指說丟到某一台主機

181
00:12:18,509 --> 00:12:22,610
因為一個ip位址他代表某一台電腦

182
00:12:22,610 --> 00:12:27,880
但是我們真的要溝通的是上面的application

183
00:12:28,880 --> 00:12:32,909
目的是軟體對軟體 就程式應用對應用

184
00:12:32,909 --> 00:12:39,279
但是呢一個ip只能代表是某一台主機 或某一台電腦

185
00:12:39,279 --> 00:12:43,009
我們說一個電腦上面可以run很多application

186
00:12:43,009 --> 00:12:46,450
所以如果我們只靠ip 我們只能知道說

187
00:12:46,450 --> 00:12:48,880
這個ip是屬於哪一台電腦

188
00:12:48,880 --> 00:12:53,509
但是我們不知道他是屬於哪一個application的process

189
00:12:53,509 --> 00:12:59,580
所以這個UDP本身就是把host to host 的這種delivery

190
00:12:59,580 --> 00:13:00,779
就是我一個封包

191
00:13:00,779 --> 00:13:05,480
從一個ip source丟到一個destination之外

192
00:13:05,480 --> 00:13:09,149
我希望能夠再往上一步

193
00:13:09,149 --> 00:13:12,710
希望能夠做到所謂的process to process

194
00:13:12,710 --> 00:13:15,509
就是從某一個process丟給某一個process

195
00:13:15,509 --> 00:13:19,809
這樣的話我們就必須加了一層叫做demultiplexing

196
00:13:19,809 --> 00:13:24,509
demultiplexing就是說我的這個ＵＤＰ

197
00:13:24,509 --> 00:13:27,080
這個protocol當我收到一個封包的時候

198
00:13:27,080 --> 00:13:33,009
我必須把它分配到不同的application

199
00:13:33,009 --> 00:13:39,450
就是說因為我們一台電腦上面會有很多process在上面同時執行

200
00:13:39,450 --> 00:13:46,380
我收到一個封包的時候我怎麼知道這個封包到底要給哪一個process

201
00:13:46,380 --> 00:13:48,380
到底是哪一個process的呢

202
00:13:48,380 --> 00:13:56,450
那我們就說 這是因為我們的做法就是靠DstPrt 因為在ＵＤＰ裡面

203
00:13:56,450 --> 00:14:02,110
我們讓每一個這個process本身都會有一個所謂的port

204
00:14:02,110 --> 00:14:09,750
在UDP裡面我們除了ip我們說ip位址是辨識到某一台主機

205
00:14:09,750 --> 00:14:13,480
主機上面會有很多application

206
00:14:13,480 --> 00:14:17,049
那這個每一個application怎麼去區隔他們呢

207
00:14:17,049 --> 00:14:22,549
就是用port number還好我們這個ＵＤＰ丟出去的封包

208
00:14:22,549 --> 00:14:25,809
他會有一個叫做DstPrt number

209
00:14:25,809 --> 00:14:29,580
代表說這個封包是要丟給這個port的

210
00:14:29,580 --> 00:14:33,509
這個封包是從哪一個port丟出來

211
00:14:33,509 --> 00:14:40,179
那這個port代表是source ip就是丟這個封包的那台ip

212
00:14:40,179 --> 00:14:46,580
他的port number 那DstPrt是指destination

213
00:14:46,580 --> 00:14:52,380
就是我們講DIP 就是收到這個封包的這個電腦

214
00:14:52,380 --> 00:14:58,450
上面的哪個port代表application 一個是從source來的

215
00:14:58,450 --> 00:15:01,980
他從哪個port進來 到了目的地之後

216
00:15:01,980 --> 00:15:06,110
他要給哪一個application就用SrcProt跟DstPrt

217
00:15:07,110 --> 00:15:11,480
這兩個port number來區隔 我們來看一下

218
00:15:11,480 --> 00:15:16,610
什麼叫做所謂的demultiplex 就是說像這個例子裡面

219
00:15:16,610 --> 00:15:22,580
我們假設這個主機上面run了三個application

220
00:15:22,580 --> 00:15:26,909
有綠色的藍色的橘色的 這是不同的application

221
00:15:26,909 --> 00:15:32,009
那我們不同的application到底怎麼區隔說到底誰是誰

222
00:15:32,009 --> 00:15:35,850
我們都用port number 所以這個port很重要

223
00:15:35,850 --> 00:15:41,149
譬如說我們很多有名的 譬如說domain name server

224
00:15:41,149 --> 00:15:44,279
domain name server 給我們查那個domain name的

225
00:15:44,279 --> 00:15:48,450
他就是port 53 也就是說我們不同的port number

226
00:15:48,450 --> 00:15:52,509
其實他會對應到所謂的應用啦

227
00:15:52,509 --> 00:15:57,049
所以不同應用的process他有不同的port number

228
00:15:57,049 --> 00:16:07,080
當我們收到一個封包的時候我們就根據這個封包的DstPrt

229
00:16:07,080 --> 00:16:14,509
我們根據這個DstPrt就可以知道說他應該往哪邊丟

230
00:16:14,509 --> 00:16:20,950
第一個封包假如他的port number是Ｚ DstPrt是Ｚ

231
00:16:20,950 --> 00:16:25,610
那我們就丟到這個port上面去 當然每一個port

232
00:16:25,610 --> 00:16:30,179
因為application本身他要處理封包

233
00:16:30,179 --> 00:16:33,809
application本身要處理封包也要用到ＣＰＵ

234
00:16:33,809 --> 00:16:37,409
那因為每一個電腦上面通常只有一個ＣＰＵ

235
00:16:37,409 --> 00:16:41,779
或者說這個ＣＰＵ是要被scheduling 要排程

236
00:16:41,779 --> 00:16:46,450
所以什麼時候run到這個application是ＯＳ幫我們排的

237
00:16:46,450 --> 00:16:49,809
所以我們封包雖然要給這個process

238
00:16:49,809 --> 00:16:52,610
可是這個process可能沒辦法立刻處理這個封包

239
00:16:52,610 --> 00:16:56,710
所以通常會有一個queue在這個地方 就是說

240
00:16:56,710 --> 00:17:04,480
我們要把這個封包丟給某一個process但這個process不見得他會有辦法立刻處理內容

241
00:17:04,480 --> 00:17:07,210
所以我們通常會把它放到queue裡面

242
00:17:07,210 --> 00:17:14,009
所以每一個process都有一個queue 所以這個封包進來

243
00:17:14,009 --> 00:17:19,809
如果他剛好是要給port Z 就是綠色這個application

244
00:17:19,809 --> 00:17:22,410
我們就丟到他的queue裡面去 像這個例子

245
00:17:22,410 --> 00:17:26,509
這個queue裡面已經有兩個封包 現在進來就第三個

246
00:17:26,509 --> 00:17:31,210
就排隊啦 如果再來一個封包 他是要給port X

247
00:17:31,210 --> 00:17:35,250
要給藍色的這個application的話 我們一樣把它放到

248
00:17:35,250 --> 00:17:42,109
這個藍色process他的queue裏頭去 在這個例子裡面

249
00:17:42,109 --> 00:17:46,210
這個queue裡面已經有三個封包 所以我就放進去

250
00:17:46,210 --> 00:17:47,750
當然這個queue的內容

251
00:17:47,750 --> 00:17:54,710
就看上面這個application什麼時候他被ＯＳ把他排程

252
00:17:54,710 --> 00:18:00,279
把它schedule到 他就去抓這個資料他就去處理這個資料

253
00:18:00,279 --> 00:18:06,650
所以這個地方我們是來解釋說當UDP收到一個封包的時候

254
00:18:06,650 --> 00:18:12,480
收到一個ＵＤＰ的封包 他會看他的DstPrt

255
00:18:12,480 --> 00:18:19,180
根據port number把這個封包丟給哪一個application的queue就把它放進去

256
00:18:19,180 --> 00:18:23,000
然後就等 他們相對的application來處理這個封包 Subtitles End: mo.dbxdb.com
