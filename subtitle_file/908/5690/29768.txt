1
00:00:08,950 --> 00:00:11,709
好，那接下來我們來跟各位介紹

2
00:00:11,710 --> 00:00:14,410
所謂的IP的切割的部分

3
00:00:14,410 --> 00:00:17,580
我們叫做IP fragmentation跟reassembly

4
00:00:17,580 --> 00:00:21,849
就是什麼時候這個IP的封包會被在網路上面被切割

5
00:00:21,850 --> 00:00:24,210
然後什麼時候呢再把它組合起來

6
00:00:24,210 --> 00:00:26,510
然後呢怎麼樣組合起來

7
00:00:26,510 --> 00:00:28,680
我因為我們說這個封包

8
00:00:28,680 --> 00:00:31,910
在internet上面傳送可能會有out-of-order

9
00:00:31,910 --> 00:00:32,780
順序會亂掉

10
00:00:32,780 --> 00:00:36,610
所以我們在收到這些切割的片段

11
00:00:36,610 --> 00:00:38,680
我們到底怎麼把它組合起來

12
00:00:38,680 --> 00:00:40,410
我們說來介紹一下

13
00:00:40,410 --> 00:00:45,150
首先呢我們說每一個網路呢都有一個叫做MTU

14
00:00:45,150 --> 00:00:48,850
我們叫做maximum transmission unit

15
00:00:48,850 --> 00:00:50,550
就是說這個封包

16
00:00:50,550 --> 00:00:57,250
依這個網路呢它可以接受的這個封包的最大的這個size

17
00:00:57,250 --> 00:00:59,380
那譬如說我們講ethernet

18
00:00:59,380 --> 00:01:03,350
Ethernet的封包最大是1518個byte

19
00:01:03,350 --> 00:01:05,50
Ethernet是1518

20
00:01:05,50 --> 00:01:08,210
那我們說IEEE 802.11就是wifi

21
00:01:08,210 --> 00:01:12,9
就是我們講的無線網路呢它是2312個byte

22
00:01:12,10 --> 00:01:17,450
那像還有另外早期的網路叫做FDDI這是一個光纖網路

23
00:01:17,450 --> 00:01:20,910
FDDI的光纖網路是4500個byte

24
00:01:20,910 --> 00:01:26,950
也就是說事實上不同的網路呢它都有一個不同的MTU的值

25
00:01:26,950 --> 00:01:29,480
就是maximum transmission unit

26
00:01:29,480 --> 00:01:32,210
就是你的封包大過這個MTU

27
00:01:32,210 --> 00:01:35,250
你就不能夠送到這個網路裡面來

28
00:01:35,250 --> 00:01:36,880
因為它就不會處理

29
00:01:36,880 --> 00:01:38,750
因為太大、超過它的規格了

30
00:01:38,750 --> 00:01:42,50
好，所以在這樣的條件之下

31
00:01:42,50 --> 00:01:46,979
我們就說那我們在封包的切割跟組合

32
00:01:46,980 --> 00:01:48,680
我們的策略是什麼

33
00:01:48,680 --> 00:01:50,650
我們說fragmentation

34
00:01:50,650 --> 00:01:53,850
我們發生在什麼地方呢，在router

35
00:01:53,850 --> 00:01:57,80
就是說當router收到一個封包

36
00:01:57,80 --> 00:01:59,480
然後呢我們查表之後

37
00:01:59,480 --> 00:02:03,210
發現說這個封包應該要往哪一個port

38
00:02:03,210 --> 00:02:06,449
或者哪一個網路把他送進去呢

39
00:02:06,450 --> 00:02:09,810
但是呢我們如果說發生了一個現象

40
00:02:09,810 --> 00:02:14,510
就是這個封包的size它大於那個網路的MTU

41
00:02:14,510 --> 00:02:19,109
代表說我們封包太大然後進不了那個網路

42
00:02:19,110 --> 00:02:21,850
因為那個網路它有一個MTU有一個上限

43
00:02:21,850 --> 00:02:24,810
那我們的封包太大了進不到那個網路裡面去了

44
00:02:24,810 --> 00:02:28,450
好，那我們就開始做所謂的fragmentation

45
00:02:28,450 --> 00:02:29,609
就開始切割的意思

46
00:02:29,610 --> 00:02:32,310
那切割之後呢

47
00:02:32,310 --> 00:02:34,510
當然就開始送到網路裡面去

48
00:02:34,510 --> 00:02:35,980
好，那我們就來看

49
00:02:35,980 --> 00:02:38,480
我們最後到底要怎麼把它組合起來

50
00:02:38,480 --> 00:02:42,649
那我們說這個組合的動作呢就叫做reassembly

51
00:02:42,650 --> 00:02:46,280
因為我們把它切割成若干個小片段

52
00:02:46,280 --> 00:02:50,710
然後就獨立的、分別的就送到，繼續往前走

53
00:02:50,710 --> 00:02:52,550
好，最後呢我們說

54
00:02:52,550 --> 00:02:58,250
這個組合的動作我們在host就是目的地呢再來做組合

55
00:02:58,250 --> 00:03:00,210
就是這個router本身不做組合

56
00:03:00,210 --> 00:03:05,50
好，那在組合的時候呢我們必須知道說

57
00:03:05,50 --> 00:03:11,910
這個片段或者說哪些片段它是屬於同樣原來的一個封包

58
00:03:11,910 --> 00:03:14,350
因為一個封包可能會被切

59
00:03:14,350 --> 00:03:17,210
下一個封包可能也會被切割

60
00:03:17,210 --> 00:03:20,180
說不定下一個封包又被切割

61
00:03:20,180 --> 00:03:22,410
所以當我的目的地收到的時候

62
00:03:22,410 --> 00:03:24,250
可能就一堆、一堆的碎片

63
00:03:24,250 --> 00:03:27,780
我怎麼知道哪些碎片屬於同一個封包

64
00:03:27,780 --> 00:03:31,210
哪些碎片又屬於那另外一個封包

65
00:03:31,210 --> 00:03:37,180
所以這些屬於同樣的一個IP datagram的這些碎片

66
00:03:37,180 --> 00:03:40,950
它必須有相同的ID的意思

67
00:03:40,950 --> 00:03:46,649
我們用這些碎片呢擁有相同的ID代表說

68
00:03:46,650 --> 00:03:50,780
它們是屬於同一個這個IP的datagram

69
00:03:50,780 --> 00:03:55,280
好，然後我們說這個被切割的這個fragment

70
00:03:55,280 --> 00:04:00,350
我們叫片段本身我們叫做self-contained的datagram

71
00:04:00,350 --> 00:04:08,210
就代表說被切割的小片段本身它也是一個完整的IP的datagram

72
00:04:08,210 --> 00:04:11,810
相當於說雖然一個封包被切成三個封包

73
00:04:11,810 --> 00:04:15,710
可這個三個封包本身都是一個完整的IP datagram

74
00:04:15,710 --> 00:04:19,480
只是呢它比較小  就是內容減少了

75
00:04:19,480 --> 00:04:21,780
可是呢IP header還是沒有減少

76
00:04:21,779 --> 00:04:25,609
就是說我們一個封包假設把它切成三個封包

77
00:04:25,610 --> 00:04:29,910
我們是把內容切三份  可是IP的header

78
00:04:29,910 --> 00:04:33,10
現在那個信封你必須複製三份

79
00:04:33,10 --> 00:04:39,110
內容把一封信我們把它內容剪成、撕成三個片段

80
00:04:39,110 --> 00:04:40,980
各塞進去這個信封裡面

81
00:04:40,980 --> 00:04:44,750
可是信封還是要有三個

82
00:04:44,750 --> 00:04:48,150
所以IP的header本身還是會被複製

83
00:04:48,150 --> 00:04:50,710
那我們說如果這個datagram

84
00:04:50,710 --> 00:04:54,349
或這個fragment本身擁有這個信封的話

85
00:04:54,350 --> 00:04:56,480
就是擁有這個IP的header

86
00:04:56,480 --> 00:05:00,210
那它就可以被獨立的繼續地往前走

87
00:05:00,210 --> 00:05:02,109
所以我們把它叫做self-contained

88
00:05:02,110 --> 00:05:05,180
因為它自己就可以被獨立的處理

89
00:05:05,180 --> 00:05:09,510
然後我們說如果這個在組合的時候

90
00:05:09,510 --> 00:05:14,810
因為我們說每一個片段都是一個獨立的這個datagram

91
00:05:14,810 --> 00:05:20,850
所以每一個片段呢可能在網路上面呢就被分別的被傳送

92
00:05:20,850 --> 00:05:24,910
但是我們說因為internet本身是unreliable

93
00:05:24,910 --> 00:05:29,250
所以每一個片段都有可能在傳送的過程當中呢

94
00:05:29,250 --> 00:05:33,50
被router丟棄或者說損毀

95
00:05:33,50 --> 00:05:35,180
好，所以最後一個host本身

96
00:05:35,180 --> 00:05:44,510
如果它在組合的時候呢發現說有部分的fragment、片段

97
00:05:44,510 --> 00:05:48,310
沒有出現或者沒有收到

98
00:05:48,310 --> 00:05:51,780
就是有漏掉或者遺失一些fragment的話

99
00:05:51,780 --> 00:05:53,710
那這個組合當然就不成功啦

100
00:05:53,710 --> 00:05:55,310
那不成功怎麼辦

101
00:05:55,310 --> 00:06:01,480
我們一直強調IP它本身是一個unreliable的service

102
00:06:01,480 --> 00:06:05,280
像這種組合失敗的IP datagram

103
00:06:05,280 --> 00:06:08,49
很簡單，就是直接把它丟掉

104
00:06:08,50 --> 00:06:10,810
因為你組合不起來了所以把它丟掉

105
00:06:10,810 --> 00:06:12,710
那丟掉之後怎麼辦  丟掉就丟掉

106
00:06:12,710 --> 00:06:19,710
因為我們一開始就跟各位介紹IP本來就是unreliable service

107
00:06:19,710 --> 00:06:20,450
它本來就不可靠

108
00:06:20,450 --> 00:06:23,479
我們講它是best effort，它盡力幫我們送

109
00:06:23,480 --> 00:06:29,380
那如果真的發生我這個fragment有遺漏啦 有遺失

110
00:06:29,380 --> 00:06:32,50
那很對不起我封包還是必須把它丟掉

111
00:06:32,50 --> 00:06:34,480
組合不起來的就把它丟掉這是沒辦法

112
00:06:34,480 --> 00:06:40,410
好，我們底下就來看一個這種封包切割跟組合的例子

113
00:06:40,410 --> 00:06:42,180
好，在這個例子呢

114
00:06:42,180 --> 00:06:46,250
這個網路的架構呢跟我們之前看的網路的結構是一樣

115
00:06:46,250 --> 00:06:48,480
就是說我有一個網段

116
00:06:48,480 --> 00:06:51,210
是一個無線網路的 H5

117
00:06:51,210 --> 00:06:53,510
然後我要送給一個H8

118
00:06:53,510 --> 00:06:55,349
它是在一個ethernet上面

119
00:06:55,350 --> 00:06:58,210
那我中間呢經過三個router

120
00:06:58,210 --> 00:07:01,409
R1、R2、R3，然後幫我轉送

121
00:07:01,410 --> 00:07:03,280
那在這個例子裡面我們說

122
00:07:03,280 --> 00:07:07,549
好，首先這個host最左邊這邊它丟了一個封包出來

123
00:07:07,550 --> 00:07:08,480
就長這個樣子

124
00:07:08,480 --> 00:07:14,50
那我們說它是從802.11因為它是wifi

125
00:07:14,50 --> 00:07:16,980
所以它用802.11的MAC丟出來

126
00:07:16,980 --> 00:07:19,610
那我們要特別注意到的是中間這個

127
00:07:19,610 --> 00:07:22,950
這個地方  這是IP的datagram

128
00:07:22,950 --> 00:07:25,610
丟出來之後呢

129
00:07:25,610 --> 00:07:28,910
當然這個封包就先丟給router 1

130
00:07:28,910 --> 00:07:30,710
所以router 1收到之後

131
00:07:30,710 --> 00:07:33,250
等於說這個封包它的路徑就這樣

132
00:07:33,250 --> 00:07:35,310
Router 1丟給router 1

133
00:07:35,310 --> 00:07:37,910
Router 1收到之後呢一樣查表

134
00:07:37,910 --> 00:07:40,950
發現說這個封包應該丟給router 2

135
00:07:40,950 --> 00:07:44,510
因為我們的目的地是H5到H8

136
00:07:44,510 --> 00:07:47,310
所以我們就丟給這個router 1

137
00:07:47,310 --> 00:07:49,550
那router 1收到之後就發現說

138
00:07:49,550 --> 00:07:51,580
這個封包應該要丟給router 2

139
00:07:51,580 --> 00:07:54,280
所以它就再用這個路把它丟給router2

140
00:07:54,280 --> 00:07:56,210
不過特別注意到就是說

141
00:07:56,210 --> 00:07:59,409
因為一開始它是802.11

142
00:07:59,410 --> 00:08:01,10
接下來已經變成ethernet了

143
00:08:01,10 --> 00:08:05,610
所以我們講那個MAC layer  就是第二層的header

144
00:08:05,610 --> 00:08:09,410
因為它必須根據你要送到哪個網路

145
00:08:09,410 --> 00:08:11,610
用那個網路的這個protocol

146
00:08:11,610 --> 00:08:16,410
那我們一開始第一段是wifi所以用802.11的header

147
00:08:16,410 --> 00:08:19,180
那第二段呢是ethernet所以用ethernet

148
00:08:19,180 --> 00:08:21,710
好，那現在這個問題在這裡

149
00:08:21,710 --> 00:08:26,250
我們現在這個router 2呢收到這個封包也查了表

150
00:08:26,250 --> 00:08:29,380
然後說應該要把它丟到router 3

151
00:08:29,380 --> 00:08:32,179
因為路線是要走router 3

152
00:08:32,179 --> 00:08:35,510
這個時候就發生說這個封包太大了

153
00:08:35,510 --> 00:08:39,179
我們的封包內容有1400個byte

154
00:08:39,179 --> 00:08:42,979
在這個例子裡面，1400個byte、這個例子

155
00:08:42,980 --> 00:08:46,210
那我們說如果要丟給這個PPP

156
00:08:46,210 --> 00:08:47,250
就是point to point

157
00:08:47,250 --> 00:08:51,480
那說這個point to point的網路呢最多是512個byte

158
00:08:51,480 --> 00:08:56,550
在這個地方它的封包的大小MTU是512

159
00:08:56,550 --> 00:08:59,349
那我的封包是1400個byte的內容

160
00:08:59,350 --> 00:09:02,50
可是接下來這個PPP這個網路

161
00:09:02,50 --> 00:09:04,780
它說它的最大是512

162
00:09:04,780 --> 00:09:05,980
所以我就把它切三塊

163
00:09:05,980 --> 00:09:08,710
在我們這個地方切三塊呢

164
00:09:08,710 --> 00:09:11,110
第一塊是放512 bytes

165
00:09:11,110 --> 00:09:14,210
第二塊也是放512 bytes

166
00:09:14,210 --> 00:09:17,680
那剩下的因為剩下來的就是376

167
00:09:17,680 --> 00:09:20,479
還剩376呢就放到第三個

168
00:09:20,480 --> 00:09:24,550
所以在這個router 2就做了這件事情

169
00:09:24,550 --> 00:09:29,209
就是把一個封包把它切成3個封包了

170
00:09:29,210 --> 00:09:34,110
那我們注意到這三個封包是把內容切三塊

171
00:09:34,110 --> 00:09:37,150
就是1400個bytes呢切成三塊

172
00:09:37,150 --> 00:09:40,780
但是每一塊呢都會有完整的IP

173
00:09:40,780 --> 00:09:45,850
所以IP的header是複製  IP的header是不切的

174
00:09:45,850 --> 00:09:50,280
Header是複製相當於信封是複製信封

175
00:09:50,280 --> 00:09:55,209
然後呢分割信紙，就是信紙的內容把它分割變成三個

176
00:09:55,210 --> 00:09:58,880
好，那這三個呢就開始往下送

177
00:09:58,880 --> 00:10:01,480
就變成說因為都獨立的嘛

178
00:10:01,480 --> 00:10:04,280
就送一個、送兩個、送三個

179
00:10:04,280 --> 00:10:09,650
這三個封包從等於說router 3收到這三個封包呢

180
00:10:09,650 --> 00:10:13,610
我們在這個例子裡面它並沒有把它做組合

181
00:10:13,610 --> 00:10:16,150
因為我們說這個reassembly的動作

182
00:10:16,150 --> 00:10:20,10
是交給最後的最後這個destination來做

183
00:10:20,10 --> 00:10:24,710
所以router 3收到這三個封包呢並沒有做組合

184
00:10:24,710 --> 00:10:27,750
它還是直接把這三個封包

185
00:10:27,750 --> 00:10:30,750
這三個router都收到了

186
00:10:30,750 --> 00:10:32,580
但是呢還是把它轉下去

187
00:10:32,580 --> 00:10:37,810
變成對於router3來講它收到三個小封包

188
00:10:37,810 --> 00:10:40,50
那它也轉三個小封包

189
00:10:40,50 --> 00:10:44,209
這三個小封包都到這個地方、到這裡，必須到這個IP

190
00:10:44,210 --> 00:10:46,710
好，它再開始做組合的動作

191
00:10:46,710 --> 00:10:52,350
那我們就來看看說那這個組合到底怎麼來做

192
00:10:52,350 --> 00:10:58,910
我們說  左邊這個圖呢就是原來還沒有切割的封包

193
00:10:58,910 --> 00:11:01,680
那我們注意到沒有切割的封包

194
00:11:01,680 --> 00:11:03,810
我怎麼知道這個封包沒有切割

195
00:11:03,810 --> 00:11:05,209
我們來看一下

196
00:11:05,210 --> 00:11:07,910
第一個我們叫做所謂的offset

197
00:11:07,910 --> 00:11:09,480
這是很重要的概念

198
00:11:09,480 --> 00:11:13,10
Offset就是說那你的data

199
00:11:13,10 --> 00:11:16,350
你原來裡面放的這個data

200
00:11:18,250 --> 00:11:22,480
在原來的封包的位置

201
00:11:22,480 --> 00:11:28,310
0就代表說它是在原來的第0個byte

202
00:11:28,310 --> 00:11:33,579
代表說它就是原來data的最前面的位置、最前面的位置

203
00:11:33,580 --> 00:11:36,380
好，注意到這個地方還有一個bit

204
00:11:36,380 --> 00:11:38,680
這個地方這個叫做frag

205
00:11:38,680 --> 00:11:43,250
這個叫做所謂的more frag，就是more fragment

206
00:11:43,250 --> 00:11:48,580
就是有沒有還有沒有這個fragment在我後面的意思

207
00:11:48,580 --> 00:11:52,180
好，如果說我的offset是0

208
00:11:52,180 --> 00:11:54,579
代表說我這個data呢

209
00:11:54,580 --> 00:11:57,750
就是在原來封包的最前面的位置

210
00:11:57,750 --> 00:12:01,850
然後他的bit，這個more fragment呢又是等於0

211
00:12:01,850 --> 00:12:06,610
代表說後面也沒有了  就代表說我是沒有切割的

212
00:12:06,610 --> 00:12:10,80
就是說我的資料是在原來的封包的最前面

213
00:12:10,80 --> 00:12:13,280
而且我後面已經沒有切割了

214
00:12:13,280 --> 00:12:16,550
所以這兩個參數呢如果都是0

215
00:12:16,550 --> 00:12:19,79
注意到這兩個通通都是0

216
00:12:19,80 --> 00:12:23,110
就代表說這個是沒有被切割的封包

217
00:12:23,110 --> 00:12:26,680
那什麼叫做有切割的封包呢

218
00:12:26,680 --> 00:12:28,380
我們看在這個例子裡面

219
00:12:28,380 --> 00:12:34,280
我們說這個封包剛剛那個例子被切成了三個fragment

220
00:12:34,280 --> 00:12:38,150
好，我們這個特別注意到這三個fragment是什麼意思

221
00:12:38,150 --> 00:12:41,380
首先，第一個fragment注意一下

222
00:12:41,380 --> 00:12:46,350
我們第一個fragment它的offset就是0

223
00:12:46,350 --> 00:12:50,280
第一個fragment這個offset就是0，在這裡

224
00:12:50,280 --> 00:12:54,350
因為第一個嘛  代表說我原來的data

225
00:12:54,350 --> 00:12:58,180
譬如說我原來的資料  譬如說是那麼多 這樣子

226
00:12:58,180 --> 00:13:01,780
那我們現在把它切三塊

227
00:13:01,780 --> 00:13:06,550
那其中這個第一塊就相當於把它放到這裡來

228
00:13:06,550 --> 00:13:11,609
那第一塊的位置就相當於data它的offset就是0

229
00:13:11,610 --> 00:13:13,310
代表說它在最左邊的意思

230
00:13:13,310 --> 00:13:17,780
好，那我們這個地方有一個bit變成1了

231
00:13:17,780 --> 00:13:21,150
剛剛提到這個叫more fragment

232
00:13:21,150 --> 00:13:26,449
1就代表說後面還有 後面還有 我是第一個位置

233
00:13:26,450 --> 00:13:29,610
我是在原來的位置  我是最左邊的位置

234
00:13:29,610 --> 00:13:30,680
可是後面還有

235
00:13:30,680 --> 00:13:34,410
就代表說這個封包是一個fragment

236
00:13:34,410 --> 00:13:38,280
因為它已經被切割了嘛所以後面還有

237
00:13:38,280 --> 00:13:42,350
好，那我們就看  那第二個呢這個地方注意到

238
00:13:42,350 --> 00:13:43,810
Offset等於64

239
00:13:43,810 --> 00:13:47,579
那這個offset的值是什麼意思呢

240
00:13:47,580 --> 00:13:49,280
這個64就是指這裡

241
00:13:49,280 --> 00:13:52,550
注意到這個位置  這個位置

242
00:13:52,550 --> 00:13:57,510
就是說64就代表說我這裡面的data  這個data

243
00:13:57,510 --> 00:14:01,880
在原來封包的位置是在什麼地方的意思

244
00:14:01,880 --> 00:14:03,780
好，阿這個64呢

245
00:14:03,780 --> 00:14:06,810
這裡面的offset值呢要乘上8

246
00:14:06,810 --> 00:14:12,650
我們，因為我們切割都是用8個bytes來做這個單位

247
00:14:12,650 --> 00:14:18,110
所以我們來看64乘上8就是512

248
00:14:18,110 --> 00:14:22,210
512剛好就是我們現在要看的

249
00:14:22,210 --> 00:14:25,150
因為我們第一個fragment

250
00:14:25,150 --> 00:14:28,579
就切了512 bytes

251
00:14:28,580 --> 00:14:32,350
所以這個64我們把它乘上8

252
00:14:32,350 --> 00:14:36,880
就代表說那我這個第二個512 bytes

253
00:14:36,880 --> 00:14:40,480
在原來的位置裡面呢這個一乘就是512

254
00:14:40,480 --> 00:14:42,880
這個64是因為就是這邊來的

255
00:14:42,880 --> 00:14:47,910
是因為我前面那個片段呢它有512 bytes

256
00:14:47,910 --> 00:14:53,579
所以呢我這個片段的位置就是在第512 bytes

257
00:14:53,580 --> 00:14:57,110
因為我們從0到511嘛

258
00:14:57,110 --> 00:14:59,80
所以我在512 bytes的意思

259
00:14:59,80 --> 00:15:04,250
那接下來這個呢第三個呢我們說它是128

260
00:15:04,250 --> 00:15:08,510
所以我們還是一樣用128去乘上8

261
00:15:08,510 --> 00:15:12,710
這個就是等於是1024了嘛

262
00:15:12,710 --> 00:15:14,280
1024就相當於說

263
00:15:14,280 --> 00:15:16,79
剛剛提到我們的封包是這樣子的

264
00:15:16,80 --> 00:15:19,950
第一個這邊是資料512 bytes

265
00:15:19,950 --> 00:15:22,50
這個是資料512 bytes

266
00:15:22,50 --> 00:15:26,510
因為我們第一個是512 第二個也是切成512

267
00:15:26,510 --> 00:15:29,410
那就剩下變成說

268
00:15:29,410 --> 00:15:33,50
那你第三個這個起始位置呢就是在這裡

269
00:15:33,50 --> 00:15:36,479
那這邊是512、這邊是512

270
00:15:36,480 --> 00:15:40,710
所以前面這邊已經用掉我們講就是1024了嘛

271
00:15:40,710 --> 00:15:46,50
所以我第三個  第三個它的位置就是這個一乘

272
00:15:46,50 --> 00:15:48,280
128乘8就是1024

273
00:15:48,280 --> 00:15:52,10
代表它就是從這裡開始的

274
00:15:52,10 --> 00:15:57,50
那我們根據這個offset  offset就是告訴我們說

275
00:15:57,50 --> 00:16:03,979
我們收到了這個片段它的資料到底在原來的封包的什麼位置

276
00:16:03,980 --> 00:16:09,950
那我們說假設剛好我們收到的順序呢是不一樣的

277
00:16:09,950 --> 00:16:12,780
那我們怎麼辦  譬如說我們再看一次

278
00:16:12,780 --> 00:16:15,709
那我們假設呢我們的封包還是這樣子

279
00:16:15,710 --> 00:16:18,480
那我先收到這個  先收到這個

280
00:16:18,480 --> 00:16:22,150
這個一收到我就說  Ok，那我的offset是64

281
00:16:22,150 --> 00:16:24,980
這個地方我就把它乘上8

282
00:16:24,980 --> 00:16:28,380
代表說我的data事實上是在原來的地方

283
00:16:28,380 --> 00:16:31,680
在這個地方，等於說這塊是我的這樣子

284
00:16:31,680 --> 00:16:34,380
第一個封包我就把這個填滿

285
00:16:34,380 --> 00:16:36,750
好，那我再來收到這個第二個

286
00:16:36,750 --> 00:16:38,880
那它說這個offset是0

287
00:16:38,880 --> 00:16:42,380
代表說我這個片段呢是在原來片段的最左邊

288
00:16:42,380 --> 00:16:44,610
那長度是多少，512

289
00:16:44,610 --> 00:16:47,250
好，那我就把這個512，事實上它就在這裡

290
00:16:47,250 --> 00:16:52,680
因為從0開始然後接512  然後我再收到第三個fragment

291
00:16:52,680 --> 00:16:57,150
它告訴我說  我這個位置呢是在128乘上8

292
00:16:57,150 --> 00:17:02,250
就是在這個地方  那我的size呢是376我就把它填完

293
00:17:02,250 --> 00:17:06,310
好，那我們在最後再介紹一下說

294
00:17:06,310 --> 00:17:11,609
那我怎麼知道這個fragment已經沒有了

295
00:17:11,609 --> 00:17:14,50
就剛好是三個呢，我怎麼知道呢

296
00:17:14,50 --> 00:17:16,909
我們這裡有一個技巧就是這個地方

297
00:17:16,910 --> 00:17:18,780
注意到這個是0

298
00:17:18,780 --> 00:17:24,579
0就代表說它這個fragment就是最後一個fragment

299
00:17:24,579 --> 00:17:27,579
因為這個0代表我們叫做more fragment

300
00:17:27,579 --> 00:17:30,149
More fragment等於0代表是沒有了

301
00:17:30,150 --> 00:17:32,610
它所以這個0就是最後一個

302
00:17:32,610 --> 00:17:34,580
我們注意到這個1代表說

303
00:17:34,580 --> 00:17:37,850
這個0代表說它是第一個

304
00:17:37,850 --> 00:17:41,610
因為offset等於0代表它是第一個 1代表說後面還有

305
00:17:41,610 --> 00:17:45,50
這個後面還有、這個後面沒有了

306
00:17:45,50 --> 00:17:49,310
所以我們根據這樣的這個資料我們就可以知道說

307
00:17:49,310 --> 00:17:53,750
這個offset等於0，所以它是擺第一個位置

308
00:17:53,750 --> 00:17:59,10
這個more fragment等於0它是擺最後一個位置

309
00:17:59,10 --> 00:18:03,10
然後長度是多少  這個地方我們都有offset嘛

310
00:18:03,10 --> 00:18:05,410
所以我們知道這應該哪裡擺

311
00:18:05,410 --> 00:18:12,350
所以根據這些資料我們就可以把一個封包被切成若干個fragment

312
00:18:12,350 --> 00:18:15,280
然後送到網路上面去沒有關係

313
00:18:15,280 --> 00:18:18,450
我們最後收到的時候呢就根據這些資料

314
00:18:18,450 --> 00:18:22,110
我們根據這個、根據這個、根據這個

315
00:18:22,110 --> 00:18:23,679
我們就可以把它兜起來

316
00:18:23,680 --> 00:18:25,380
那我們說那萬一

317
00:18:25,380 --> 00:18:29,850
譬如說這個封包不見了  那我們就會發生這個現象

318
00:18:29,850 --> 00:18:32,850
第一個這個是放這裡嘛

319
00:18:32,850 --> 00:18:36,379
這個是0是最尾巴所以我們就放這裡

320
00:18:36,380 --> 00:18:39,610
這樣我們都放了  可是中間沒有來

321
00:18:39,610 --> 00:18:42,979
中間沒有來就是我們剛剛講missing、它掉了

322
00:18:42,980 --> 00:18:46,880
那你組合不起來  那要等多久呀

323
00:18:46,880 --> 00:18:50,580
因為我們知道網路  封包在網路上面會被delay

324
00:18:50,580 --> 00:18:55,480
所以我們在組合封包的時候呢我們會設一個時間上限

325
00:18:55,480 --> 00:18:59,850
譬如說在這個時間內我沒有辦法完全組合起來

326
00:18:59,850 --> 00:19:03,649
好，那我這個整個就不要了就把它丟掉

327
00:19:03,650 --> 00:19:08,350
因為組合不起來的封包就是沒有用了就直接把它丟棄

