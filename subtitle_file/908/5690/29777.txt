1
00:00:09,210 --> 00:00:11,180
好，那接下來我們來介紹

2
00:00:11,180 --> 00:00:14,680
我們說這個distance vector本身這個方法如果說

3
00:00:14,680 --> 00:00:17,380
它Detect到一個link fail掉的話

4
00:00:17,380 --> 00:00:21,349
那我們來用一個例子呢來介紹說它到底怎麼來處理

5
00:00:21,350 --> 00:00:25,780
那我們看這張圖裡面  我們這個網路的架構裡面呢

6
00:00:25,780 --> 00:00:29,350
有譬如說6個node、7個node本身

7
00:00:29,350 --> 00:00:31,750
然後呢我們現在假設說

8
00:00:31,750 --> 00:00:33,510
假設這個link呢

9
00:00:33,510 --> 00:00:36,580
譬如說F到G之間的link就突然壞掉了

10
00:00:36,580 --> 00:00:40,10
那這個壞掉的事件  我們說假設F

11
00:00:40,10 --> 00:00:44,10
因為F這個node它直接連了這個link嘛

12
00:00:44,10 --> 00:00:47,80
我們說這個F呢它偵測到說

13
00:00:47,80 --> 00:00:49,550
這個它跟G之間的link已經fail掉了

14
00:00:49,550 --> 00:00:54,110
壞掉了、那壞掉之後它就要通知它的neighbor嘛

15
00:00:54,110 --> 00:00:57,80
那等於說這個時候呢我們說這個F

16
00:00:57,80 --> 00:01:00,580
它就會告訴A  就它相鄰的這個router

17
00:01:00,580 --> 00:01:05,509
跟它說它現在到G  現在這個link呢已經斷線

18
00:01:05,510 --> 00:01:09,110
所以它的cost  我們說用無限大來表示

19
00:01:09,110 --> 00:01:11,210
代表說現在這條線已經不通了

20
00:01:11,210 --> 00:01:14,850
好，那我們說那A收到這個之後呢

21
00:01:14,850 --> 00:01:19,479
它就會把說它到G的現在已經是斷掉了

22
00:01:19,480 --> 00:01:20,810
因為是變得無限大

23
00:01:20,810 --> 00:01:24,580
那可是呢事實上因為我們說每一個router

24
00:01:24,580 --> 00:01:27,149
它們都會定期、不定期的會交換嘛

25
00:01:27,150 --> 00:01:32,950
所以這個時候呢C、C可能就會在適當的時間

26
00:01:32,950 --> 00:01:36,480
因為它會把它的routing table跟它的neighbor交換

27
00:01:36,480 --> 00:01:40,280
這個時候我們說假設C呢跟A做了交換

28
00:01:40,280 --> 00:01:43,680
那這個router C會告訴router A說

29
00:01:43,680 --> 00:01:46,580
它有一條路它的cost是2

30
00:01:46,580 --> 00:01:48,250
事實上這個路我們看原來是說

31
00:01:48,250 --> 00:01:50,980
C經過D可以到G嘛

32
00:01:50,980 --> 00:01:52,680
所以這個時候C呢

33
00:01:52,680 --> 00:01:57,680
它就告訴A說  它有一條路可以到G

34
00:01:57,680 --> 00:02:00,550
它的cost是2  好，那剛剛A呢

35
00:02:00,550 --> 00:02:02,710
收到說F跟它講說

36
00:02:02,710 --> 00:02:04,809
如果要經過F的話

37
00:02:04,810 --> 00:02:06,180
那個cost是無限大

38
00:02:06,180 --> 00:02:08,710
那現在C跟它說

39
00:02:08,710 --> 00:02:12,510
它有一條路經過C的話到G

40
00:02:12,510 --> 00:02:15,310
Cost只有2  所以A就想說

41
00:02:15,310 --> 00:02:19,180
好，那我既然從F到G已經變成無限大了

42
00:02:19,180 --> 00:02:22,980
那我可不可以透過C到F，這是可以的

43
00:02:22,980 --> 00:02:27,649
所以A呢就把它到G的cost本來是2

44
00:02:27,650 --> 00:02:29,810
那後來F跟它說無限大

45
00:02:29,810 --> 00:02:30,950
所以它設為無限大

46
00:02:30,950 --> 00:02:34,79
那現在C又跟它說這個cost是2

47
00:02:34,80 --> 00:02:37,680
所以A就想說那我如果經過2的話我cost就是3

48
00:02:37,680 --> 00:02:39,280
等於2再加1

49
00:02:39,280 --> 00:02:44,10
所以A就把它到G的cost呢變成3

50
00:02:44,10 --> 00:02:47,10
而且記錄著說是從C

51
00:02:47,10 --> 00:02:54,549
就經過C到G呢這個cost呢是3  同時呢A呢再告訴F說

52
00:02:54,550 --> 00:02:59,510
我有一條路到這個、到這個G呢是3

53
00:02:59,510 --> 00:03:03,679
事實上這條路呢  我們說是經過、經過這條路

54
00:03:03,680 --> 00:03:05,550
等於這條路是3嘛

55
00:03:05,550 --> 00:03:09,50
所以它就告訴這個、這個F說

56
00:03:09,50 --> 00:03:12,950
我現在我要告訴F說我有一條路經過C

57
00:03:12,950 --> 00:03:15,679
然後到G呢它的cost是3

58
00:03:15,680 --> 00:03:17,250
那這時候F本身

59
00:03:17,250 --> 00:03:20,880
因為它剛剛到這個G呢已經變成斷線了嘛

60
00:03:20,880 --> 00:03:22,350
所以它就記得說

61
00:03:22,350 --> 00:03:26,810
Okay，既然A有一條路可以到G它的cost是3

62
00:03:26,810 --> 00:03:28,610
那我就經過A

63
00:03:28,610 --> 00:03:32,910
所以F呢就把它改成它自己的cost到G呢

64
00:03:32,910 --> 00:03:36,650
剛剛是無限大現在就把它改成4

65
00:03:36,650 --> 00:03:38,850
變成說4經過A

66
00:03:38,850 --> 00:03:41,410
它的cost、它的路徑就這樣子

67
00:03:41,410 --> 00:03:43,880
也就是說在這個例子裡面呢

68
00:03:43,880 --> 00:03:47,49
我們可以看到一個link的譬如說斷線

69
00:03:47,50 --> 00:03:51,350
然後router呢會互相把這個消息互相傳遞出去

70
00:03:51,350 --> 00:03:53,950
那如果有另外一條路存在的話

71
00:03:53,950 --> 00:03:57,310
因為這樣透過這個routing table的交換

72
00:03:57,310 --> 00:04:01,350
我們就可以讓router呢去找到另外一條更好的路

73
00:04:01,350 --> 00:04:03,910
然後去更新它的這個routing table

74
00:04:03,910 --> 00:04:07,109
所以我們說雖然link壞掉

75
00:04:07,110 --> 00:04:11,450
我們還是可以偵測出來然後經過這個routing table的交換呢

76
00:04:11,450 --> 00:04:15,980
可以讓每一個router呢還是找到一個比較適當的路

77
00:04:15,980 --> 00:04:17,880
但是呢我們來看一下

78
00:04:17,880 --> 00:04:20,909
它有一個問題可能會發生

79
00:04:20,910 --> 00:04:23,650
我們叫做count-to-infinity problem

80
00:04:23,650 --> 00:04:28,650
就是說distance vector雖然經過這個所謂的routing table的交換

81
00:04:28,650 --> 00:04:31,710
可以找到所謂的另外一條路

82
00:04:31,710 --> 00:04:34,680
但是在有一些特殊的狀況之下

83
00:04:34,680 --> 00:04:38,710
可能會造成我們叫做網路的unstable

84
00:04:38,710 --> 00:04:41,150
就是說它那個routing table呢

85
00:04:41,150 --> 00:04:44,679
一直沒有辦法很穩定下來、沒有辦法收斂

86
00:04:44,680 --> 00:04:45,980
沒有辦法收斂意思就是說

87
00:04:45,980 --> 00:04:51,210
它的cost、到某一個點的cost會越來越大、越來越大

88
00:04:51,210 --> 00:04:53,109
那我們叫做count-to-infinity

89
00:04:53,110 --> 00:04:56,710
就等於說會一直增加、增加到無限大

90
00:04:56,710 --> 00:04:59,580
那這個是一個問題  那我們來看一個例子

91
00:04:59,580 --> 00:05:01,349
這到底是什麼樣問題

92
00:05:01,350 --> 00:05:05,610
我們來看一下假設呢剛剛一樣的這個網路的架構

93
00:05:05,610 --> 00:05:09,250
不過我們說在這個例子裡面我們假設

94
00:05:09,250 --> 00:05:12,750
A到E的link斷線、A到E

95
00:05:12,750 --> 00:05:16,310
那因為我們特別注意到E只連到A嘛

96
00:05:16,310 --> 00:05:17,650
在這個例子裡面

97
00:05:17,650 --> 00:05:21,10
所以如果A到E的這個link斷線的話

98
00:05:21,10 --> 00:05:23,409
只有A知道

99
00:05:23,410 --> 00:05:26,880
那A當然就覺得說它到E已經斷線了嘛

100
00:05:26,880 --> 00:05:28,580
所以它會告訴它的neighbor

101
00:05:28,580 --> 00:05:29,849
它會做這個動作

102
00:05:29,850 --> 00:05:32,180
我們說它會告訴它所有的neighbor

103
00:05:32,180 --> 00:05:36,550
告訴到E現在已經斷線  所以cost是無限大

104
00:05:36,550 --> 00:05:43,850
所以A會告訴F  然後A會告訴B也會告訴C說這個是無限大

105
00:05:43,850 --> 00:05:45,610
好，但是我們要記得說

106
00:05:45,610 --> 00:05:49,150
在這個還沒斷線之前、還沒斷線之前

107
00:05:49,150 --> 00:05:55,710
這個C它其實它是知道說它到E呢它的cost是2

108
00:05:55,710 --> 00:05:58,409
因為C在沒斷線之前

109
00:05:58,410 --> 00:06:02,910
C知道說它如果經過A的話到E的cost是2

110
00:06:02,910 --> 00:06:06,680
那B呢它也知道說在沒斷線之前

111
00:06:06,680 --> 00:06:10,350
B經過A到E呢cost也是2

112
00:06:10,350 --> 00:06:15,10
也就是說這個C跟B它們本來就記錄著一條路

113
00:06:15,10 --> 00:06:18,280
就是有一條路呢到E，Cost是2

114
00:06:18,280 --> 00:06:21,380
好，那我們說那現在斷線了

115
00:06:21,380 --> 00:06:24,750
現在斷線了然後斷線之後呢它廣播

116
00:06:24,750 --> 00:06:29,410
但是C它知道  它剛剛說它有一條路到E是2

117
00:06:29,410 --> 00:06:32,580
所以呢C就跟B講說

118
00:06:32,580 --> 00:06:35,349
我有一條路到E呢cost是2

119
00:06:35,350 --> 00:06:40,450
我們說剛剛這個A告訴這個B嘛

120
00:06:40,450 --> 00:06:43,210
跟它說這個路已經是無限大了

121
00:06:43,210 --> 00:06:44,580
然後現在呢

122
00:06:44,580 --> 00:06:47,979
C又跟B講說我有一條路是2

123
00:06:47,980 --> 00:06:49,510
所以B就是說

124
00:06:49,510 --> 00:06:50,880
好，那我就跟著你走

125
00:06:50,880 --> 00:06:56,810
所以B就認為說既然C跟它講有一條路呢到E，Cost是2

126
00:06:56,810 --> 00:06:59,810
那我如果、我如果走這條路

127
00:06:59,810 --> 00:07:02,850
不管C怎麼走的  我就經過C就是了

128
00:07:02,850 --> 00:07:06,950
那這樣子cost就是3嘛  所以B就認為說

129
00:07:06,950 --> 00:07:12,50
它可以有一條路  它的cost是3經過C的意思

130
00:07:12,50 --> 00:07:16,510
所以呢這個B它就會告訴A說

131
00:07:16,510 --> 00:07:21,710
我有一條路到E是3經過C

132
00:07:21,710 --> 00:07:24,609
等於說這個3其實在告訴A說

133
00:07:24,610 --> 00:07:29,450
B本身有一條路經過C然後事實上它是講這條路

134
00:07:29,450 --> 00:07:30,750
這樣子是3

135
00:07:30,750 --> 00:07:32,980
那這個A收到之後

136
00:07:32,980 --> 00:07:34,950
它就會覺得很高興說

137
00:07:34,950 --> 00:07:37,180
剛剛認為這個已經斷線了

138
00:07:37,180 --> 00:07:39,310
我告訴人家說我到E無限大

139
00:07:39,310 --> 00:07:41,80
現在B告訴我說

140
00:07:41,80 --> 00:07:45,810
它有一條路可以到E然後它的cost是3

141
00:07:45,810 --> 00:07:50,850
那A就覺得說現在多了一條路出來是經過B

142
00:07:50,850 --> 00:07:54,750
那可以是3  所以A呢就決定走這條路

143
00:07:54,750 --> 00:07:56,280
所以A這時候想就說

144
00:07:56,280 --> 00:07:58,510
好，那我就走B好了  走B這樣子

145
00:07:58,510 --> 00:08:03,980
好，那走B代表說它到E呢就會變成4嘛

146
00:08:03,980 --> 00:08:06,150
所以A它就告訴C說

147
00:08:06,150 --> 00:08:12,880
Okay，我現在找到新的一條路到E是4

148
00:08:12,880 --> 00:08:14,850
然後C就說

149
00:08:14,850 --> 00:08:18,80
好，那既然A告訴我現在是4了

150
00:08:18,80 --> 00:08:21,550
因為C知道說  我們特別注意到

151
00:08:21,550 --> 00:08:26,510
這個C  C本身一開始它說它是cost是2

152
00:08:26,510 --> 00:08:29,980
是經過A的  一開始是這樣子的

153
00:08:29,980 --> 00:08:31,950
那後來A跟它講無限大

154
00:08:31,950 --> 00:08:35,280
那現在A又跟它講說這個有一條路是4

155
00:08:35,280 --> 00:08:40,150
所以當初這個C它的2是經過A來的

156
00:08:40,150 --> 00:08:44,209
那但是A現在跟它講說這條路已經變成4了

157
00:08:44,210 --> 00:08:47,880
所以C就會告訴說  那我如果走A的話

158
00:08:47,880 --> 00:08:52,50
就會cost是4嘛  但是呢至少這條路存在

159
00:08:52,50 --> 00:08:56,680
但是cost變成4  所以C就跟B講說

160
00:08:56,680 --> 00:08:58,510
剛剛我跟你講那條路

161
00:08:58,510 --> 00:09:02,110
2的現在已經變成5了

162
00:09:02,110 --> 00:09:03,650
好，然後B呢就說

163
00:09:03,650 --> 00:09:07,50
好吧，那你剛剛告訴我本來cost是多少現在變成5

164
00:09:07,50 --> 00:09:08,780
那我還是繼續走這條路

165
00:09:08,780 --> 00:09:13,310
所以它就告訴A說剛剛那條路Cost變成6了

166
00:09:13,310 --> 00:09:16,880
所以我們就注意到  這裡面它有一個循環

167
00:09:16,880 --> 00:09:21,110
2、3然後告訴他說這個路是4

168
00:09:21,110 --> 00:09:23,380
它說這條路是已經變成5了

169
00:09:23,380 --> 00:09:27,350
剛剛講，sorry，再一次

170
00:09:27,350 --> 00:09:31,50
就是4然後它說這條路是5  然後他說這條路是6

171
00:09:31,50 --> 00:09:35,50
事實上再來就是7、8、9、10這樣  它在那邊繞圈圈

172
00:09:35,50 --> 00:09:41,209
就是那個路存在  但是它的cost一直被增加、增加這樣子

173
00:09:41,210 --> 00:09:44,650
那我們說這個增加會增加到什麼時候呢

174
00:09:44,650 --> 00:09:47,310
我們說它會增加到所謂的無限大

175
00:09:47,310 --> 00:09:52,150
當然無限大是不可能  因為我們在這個computer裡面

176
00:09:52,150 --> 00:09:55,949
我們這個所謂的hop在router裡面這個hop

177
00:09:55,950 --> 00:09:57,710
最多最多有一個上限

178
00:09:57,710 --> 00:10:00,880
所謂的無限大說它會增加到那個上限

179
00:10:00,880 --> 00:10:03,50
那個上限本身是多少

180
00:10:03,50 --> 00:10:03,979
我們等一下來解釋

181
00:10:03,980 --> 00:10:08,850
不過就是說在某一些比較特殊的情況之下

182
00:10:08,850 --> 00:10:11,980
我們這個cost本身會因為這樣子

183
00:10:11,980 --> 00:10:15,380
它會不斷地所謂的繞迴圈  就會這樣子繞

184
00:10:15,380 --> 00:10:17,680
就是說cost越來越大的意思

185
00:10:17,680 --> 00:10:20,609
那最後呢就會達到那個上限

186
00:10:20,610 --> 00:10:25,50
那我們說這種情況呢就叫做count-to-infinity的問題

187
00:10:25,50 --> 00:10:28,609
就是說distance vector在某些特定的情況之下

188
00:10:28,610 --> 00:10:30,910
那它會發生這樣的問題

189
00:10:30,910 --> 00:10:37,510
那我們說到底會誰開始來做這樣的事情

190
00:10:37,510 --> 00:10:38,280
就是剛剛講

191
00:10:38,280 --> 00:10:40,250
剛剛是從C開始說2嘛

192
00:10:40,250 --> 00:10:41,780
當然也有可能是B開始說

193
00:10:41,780 --> 00:10:44,480
就是那個方向也可能剛好倒過來

194
00:10:44,480 --> 00:10:50,710
那我們說這個depends on我們講事件發生的那個精確的時間

195
00:10:50,710 --> 00:10:53,910
就是因為剛剛提到  在剛剛那個例子裡面

196
00:10:53,910 --> 00:10:56,810
我們說在這個例子裡面呢

197
00:10:56,810 --> 00:11:02,510
是我們說是這個C跟B講說有2嘛

198
00:11:02,510 --> 00:11:05,550
當然也有可能說  B先跟C講說

199
00:11:05,550 --> 00:11:09,349
它的cost是2  那如果是B先跟C講的話

200
00:11:09,350 --> 00:11:12,680
那它就是這個方向  就剛好方向倒過來

201
00:11:12,680 --> 00:11:14,479
那我們說到底是

202
00:11:14,480 --> 00:11:20,810
哪個程序先開始  我們說depends on這個剛剛講

203
00:11:20,810 --> 00:11:24,650
A先、B先告訴C還是C先告訴B

204
00:11:24,650 --> 00:11:25,550
因為它們要交換嘛

205
00:11:25,550 --> 00:11:27,449
看哪個交換的動作比較快

206
00:11:27,450 --> 00:11:31,210
那我們下面這個例子就是剛剛講的這個例子

207
00:11:31,210 --> 00:11:32,650
那在這個例子裡面

208
00:11:32,650 --> 00:11:37,780
事實上我們說它是按照我們剛剛講的C比較快

209
00:11:37,780 --> 00:11:40,850
就是C呢它先講 它先講

210
00:11:40,850 --> 00:11:43,110
C先告訴B然後B告訴A

211
00:11:43,110 --> 00:11:45,680
然後A再告訴C、C再告訴B

212
00:11:45,680 --> 00:11:47,880
就這樣C、B、A、C、B、A這樣子

213
00:11:47,880 --> 00:11:49,210
好，那從3

214
00:11:49,210 --> 00:11:54,410
剛剛提到我們從hop 2改成3再改成4再改成5

215
00:11:54,410 --> 00:11:56,850
它就會一直加 加到所謂的無限大

216
00:11:56,850 --> 00:12:00,950
那我們說當然在、在真正的這個網路裡面

217
00:12:00,950 --> 00:12:03,210
當然不會讓它跑到無限大

218
00:12:03,210 --> 00:12:05,980
因為真正的這個網路裡面

219
00:12:05,980 --> 00:12:09,450
我們說一個我們要經過一個網路

220
00:12:09,450 --> 00:12:13,580
最多呢、最多也是經過這個router的數量

221
00:12:13,580 --> 00:12:14,750
差不多是16

222
00:12:14,750 --> 00:12:17,980
在真實的網路上面一個網路的

223
00:12:17,980 --> 00:12:19,980
我們講一般diameter、一個直徑

224
00:12:19,980 --> 00:12:21,910
我們要穿過這個網路

225
00:12:21,910 --> 00:12:25,910
那大概經過的router數16已經算是很高了

226
00:12:25,910 --> 00:12:28,880
所以我們就幾乎把這個16

227
00:12:28,880 --> 00:12:33,380
就當成是剛剛所謂的這個所謂的count-to-infinity

228
00:12:33,380 --> 00:12:38,50
那個無限大  基本上就可以用16數字來表示

229
00:12:38,50 --> 00:12:40,750
也就是我們如果說這個cost呢

230
00:12:40,750 --> 00:12:45,150
加到16的時候就認為大概是幾乎已經到了上限的意思

231
00:12:45,150 --> 00:12:47,480
好，那這個問題呢

232
00:12:47,480 --> 00:12:50,380
就是所謂的count-to-infinity的problem

233
00:12:50,380 --> 00:12:54,480
那我們接下來就來看說  那我們怎麼來解這個問題

234
00:12:54,480 --> 00:12:59,280
就是說我們這個hop數  就會越來越多嘛

235
00:12:59,280 --> 00:13:01,579
然後一直增加  那我們怎麼來解呢

236
00:13:01,580 --> 00:13:05,550
我們說有一個方法  這個方法我們叫做split horizon

237
00:13:05,550 --> 00:13:10,10
這個split horizon的意思就是說

238
00:13:10,10 --> 00:13:13,10
下面這句話的解釋就是說

239
00:13:13,10 --> 00:13:15,550
當一個node、一個router

240
00:13:15,550 --> 00:13:19,449
它在把它的routing table給它的neighbor

241
00:13:19,450 --> 00:13:21,380
因為我們router要互相交換嘛

242
00:13:21,380 --> 00:13:25,910
就是一個router把它的routing table給它的neighbor的時候

243
00:13:25,910 --> 00:13:31,880
那如果說它有一個路徑是從那個neighbor學到的

244
00:13:31,880 --> 00:13:36,380
那它就不把這個路徑呢  再送回去給neighbor

245
00:13:36,380 --> 00:13:40,410
所以我們看一下就是說  如果呢它有一個路徑

246
00:13:40,410 --> 00:13:43,709
它是從它的neighbor學到的

247
00:13:43,710 --> 00:13:48,380
那這個路徑呢在交換這個routing table的時候呢

248
00:13:48,380 --> 00:13:51,680
就不用在交換回去給它的neighbor

249
00:13:51,680 --> 00:13:56,150
避免我們剛剛講一個迴圈  就是A告訴譬如說

250
00:13:56,150 --> 00:13:59,850
B它說它有一個路徑是經過A

251
00:13:59,850 --> 00:14:03,610
所以B給A的時候呢  這個路徑就不用給了

252
00:14:03,610 --> 00:14:04,910
以剛剛的例子來看

253
00:14:04,910 --> 00:14:07,910
譬如說我們說剛才這個table裡面

254
00:14:07,910 --> 00:14:09,180
B有一個路徑

255
00:14:09,180 --> 00:14:11,449
說它到E呢

256
00:14:11,450 --> 00:14:16,250
我們說它到E，Cost是2那經過A

257
00:14:16,250 --> 00:14:20,50
我們再看一下就是說  這個B呢它有一個路徑

258
00:14:20,50 --> 00:14:25,550
這個路徑是說它到E，Cost是2然後經過A

259
00:14:25,550 --> 00:14:29,880
那這個路徑呢在哪裡我們來看一下  這個路徑就在這個地方

260
00:14:29,880 --> 00:14:34,510
B它有一個路徑  它到E呢cost是2

261
00:14:34,510 --> 00:14:36,850
因為我們經過兩個hop然後經過A

262
00:14:36,850 --> 00:14:41,680
就是事實上B的routing table裡面有這樣的一個entry說

263
00:14:41,680 --> 00:14:45,109
它到E呢cost是2

264
00:14:45,110 --> 00:14:46,880
可是呢經過A

265
00:14:46,880 --> 00:14:51,680
所以事實上我們說B本身是有這個路徑的

266
00:14:51,680 --> 00:14:55,709
好，那當B現在他要跟A溝通的時候

267
00:14:55,710 --> 00:15:01,910
就是說我們說B送一個routing table給A的時候

268
00:15:01,910 --> 00:15:07,110
他並不會把這個route、就是這個route

269
00:15:07,110 --> 00:15:10,180
到E呢cost是2

270
00:15:10,180 --> 00:15:14,709
這個東西呢就不會放在這個更新的這個資料裡面

271
00:15:14,710 --> 00:15:16,710
因為我們剛剛提到就是說

272
00:15:16,710 --> 00:15:19,810
B本身它裡面有一個entry叫做

273
00:15:19,810 --> 00:15:23,410
到E呢cost是2經過A、經過A嘛

274
00:15:23,410 --> 00:15:26,480
也就是說這個路徑是從A告訴它

275
00:15:26,480 --> 00:15:29,980
所以當B把它的routing table告訴A的時候

276
00:15:29,980 --> 00:15:32,850
這個路徑呢就不放在裡面

277
00:15:32,850 --> 00:15:35,910
不放在裡面它的意思就是說

278
00:15:35,910 --> 00:15:39,350
剛剛提到說這個斷線的時候

279
00:15:39,350 --> 00:15:44,650
斷線的時候呢我們在交換的過程當中

280
00:15:44,650 --> 00:15:49,680
我們就不會發生說  B告訴A說它的路徑是多少

281
00:15:49,680 --> 00:15:53,479
因為B到E的是經過A學的嘛

282
00:15:53,480 --> 00:15:58,680
所以B告訴A的時候就不用把這個路徑放在裡面

283
00:15:58,680 --> 00:16:00,50
那這樣就可以避免

284
00:16:00,50 --> 00:16:03,310
剛剛提到這個所謂的count-to-infinity problem

285
00:16:03,310 --> 00:16:06,579
好，那事實上除了這個count-to-infinity的problem

286
00:16:06,580 --> 00:16:09,10
這種split horizon的這種解法之外

287
00:16:09,10 --> 00:16:12,280
我們說它還有一個版本是更積極的

288
00:16:12,280 --> 00:16:15,680
我們叫做更strong的這種版本

289
00:16:15,680 --> 00:16:20,10
我們叫做split horizon with我們叫做poison reverse

290
00:16:20,10 --> 00:16:24,910
Poison reserve就代表是說這個反向是有毒的意思

291
00:16:24,910 --> 00:16:26,209
就是你根本不要走回來

292
00:16:26,210 --> 00:16:28,780
也就是這個時候B事實上呢

293
00:16:28,780 --> 00:16:31,780
也會把這個路徑送給A

294
00:16:31,780 --> 00:16:37,449
剛剛提到split horizon是不把這個路徑送給A

295
00:16:37,450 --> 00:16:41,110
但是split horizon with poison reverse

296
00:16:41,110 --> 00:16:43,410
是說它會把這個路徑送給A

297
00:16:43,410 --> 00:16:48,780
但是呢它會告訴A說這條路徑的cost是無限大

298
00:16:48,780 --> 00:16:53,110
就像這樣子就是說B本身送給A的時候它會說

299
00:16:53,110 --> 00:16:58,180
它有一個route是可以到E可是cost是無限大

300
00:16:58,180 --> 00:17:01,310
因為這個路徑呢是經過A的

301
00:17:01,310 --> 00:17:05,79
所以它就告訴A說它到A呢是無限大

302
00:17:05,79 --> 00:17:08,179
這個路徑它就告訴A是無限大

303
00:17:08,180 --> 00:17:12,110
是因為說它其實到E是經過A啦

304
00:17:12,109 --> 00:17:17,179
所以變成說這個所謂的我們講它的強度更強

305
00:17:17,180 --> 00:17:20,880
它split horizon是不告訴A

306
00:17:20,880 --> 00:17:22,510
那現在它是告訴A

307
00:17:22,510 --> 00:17:24,810
而且告訴A講這條路是無限大

308
00:17:24,810 --> 00:17:26,679
代表說我不走這條路的意思

309
00:17:26,680 --> 00:17:29,210
也就是這個時候B有點

310
00:17:29,210 --> 00:17:32,150
我們假設這邊是A、這邊是B

311
00:17:32,150 --> 00:17:36,880
那B有點告訴A說  它到E是無限大

312
00:17:36,880 --> 00:17:40,180
代表是說A要到E的話

313
00:17:40,180 --> 00:17:42,310
不要不要經過它的意思

314
00:17:42,310 --> 00:17:46,250
不要經過它  因為它說它到E是無限大

315
00:17:46,250 --> 00:17:50,310
那B說它到E是無限大代表說

316
00:17:50,310 --> 00:17:53,149
它到E沒有路的意思、沒有路

317
00:17:53,150 --> 00:17:57,210
所以A本身就不要想說你要經過B到E

318
00:17:57,210 --> 00:17:58,510
因為那條路不通的意思

319
00:17:58,510 --> 00:18:01,550
那事實上A就應該走它自己的路到E嘛

320
00:18:01,550 --> 00:18:05,810
所以這種所謂的split horizon with poison reverse

321
00:18:05,810 --> 00:18:12,10
它等於說把這樣可能造成的迴圈  完全的徹底的把它切掉

322
00:18:12,10 --> 00:18:16,80
那這個對於解決所謂的count-to-infinity的問題

323
00:18:16,80 --> 00:18:17,879
是一個比較好的解法

