2
00:00:09,410 --> 00:00:14,150
好那接下呢我們就來介紹這個ＴＣＰ的connection management

3
00:00:14,150 --> 00:00:21,010
就是說我們說ＴＣＰ在正式送data之前 他必須先建所謂的connection

4
00:00:21,010 --> 00:00:24,210
那我們來看看說這個connection是怎麼來建立的

5
00:00:24,210 --> 00:00:29,680
那我們說在建connection的時候 他要帶一個東西叫做sequence number

6
00:00:29,680 --> 00:00:34,880
因為我們說ＴＣＰ本身是一個byte stream oriented protocol

7
00:00:34,880 --> 00:00:38,410
就是說他那個每一個byte都會給他一個sequence number

8
00:00:38,410 --> 00:00:45,009
所以兩邊在建這個連線的時候 一定雙方要告訴對方說我等一下的data

9
00:00:45,009 --> 00:00:48,480
我的sequence number要從哪一個號碼開始

10
00:00:48,480 --> 00:00:52,950
sequence number不一定從0 雙方只要通知對方就可以了

11
00:00:52,950 --> 00:00:58,680
所以我們在建連線的時候呢 要把sequence number告訴對方

12
00:00:58,680 --> 00:01:02,450
也就是說我們在建連線的時候要帶一個sequence number到對方去

13
00:01:02,450 --> 00:01:09,480
同時第二個就是說我們自己要保留buffer 因為我們連線建立的過程當中

14
00:01:09,480 --> 00:01:16,650
我們等一下就要收對方送過來的data 那我們到底可以收對方多少data

15
00:01:16,650 --> 00:01:22,780
我們講那個flow control做流量控制 所以我們必須把這個buffer先把它保存起來

16
00:01:22,780 --> 00:01:26,680
甚至告訴對方說這個所謂的RcvWindow

17
00:01:26,680 --> 00:01:29,250
就是我們叫advertised window

18
00:01:29,250 --> 00:01:36,079
就是你把buffer多大告訴對方 讓對方知道你要怎麼控制對方送過來的流量

19
00:01:36,079 --> 00:01:41,250
那我們說這個建連線 一定有一方來所謂的發起 假設我們通訊的兩端

20
00:01:41,250 --> 00:01:47,150
假設我們通訊的兩端我們一般一邊叫做所謂的server 一邊叫做client

21
00:01:47,150 --> 00:01:50,079
叫做我們的model 叫做所謂的client-server model

22
00:01:50,079 --> 00:01:54,680
那通常我們這個連線的發起者通常都是client

23
00:01:54,680 --> 00:01:58,180
因為一般的server它都是等著人家建連線

24
00:01:58,180 --> 00:02:02,680
像我們一般的mail server, web server, FTP server

25
00:02:02,680 --> 00:02:09,479
就是我們的server通常都是等在那個地方 由client主動提出連線的需求

26
00:02:09,479 --> 00:02:13,910
client本身會送出這個等一下會介紹 叫做connection request

27
00:02:13,910 --> 00:02:19,580
會把那個連線的需求送過來 那怎麼樣去啟動這個連線的這個需求

28
00:02:19,580 --> 00:02:26,050
也就是說我們在所謂的socket programming裡面有一種就是說我們產生一個叫做socket

29
00:02:26,050 --> 00:02:27,550
就是建立一個socket的意思

30
00:02:27,550 --> 00:02:31,750
那建立一個socket就是我們代表說我要跟對方建連線

31
00:02:31,750 --> 00:02:35,280
那你要跟對方建連線第一個當然要有對方的ip

32
00:02:35,280 --> 00:02:40,380
所以我們這邊host name 建連線的時候第一個就是要有對方的ip

33
00:02:40,380 --> 00:02:43,849
第二個就是要有他的port 到底是跟哪一個port

34
00:02:43,849 --> 00:02:47,580
因為我們說不同的port通常代表不同的application

35
00:02:47,580 --> 00:02:51,250
上面的不同的process。所以我們如果要跟對方建連線

36
00:02:51,250 --> 00:02:54,849
你必須講對方是誰 他的ip 還有他的port number

37
00:02:54,849 --> 00:02:57,780
這樣我們就可以透過所謂的socket

38
00:02:57,780 --> 00:03:02,580
就是一般ＯＳ會提供這個socket的ＡＰＩ 讓我們來呼叫

39
00:03:02,580 --> 00:03:06,250
那透過呼叫這個socket我們就可以跟對方建連線

40
00:03:06,250 --> 00:03:11,880
那我們說server本身一般都是比較被動 他是所謂的contact by client

41
00:03:11,880 --> 00:03:17,680
他就等 那可是這個server本身在等人家來建連線

42
00:03:17,680 --> 00:03:23,849
他在等的這個過程當中他也必須先建一個所謂的welcome socket

43
00:03:23,849 --> 00:03:26,650
等於說他也是一樣 他把那個socket打開

44
00:03:26,650 --> 00:03:30,050
然後就等對方來建連線 這是一個基本的過程

45
00:03:30,050 --> 00:03:34,710
那我們說TCP建連線 他是用所謂的Three-way handshakes

46
00:03:34,710 --> 00:03:41,349
就是說建連線的過程當中必須有所謂的三次的交握。第一個就是他會送一個

47
00:03:41,349 --> 00:03:48,479
第一步呢我們說這個client 因為我們說這個連線的建立人是由client發起的

48
00:03:48,479 --> 00:03:55,050
所以client送的第一個封包呢 他的TCP的封包這個SYN 就是這個bit

49
00:03:55,050 --> 00:03:58,479
這個flag要設為1 代表說他要建連線的意思

50
00:03:58,479 --> 00:04:04,080
那server收到這個ＳＹＮ代表說有一個client要跟我建連線

51
00:04:04,080 --> 00:04:08,050
那如果我同意跟他建連線的話我就會回送一個封包

52
00:04:08,050 --> 00:04:12,849
那這個封包我會把這個ＳＹＮ跟ＡＣＫ 這兩個flag通通設為1

53
00:04:12,849 --> 00:04:19,410
那發起這個連線需求的client 他收到這個ＳＹＮ/ＡＣＫ之後

54
00:04:19,410 --> 00:04:24,079
他要再回覆另外一個ACK 所以我們叫做Three-way handshakes

55
00:04:24,079 --> 00:04:27,949
就這個是過去的 這個是回來的 這個再過去的

56
00:04:27,949 --> 00:04:33,180
就等於說1,2,3這樣子的過程當中呢 連線才會建起來

57
00:04:33,180 --> 00:04:40,180
我們用一個圖來解釋譬如說我們在這個圖裡面 我們說左邊就是我們的client

58
00:04:40,180 --> 00:04:44,750
這個地方是我們的client 右邊是我們的server 就是client-server

59
00:04:44,750 --> 00:04:50,009
那首先client本身他要建連線的時候 他就會送出第一個封包

60
00:04:50,009 --> 00:04:55,980
我們說第一個封包送過來 那這個封包本身他會把SYN這個bit設為1

61
00:04:55,980 --> 00:04:59,779
代表說他要建連線。那同時把他的sequence number

62
00:04:59,779 --> 00:05:02,279
他的sequence number也要把他

63
00:05:02,279 --> 00:05:09,350
這個數字也要告訴對方說我等一下我要送的data 我的sequence number是多少

64
00:05:09,350 --> 00:05:16,380
好那因為我們建連線的過程當中 sender收到之後他就要回一個

65
00:05:16,380 --> 00:05:18,810
我們剛剛講回一個叫做ＳＹＮ/ＡＣＫ

66
00:05:18,810 --> 00:05:21,550
要把這個ＳＹＮ ＡＣＫ這兩個bit都設為1

67
00:05:21,550 --> 00:05:29,250
那同時我們特別強調說因為雖然雙方建連線可是連線建起來之後

68
00:05:29,250 --> 00:05:34,149
我們叫做所謂的bidirectional 或者說fully duplicate

69
00:05:34,149 --> 00:05:38,009
就是說連線建起來之後data是兩邊都可以同時送的

70
00:05:38,009 --> 00:05:46,050
就是連線可能是由一端發起但是連線一旦建立之後兩邊都可以同時送data

71
00:05:46,050 --> 00:05:51,579
就是說他需要這邊從client到server有一個sequence number

72
00:05:51,579 --> 00:05:57,480
從server到client也會有sequence number 因為兩邊是同時會在送data

73
00:05:57,480 --> 00:06:04,149
所以我們這邊說server回應的這個封包裡面 他也必須帶上一個sequence number

74
00:06:04,149 --> 00:06:13,509
我們叫做Y 假設叫做Ｙ那同時這個server要跟client講說他剛剛那個封包他已經收到了

75
00:06:13,509 --> 00:06:17,649
而且他正在等他的data 所以我們會有一個叫acknowledgement

76
00:06:17,649 --> 00:06:20,810
我們說在這個ＴＣＰ的header裡面

77
00:06:20,810 --> 00:06:27,810
這個acknowledgement代表的意義就是說我現在收到對方的送來的資料的接收的狀態

78
00:06:27,810 --> 00:06:36,310
那acknowledgement X加1就代表說我等一下就是等你的data他的sequence number必須是X加1開始的意思

79
00:06:36,310 --> 00:06:43,980
所以X加1就是告訴對方說 我等一下就是在等那個data從Ｘ＋1開始

80
00:06:43,980 --> 00:06:53,579
好那我們說這個封包丟到client之後 client本身他的連線就建起來了

81
00:06:53,579 --> 00:07:01,810
對client來講的話因為這個一問一答 是對client來說他連線已經建好了

82
00:07:01,810 --> 00:07:07,850
因為他送出request而且server回應他了。但是這個答應這個封包

83
00:07:07,850 --> 00:07:13,810
client要讓server知道說他收到了 所以他一定在回一個的意思

84
00:07:13,810 --> 00:07:19,209
類似雙方確認的意思。因為你看到目前為止的話 client送一個收一個

85
00:07:19,209 --> 00:07:23,550
所以他已經確認 因為他送一個收一個。可是對server來講

86
00:07:23,550 --> 00:07:28,250
他只送一個啊 那他不確定這個封包對方有沒有收到啊

87
00:07:28,250 --> 00:07:33,149
因為這個封包有可能包括這個 這個封包萬一在中間掉了

88
00:07:33,149 --> 00:07:36,649
那這個連線其實是沒有建起來 但是server就不知道啊

89
00:07:36,649 --> 00:07:42,380
所以對client跟server來講他們都一定要收到一個確認的意思

90
00:07:42,380 --> 00:07:44,750
所以我們說第三個 這就是確認

91
00:07:44,750 --> 00:07:51,610
等於說client回給server確認說這個連線是有建起來 而且他回了什麼呢

92
00:07:51,610 --> 00:07:56,610
他在這個確認的這個封包裡面他回一個ＡＣＫ 這個bit設為1

93
00:07:56,610 --> 00:07:59,880
代表說ok ＳＹＮ ＡＣＫ ＡＣＫ

94
00:07:59,880 --> 00:08:04,880
同時我們說這個acknowledgement number他要寫成Ｙ＋1

95
00:08:04,880 --> 00:08:09,910
為什麼是Ｙ＋1 因為剛剛這個server說

96
00:08:09,910 --> 00:08:15,350
從server過來的封包他的sequence number從Y開始

97
00:08:15,350 --> 00:08:20,350
那現在client就說好那我就等你的下一個就是Ｙ＋1

98
00:08:20,350 --> 00:08:28,079
所以剛剛我們再看一次就是說client本身他是說他的sequence number是Ｘ

99
00:08:28,079 --> 00:08:32,279
所以server就回他說那我就等你這個sequence number出來

100
00:08:32,279 --> 00:08:36,549
那同時server說他的sequence number是Y

101
00:08:36,549 --> 00:08:41,880
那client就說好那我就等你的sequence number等下就要開始用

102
00:08:41,880 --> 00:08:47,380
所以這個是對等的。所以經過這樣的Three-way handshakes

103
00:08:47,380 --> 00:08:52,210
我們說這個connection就可以建起來 就是說先送一個過去

104
00:08:52,210 --> 00:08:54,250
在送一個回來 再送一個過去

105
00:08:54,250 --> 00:08:57,080
那這就是非常有名的我們叫做Three-way handshakes

106
00:08:57,080 --> 00:09:00,080
就是他們交握要三次 1,2,3這樣子

107
00:09:00,080 --> 00:09:07,210
好那如果我們把這個ＴＣＰ的這個連線建完之後 我們就可以開始送封包

108
00:09:07,210 --> 00:09:11,149
那每一個封包裡面當然就帶sequence number

109
00:09:11,149 --> 00:09:15,480
那我們特別強調說ＴＣＰ header裡面的sequence number

110
00:09:15,480 --> 00:09:21,279
他指的是這個封包裡面所攜帶的data 因為data可能有大有小

111
00:09:21,279 --> 00:09:24,950
這個data的第一個byte的sequence number

112
00:09:24,950 --> 00:09:30,509
就是說header裡面的sequence number指的是他所攜帶的data的第一個byte

113
00:09:30,509 --> 00:09:37,710
所以我第一個封包去 變成說sequence number是Ｘ 那下一個封包 sequence number是多少呢

114
00:09:37,710 --> 00:09:40,279
不是Ｘ＋1 是看你這個封包帶了多少

115
00:09:40,279 --> 00:09:46,779
等於說Ｘ要加上這個封包量才是下一個這個封包的sequence number

116
00:09:46,779 --> 00:09:53,009
好那接下來我們說當我們把這個data都送完了 因為資料傳送完畢之後呢

117
00:09:53,009 --> 00:09:56,880
我們必須把connection把它我們叫做結束掉 把它close

118
00:09:56,880 --> 00:10:02,649
connection要建立也要把它終結的意思 我們說要終結一個connection

119
00:10:02,649 --> 00:10:08,049
他的過程也是很類似也是幾乎就是相當於也是Three-way handshakes

120
00:10:08,049 --> 00:10:16,080
也是要交握的意思。我們說client 這個連線結束可以雙方都可以

121
00:10:16,080 --> 00:10:19,580
譬如說client來說要結束或者server要結束都可以

122
00:10:19,580 --> 00:10:25,880
我們這邊的例子是說假設是client開始想要把這個連線把它結束掉

123
00:10:25,880 --> 00:10:30,580
那他就呼叫一個所謂的socket 一樣呼叫socket programming

124
00:10:30,580 --> 00:10:35,980
就叫做close 就代表說我現在要把某一個連線結束掉

125
00:10:35,980 --> 00:10:40,679
那連線結束會做什麼事情呢 首先他會送一樣 送一個封包出來

126
00:10:40,679 --> 00:10:45,080
這個封包特別強調所謂的ＦＩＮ ＦＩＮ代表所謂的finish

127
00:10:45,080 --> 00:10:49,279
一樣我們說ＴＣＰ的header裡面有六個很重要的flag

128
00:10:49,279 --> 00:10:54,009
那其中的一個就是所謂的ＦＩＮ 代表finish

129
00:10:54,009 --> 00:10:59,980
代表說這個client目前想要把這個所謂的連線把它結束掉

130
00:10:59,980 --> 00:11:08,809
好那server收到之後呢它就回應一個ＡＣＫ代表說我收到說你要把connection結束掉

131
00:11:08,809 --> 00:11:12,710
所以這個ＦＩＮ跟ＡＣＫ只是一個確認這件事情

132
00:11:12,710 --> 00:11:17,649
那接下來就要開始進行connection結束的動作

133
00:11:17,649 --> 00:11:24,649
他的過程就是server本身等一下就會送一個FIN 代表說ok我現在要結束

134
00:11:24,649 --> 00:11:32,549
然後再等到client收到之後他就回一個ＡＣＫ 代表說好確認雙方在確認

135
00:11:32,549 --> 00:11:39,880
這個時候我們說server就會進入叫做closed 代表說他已經把它結束掉了

136
00:11:39,880 --> 00:11:42,309
可是我們client這邊

137
00:11:42,309 --> 00:11:49,309
收到這個FIN之後我們說他進入所謂的closing代表正式要把這個connection結束掉

138
00:11:49,309 --> 00:11:54,710
可是他還是會等一段時間 我們說會等一段時間 這段時間通常是30秒

139
00:11:54,710 --> 00:12:01,710
等30秒之後才正式把這個所謂的連線把它結束掉

140
00:12:01,710 --> 00:12:07,950
我們說雙方都要結束了為什麼還要等30秒最後才把這個連線結束掉

141
00:12:07,950 --> 00:12:13,179
這是因為我們知道說我們的封包丟到internet裡面去 他有可能會delay

142
00:12:13,179 --> 00:12:21,250
所以我們在這個連線正式把它關閉之前 可能會有一些封包還在外面

143
00:12:21,250 --> 00:12:25,950
我們講還在遊蕩 因為被繞比較遠的路 等一下可能會進來

144
00:12:25,950 --> 00:12:32,779
我們等於說在連線正式把它關閉之前 我們在保留一段時間

145
00:12:32,779 --> 00:12:37,980
我們說大概就是30秒 讓還在internet上面屬於這個connection

146
00:12:37,980 --> 00:12:44,610
但是還在外面送的這個封包 在正式關閉之前能夠收到能夠進來

147
00:12:44,610 --> 00:12:47,580
因為一旦關閉之後這個connection就不見了

148
00:12:47,580 --> 00:12:52,880
以後屬於這個connection的封包即使在跑進來 也通通沒有用了

149
00:12:52,880 --> 00:12:57,009
因為通通connection已經結束掉了 所以這個地方會有這樣的設計啦

150
00:12:57,009 --> 00:13:02,909
那我們簡單看一下他的整個流程 就是說我們先送一個ＦＩＮ

151
00:13:02,909 --> 00:13:08,110
然後送一個ＡＣＫ 然後回一個FIN 最後在回一個這個ＡＣＫ

152
00:13:08,110 --> 00:13:15,909
這樣就可以把整個connection把它結束掉。那我們剛剛提到第一步是由client發起的

153
00:13:15,909 --> 00:13:30,710
那server就回應一個ＡＣＫ那我們說第三步第四步就是進到說這個server本身先回一個ＦＩＮ

154
00:13:30,710 --> 00:13:38,409
然後client本身在回一個ACK這樣的話等於說就把整個connection就可以把它結束掉

155
00:13:38,409 --> 00:13:41,750
好那我們簡單來看一下這個動畫

156
00:13:41,750 --> 00:13:46,049
就相當於ＦＩＮ/ＡＣＫ然後ＦＩＮ/ＡＣＫ 就兩邊

157
00:13:46,049 --> 00:13:53,350
一邊送ＦＩＮ一邊送ＡＣＫ另外一邊再送一邊在送ＡＣＫ 這樣就可以把這個連線把它結束掉

158
00:13:53,350 --> 00:13:57,980
我們用一個 一般我們會用一個叫做state diagram

159
00:13:57,980 --> 00:14:06,049
狀態圖來描述說這個connection的建立的過程或者connection結束的過程

160
00:14:06,049 --> 00:14:10,980
我們這個狀態圖是所謂的client這邊

161
00:14:10,980 --> 00:14:14,909
另外一個狀態圖我們看下一張這是所謂的server

162
00:14:14,909 --> 00:14:19,480
就是一個是client一個是server 那client跟server的狀態不一樣

163
00:14:19,480 --> 00:14:28,980
因為他們的發起的程序或者送什麼這樣的封包收什麼樣的封包那個程序稍微不一樣

164
00:14:28,980 --> 00:14:33,880
我們很快的先把client的這個state先跟各位介紹一下

165
00:14:33,880 --> 00:14:41,250
我們說一開始一個連線我們說在close state 因為一開始什麼都還沒有建

166
00:14:41,250 --> 00:14:47,710
所以這個連線在關閉的狀態。當這個client他想要建一個connection的時候

167
00:14:47,710 --> 00:14:50,950
他會送一個ＳＹＮ 所以他會送一個ＳＹＮ

168
00:14:50,950 --> 00:14:57,409
也就是說當這個client送了這個ＳＹＮ的封包之後 我們說他會進到另外一個state

169
00:14:57,409 --> 00:15:02,309
這個state叫做SYN_SENT 代表說他已經送了這個ＳＹＮ的意思

170
00:15:02,309 --> 00:15:06,480
那送了SYN之後我們剛剛提到因為建連線是Three-way handshakes

171
00:15:06,480 --> 00:15:09,679
所以他送了ＳＹＮ之後 他就要等ＳＹＮ/ＡＣＫ

172
00:15:09,679 --> 00:15:15,409
所以等到他收到這個SYN/ACK的時候 代表他已經連線建起來

173
00:15:15,409 --> 00:15:21,279
就是說送一個SYN收到他ＳＹＮ/ＡＣＫ他就進入這個connection建立了

174
00:15:21,279 --> 00:15:26,110
同時他會回一個ACK的意思。SYN/ACK/ACK 回一個ACK

175
00:15:26,110 --> 00:15:27,850
那他這個連線已經建起來了

176
00:15:27,850 --> 00:15:34,750
那我們就來看那如果是server的話 我們說server本身他一開始也是close的

177
00:15:34,750 --> 00:15:41,779
可是我們說server本身通常比較處於被動 所以他為了要開始讓別人可以建連線

178
00:15:41,779 --> 00:15:49,909
他必須先打開port的意思 讓別人可以進來。那他讓別人可以進來

179
00:15:49,909 --> 00:15:54,409
我們說他會create一個叫做listen socket

180
00:15:54,409 --> 00:16:00,149
代表說這時候他開了一個socket 讓別人可以連進來

181
00:16:00,149 --> 00:16:07,909
所以本身我們講她就會進入這個所謂LISTEN這個地方 進到這個LISTEN

182
00:16:07,909 --> 00:16:17,610
表示在等的意思那如果他收到一個SYN 代表說對方送一個SYN

183
00:16:17,610 --> 00:16:24,309
那他回SYN/ACK這時候他就進到另外一個state叫做SYN_RECVD

184
00:16:24,309 --> 00:16:27,779
代表說他已經收到對方送來的ＳＹＮ的意思

185
00:16:27,779 --> 00:16:34,279
然後我們說他回了一個所謂的SYN/ACK 他還在等對方的ACK

186
00:16:34,279 --> 00:16:37,350
如果他也收到對方的ACK的話

187
00:16:37,350 --> 00:16:41,309
我們說他就進入了所謂的ESTABLISHED

188
00:16:41,309 --> 00:16:43,210
所以我們來看一下就是說

189
00:16:43,210 --> 00:16:49,049
client本身他進入到ESTABLISHED就是連線建立

190
00:16:49,049 --> 00:16:52,250
那個過程比較簡單 因為他只要送一個收一個就可以

191
00:16:52,250 --> 00:16:56,610
那server本身他就必須先把這個socket打開

192
00:16:56,610 --> 00:17:00,179
先把這個port打開的意思 等別人送一個ＳＹＮ

193
00:17:00,179 --> 00:17:04,049
回一個ＳＹＮ/ＡＣＫ 然後等一個ＡＣＫ

194
00:17:04,049 --> 00:17:07,950
那ＡＣＫ如果等到的話 那我們說這個連線就建起來

195
00:17:07,950 --> 00:17:13,609
等於說前半段一個連線從close到ESTABLISHED

196
00:17:13,609 --> 00:17:16,880
那後半段就變成談的是那我們怎麼把它結束掉

197
00:17:16,880 --> 00:17:21,109
那要結束掉的話我們說一樣 如果這個連線要結束的話呢

198
00:17:21,109 --> 00:17:25,380
我們說這個client假設他開始的話

199
00:17:25,380 --> 00:17:29,750
我們講client initial這個close connection的動作

200
00:17:29,750 --> 00:17:35,849
就是由client來發起 他就送一個叫做FIN 送FIN的這個封包

201
00:17:35,849 --> 00:17:42,380
那他就進入叫做FIN_WAIT_1 因為finish這個他有兩個state

202
00:17:42,380 --> 00:17:45,910
一個wait 1一個wait 2 這個是他不同的狀態

203
00:17:45,910 --> 00:17:50,079
那他送了這個ＦＩＮ代表說他要把connection結束

204
00:17:50,079 --> 00:17:56,180
那我們說server本身也是一樣 如果server本身如果他收到一個FIN

205
00:17:56,180 --> 00:18:02,049
代表說對方要把connection結束 所以他就回一個ＡＣＫ

206
00:18:02,049 --> 00:18:09,410
進入到CLOSE_WAIT 代表說他等著要把這個連線結束掉

207
00:18:09,410 --> 00:18:16,680
那我們說等一下呢他就送一個send FIN 就送一個ＦＩＮ回去

208
00:18:16,680 --> 00:18:22,380
他就等最後一個last ACK 等最後一個ＡＣＫ

209
00:18:22,380 --> 00:18:28,180
那我們說client本身剛剛提到 他送了一個finish

210
00:18:28,180 --> 00:18:32,549
然後接下來他會收到一個所謂的acknowledgement

211
00:18:32,549 --> 00:18:38,950
這個從server來的 他就進入到所謂的FIN_WAIT_2

212
00:18:38,950 --> 00:18:44,609
如果他又收到一個所謂的ＦＩＮ那他回一個ＡＣＫ

213
00:18:44,609 --> 00:18:47,210
同時他進入到這個所謂的TIME_WAIT

214
00:18:47,210 --> 00:18:50,380
那他回了這個ＡＣＫ目的就是要讓

215
00:18:50,380 --> 00:18:59,779
我們講這個server本身他收到最後一個ACK 他會收到 收到ACK

216
00:18:59,779 --> 00:19:02,380
那他就進入回到這個CLOSED

217
00:19:02,380 --> 00:19:08,950
然後我們剛剛還有一個最後面就是說client本身他收到ＡＣＫ之後

218
00:19:08,950 --> 00:19:11,809
代表說連線可以結束

219
00:19:11,809 --> 00:19:16,450
可是因為還有一些connection的封包可能還在網路上面送

220
00:19:16,450 --> 00:19:23,980
所以我們說會讓他等 讓他等30秒再把connection結束掉

221
00:19:23,980 --> 00:19:32,210
所以這個state diagram可以很清楚的告訴我們說我們的連線是怎麼樣可以建立起來

222
00:19:32,210 --> 00:19:35,150
然後怎麼樣可以結束掉

223
00:19:35,150 --> 00:19:40,380
所以這個圖就很清楚告訴我們說一個連線從CLOSED

224
00:19:40,380 --> 00:19:45,680
然後他的過程到所謂的ESTABLISHED 然後再到CLOSED

225
00:19:45,680 --> 00:19:50,079
等於說把這個從CLOSED怎麼到建連線

226
00:19:50,079 --> 00:19:52,980
等於說他怎麼繞過來怎麼繞回去

227
00:19:52,980 --> 00:19:55,180
一個connection就是這樣的一個狀態

228
00:19:55,180 --> 00:20:00,079
我們叫狀態圖那如果說我們把這個狀態圖弄得很清楚的話

229
00:20:00,079 --> 00:20:07,000
我們對這個TCP連線的建立還有連線的結束我們基本上應該都掌握到他的精神了 Subtitles End: mo.dbxdb.com
