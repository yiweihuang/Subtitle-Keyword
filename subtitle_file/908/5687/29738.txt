1
00:00:08,078 --> 00:00:13,025
好 那接下來我們來看一下那個bridge網路裡面

2
00:00:13,025 --> 00:00:16,028
如果形成loop的話她有什麼樣的問題

3
00:00:16,028 --> 00:00:19,088
我們說bridge網路裡面呢

4
00:00:19,088 --> 00:00:22,005
為了增加這個網路的可靠度

5
00:00:22,005 --> 00:00:25,021
我們會把那個網路接成有所謂的迴路

6
00:00:25,021 --> 00:00:27,065
有loop 有loop的目的就是希望說

7
00:00:27,065 --> 00:00:30,095
萬一有bridge壞掉啦 或者link有斷掉的話

8
00:00:30,095 --> 00:00:33,035
這個網路還是可以連結起來

9
00:00:33,035 --> 00:00:36,028
但是呢 loop也會造成兩個比較大的問題

10
00:00:36,028 --> 00:00:39,081
我們來看一下 第一個是loop會造成所謂的

11
00:00:39,081 --> 00:00:43,071
封包會重複接收 因為有迴路嘛

12
00:00:43,071 --> 00:00:46,095
所以我們封包在送的時候可能會經過兩條路

13
00:00:46,095 --> 00:00:49,081
或者三條路呢 會同時收到

14
00:00:49,081 --> 00:00:52,071
變成說一個封包會被收到好幾次

15
00:00:52,071 --> 00:00:54,041
就所謂的frame duplication

16
00:00:54,041 --> 00:00:56,058
這是一個滿嚴重的問題

17
00:00:56,058 --> 00:00:58,005
那另外一個問題就是說

18
00:00:58,005 --> 00:01:01,041
這個loop本身會造成所謂的wrong address learning

19
00:01:01,041 --> 00:01:03,055
就是說因為我們bridge本身

20
00:01:03,055 --> 00:01:07,051
他要學習每一個工作站到底在什麼地方

21
00:01:07,051 --> 00:01:09,028
他會做address learning

22
00:01:09,028 --> 00:01:10,065
但是如果有迴路的話

23
00:01:10,065 --> 00:01:14,038
因為封包一下子從這個port進來 一下從另外一個port進來

24
00:01:14,038 --> 00:01:16,028
那他在做access learning的時候

25
00:01:16,028 --> 00:01:18,095
他就會搞混了 到底是封包應該

26
00:01:18,095 --> 00:01:22,001
到底station應該是在左邊還是在右邊

27
00:01:22,001 --> 00:01:24,028
他會變成 會造成混淆

28
00:01:24,028 --> 00:01:26,028
那這個會造成address learning的錯誤

29
00:01:26,028 --> 00:01:27,045
我們來看一下

30
00:01:27,045 --> 00:01:30,058
那我們假設呢 像下面這個圖

31
00:01:30,058 --> 00:01:34,058
我們說 有兩個工作站 A跟B

32
00:01:34,058 --> 00:01:36,005
然後呢我們有兩個LAN

33
00:01:36,005 --> 00:01:39,028
LAN1跟LAN2 同時有兩個bridge XY

34
00:01:39,028 --> 00:01:42,015
那你注意到 這個網路的結構裡面呢

35
00:01:42,015 --> 00:01:43,048
我們剛好有一個迴路

36
00:01:43,048 --> 00:01:45,048
在中間這個地方形成一個迴路

37
00:01:45,048 --> 00:01:49,091
那我們假設呢 現在A要把一個封包送給B

38
00:01:49,091 --> 00:01:53,011
所以我們就會形成一個這樣的一個封包

39
00:01:53,011 --> 00:01:57,028
就是A要送給B 這個A給B的封包

40
00:01:57,028 --> 00:02:00,078
然後我們看一下 當A把這個封包丟出去的時候呢

41
00:02:00,078 --> 00:02:04,001
他會在網路上面形成廣播

42
00:02:04,001 --> 00:02:06,091
因為我們一般的LAN是一個broadcast LAN

43
00:02:06,091 --> 00:02:08,068
所以這個封包一丟出去的時候呢

44
00:02:08,068 --> 00:02:12,055
他就會造成所謂的X跟Y

45
00:02:12,055 --> 00:02:14,078
這兩個bridge呢會同時收到

46
00:02:14,078 --> 00:02:18,081
那這兩個bridge收到這個封包的時候呢

47
00:02:18,081 --> 00:02:20,035
都會做同樣的事情

48
00:02:20,035 --> 00:02:23,051
第一個就是說 他試著去做轉播嘛

49
00:02:23,051 --> 00:02:26,005
就是forwarding 那我們假設這個時候

50
00:02:26,005 --> 00:02:30,008
那個database裡面呢都不知道所謂B在什麼地方

51
00:02:30,008 --> 00:02:34,048
所以這兩個bridge呢 都會把這個封包做一個轉送

52
00:02:34,048 --> 00:02:38,045
所以等下我們會看 這兩個封包都會被送到網路的另外一端

53
00:02:38,045 --> 00:02:41,051
那同時當然開始會做address learning

54
00:02:41,051 --> 00:02:45,028
所以我們來看一下 不管這個bridge X呢

55
00:02:45,028 --> 00:02:47,018
他在learn的時候他會發現說

56
00:02:47,018 --> 00:02:50,015
這個A 是從port1進來

57
00:02:50,015 --> 00:02:52,001
所以bridgeX呢會認為

58
00:02:52,001 --> 00:02:55,021
這個station A呢他是在屬於port1

59
00:02:55,021 --> 00:02:58,045
那我們看右邊這邊 那右邊這邊的話變成說

60
00:02:58,045 --> 00:03:01,015
bridge Y呢他也會認為說

61
00:03:01,015 --> 00:03:06,081
這個A的封包是從port2進來 所以對bridge Y來講的話

62
00:03:06,081 --> 00:03:09,028
他會認為station呢 是在port2

63
00:03:09,028 --> 00:03:12,065
這是目前 各收到這個封包的時候呢

64
00:03:12,065 --> 00:03:16,021
他們所做的這個learning的結果 那接下來我們再來看

65
00:03:16,021 --> 00:03:20,045
當不管是X或Y 收到這個封包之後呢

66
00:03:20,045 --> 00:03:22,078
因為他查不到B在什麼地方

67
00:03:22,078 --> 00:03:24,078
所以他會開始做轉送

68
00:03:24,078 --> 00:03:26,098
那我們看一下 轉送的時候呢

69
00:03:26,098 --> 00:03:33,005
當bridge X跟Y 他要把封包送到這個LAN1的時候

70
00:03:33,005 --> 00:03:35,041
那哪一個會先送呢 就不一定

71
00:03:35,041 --> 00:03:37,065
這個要看他在這個LAN1的protocol

72
00:03:37,065 --> 00:03:40,025
那如果他是像我們ethernet來講的話

73
00:03:40,025 --> 00:03:44,001
他們就按照ethernet的CSMA/CD的protocol去送

74
00:03:44,001 --> 00:03:46,008
那誰先誰後不一定

75
00:03:46,008 --> 00:03:50,088
我們假設是左邊的X bridgeX先送的話

76
00:03:50,088 --> 00:03:53,088
你看他就要把這個封包呢丟到網路上面去

77
00:03:53,088 --> 00:03:58,031
同時呢讓Y收到 所以這個時候就發生第一個問題了

78
00:03:58,031 --> 00:04:03,065
同樣這個封包 剛剛bridgeY已經從LAN2收到一次

79
00:04:03,065 --> 00:04:08,048
那接下來這次呢 bridgeX因為他轉送呢

80
00:04:08,048 --> 00:04:12,018
這個封包呢 又讓bridgeY收到第二次

81
00:04:12,018 --> 00:04:15,041
所以變成說 這個會收到兩次的問題

82
00:04:15,041 --> 00:04:17,008
然後最重要的是說

83
00:04:17,008 --> 00:04:20,008
這個bridgeY呢又會做一次address learning

84
00:04:20,008 --> 00:04:25,001
那這個learning呢發現說 這個封包是從port1進來的

85
00:04:25,001 --> 00:04:30,008
所以他會認為說這個station呢 現在已經在所謂的port1了

86
00:04:30,008 --> 00:04:33,088
我們記得 剛剛bridge Y收到這個封包的時候

87
00:04:33,088 --> 00:04:38,005
是從port2進來 所以他認為A應該是在port2

88
00:04:38,005 --> 00:04:40,098
那現在這個封包是從port1進來

89
00:04:40,098 --> 00:04:44,015
他又認為這個station A呢應該在port1

90
00:04:44,015 --> 00:04:47,008
所以他在學習上面呢 這個時候他已經搞混了

91
00:04:47,008 --> 00:04:50,061
到底是2還是1 當然他會以最近收到的為準

92
00:04:50,061 --> 00:04:54,061
所以他會認為說這個A呢是在port1

93
00:04:54,061 --> 00:04:56,061
事實上不對 我們看一下

94
00:04:56,061 --> 00:04:58,098
事實上A是在port2喔

95
00:04:58,098 --> 00:05:01,005
沒關係 那接下來Y呢

96
00:05:01,005 --> 00:05:03,038
他可能又會把這個封包丟出去

97
00:05:03,038 --> 00:05:06,098
我們剛提到 X跟Y 他們都會想把封包轉送嘛

98
00:05:06,098 --> 00:05:08,005
好 一樣的

99
00:05:08,005 --> 00:05:10,058
當Y把這個封包轉送出去的時候呢

100
00:05:10,058 --> 00:05:13,018
這個封包有沒有到達bridge X

101
00:05:13,018 --> 00:05:16,068
當然其實這個B 又收到第二份了

102
00:05:16,068 --> 00:05:19,041
剛剛第一份的時候呢 B已經收到一次了

103
00:05:19,041 --> 00:05:22,071
所以我們來看一下 剛才這個

104
00:05:23,068 --> 00:05:25,088
這個封包呢 現在等於是說

105
00:05:25,088 --> 00:05:29,051
這次送的是這樣子 B其實等於說

106
00:05:29,051 --> 00:05:32,058
bridge Y在送的時候呢 B會收到一次

107
00:05:32,058 --> 00:05:34,091
剛剛這個bridge X送的時候呢

108
00:05:34,091 --> 00:05:36,071
B也收到一次啦

109
00:05:36,071 --> 00:05:39,081
也就是說事實上這個B呢他收到兩次

110
00:05:39,081 --> 00:05:41,031
這也是我們剛剛講的

111
00:05:41,031 --> 00:05:44,058
他會有這個所謂的frame duplication的問題

112
00:05:44,058 --> 00:05:50,045
就在一般的網路上面 一個station不應該收到兩次

113
00:05:50,045 --> 00:05:52,055
或兩次以上的同樣的封包

114
00:05:52,055 --> 00:05:55,035
就是一個封包不應該讓一個station呢收到兩次以上

115
00:05:55,035 --> 00:05:57,015
所以這本身就是一個問題

116
00:05:57,015 --> 00:05:58,021
那還有剛剛提到的

117
00:05:58,021 --> 00:06:01,035
這個address learning呢他會造成學習錯誤就是說

118
00:06:01,035 --> 00:06:05,025
剛剛有提到說 這個bridge Y呢

119
00:06:05,025 --> 00:06:10,081
他因為封包呢從這個port 1進來已經讓他學習錯誤了

120
00:06:10,081 --> 00:06:12,085
因為他認為A在port 1

121
00:06:12,085 --> 00:06:15,031
那現在這個封包呢送進來的時候

122
00:06:15,031 --> 00:06:20,001
會讓這個bridge X呢 他認為說A在port2

123
00:06:20,001 --> 00:06:23,095
因為這個封包是從這個port2進來嘛

124
00:06:23,095 --> 00:06:26,018
那這樣就造成一個問題就是說

125
00:06:26,018 --> 00:06:29,055
X跟Y 他們都認為說

126
00:06:29,055 --> 00:06:33,005
這個station A分別在他們的上半部啦

127
00:06:33,005 --> 00:06:35,028
因為一個在port1一個在port2嘛

128
00:06:35,028 --> 00:06:38,025
那這個時候就碰到一個問題 就是我們看一下

129
00:06:38,025 --> 00:06:41,095
如果這個時候B他要回送一個封包給A的時候呢

130
00:06:41,095 --> 00:06:44,015
這個封包會送到這裡來

131
00:06:44,015 --> 00:06:49,028
假設B有回送嘛 那回送到這個bridge的時候就出現一個問題

132
00:06:49,028 --> 00:06:53,081
因為bridgeX認為說 A呢是在port2

133
00:06:53,081 --> 00:06:58,088
所以這個封包呢會被bridgeX呢 把它filter掉 會過濾

134
00:06:58,088 --> 00:07:00,078
那同時bridge Y呢

135
00:07:00,078 --> 00:07:03,075
他也認為說 這個A應該在port1啊

136
00:07:03,075 --> 00:07:06,065
所以這個封包 B送給A的封包呢

137
00:07:06,065 --> 00:07:10,071
他一樣會在這個bridge X的地方會被filter掉

138
00:07:10,071 --> 00:07:12,061
等於說 這兩個封包呢

139
00:07:12,061 --> 00:07:16,061
這個封包在這兩個bridge呢都會被過濾掉

140
00:07:16,061 --> 00:07:19,008
也就是說A跟B就沒有辦法溝通

141
00:07:19,008 --> 00:07:24,011
A可以送給B 但B收到兩份

142
00:07:24,011 --> 00:07:27,041
但是B送給A的時候呢 A一份都收不到

143
00:07:27,041 --> 00:07:28,075
因為都會被濾掉了

144
00:07:28,075 --> 00:07:31,068
也就是說loop本身就會有這樣的問題

145
00:07:31,068 --> 00:07:33,058
也就是說 第一個

146
00:07:33,058 --> 00:07:37,048
他會造成某些station呢 封包會重複接收

147
00:07:37,048 --> 00:07:39,095
這是第一個問題 這本來就不應該

148
00:07:39,095 --> 00:07:41,091
那第二個問題更嚴重了就是說

149
00:07:41,091 --> 00:07:44,015
他會造成這個address learning錯誤

150
00:07:44,015 --> 00:07:47,065
那address learning錯誤呢 造成的結果就是說

151
00:07:47,065 --> 00:07:50,031
可能有些封包呢不應該被過濾的

152
00:07:50,031 --> 00:07:53,085
反而被過濾掉 不應該轉送的反而被轉送

153
00:07:53,085 --> 00:07:55,088
變成天下大亂了

154
00:07:55,088 --> 00:08:00,038
那可是我們為什麼又要把他接成有所謂的loop呢

155
00:08:00,038 --> 00:08:03,055
剛剛有提到 因為loop本身有一個最大的好處

156
00:08:03,055 --> 00:08:06,058
他至少提高這個網路的可靠度

157
00:08:06,058 --> 00:08:08,051
譬如說 假設萬一

158
00:08:08,051 --> 00:08:11,028
我們講停電啦 或者說這個當機

159
00:08:11,028 --> 00:08:13,028
我們讓這個bridge呢壞掉

160
00:08:13,028 --> 00:08:15,005
萬一這個bridge壞掉的時候呢

161
00:08:15,005 --> 00:08:16,081
那我至少網路還是可以連起來啦

162
00:08:16,081 --> 00:08:19,091
譬如說我跟A跟B之間 我還有這條路可以通啊

163
00:08:19,091 --> 00:08:23,035
所以把網路接成有迴路呢

164
00:08:23,035 --> 00:08:26,055
最大的目的就是希望提高網路的可靠度

165
00:08:26,055 --> 00:08:29,011
就是萬一不管是 bridge壞掉啦

166
00:08:29,011 --> 00:08:33,068
或者所謂的連線斷掉啦 我網路呢還可以接起來

167
00:08:33,068 --> 00:08:37,045
可是我又希望在運作的時候呢不要有迴路

168
00:08:37,045 --> 00:08:39,098
我們剛剛提到 迴路會造成兩個問題

169
00:08:39,098 --> 00:08:42,045
第一個封包會重複接收

170
00:08:42,045 --> 00:08:44,078
第二個呢我address learning會錯誤

171
00:08:44,078 --> 00:08:48,008
所以這個很矛盾啊 我為了提高網路的可靠度

172
00:08:48,008 --> 00:08:49,098
我會把網路接成有迴路

173
00:08:49,098 --> 00:08:54,071
可是有迴路呢又會造成這個網路address learning錯誤

174
00:08:54,071 --> 00:08:57,008
跟所謂的封包的重複接收

175
00:08:57,008 --> 00:08:59,085
好 那這問題就是要怎麼解決呢

176
00:08:59,085 --> 00:09:02,021
就是我們底下要跟各位介紹的

177
00:09:02,021 --> 00:09:04,051
所謂的spanning tree

178
00:09:04,051 --> 00:09:06,028
spanning tree的意思就是說

179
00:09:06,028 --> 00:09:08,055
我們讓這個bridge X跟Y

180
00:09:08,055 --> 00:09:11,041
事實上是每一個bridge呢上面會run一個演算法

181
00:09:11,041 --> 00:09:14,015
這個演算法就叫做spanning tree algorithm

182
00:09:14,015 --> 00:09:16,005
這個演算法會做什麼事呢

183
00:09:16,005 --> 00:09:18,005
就是說他們會互相的 譬如說

184
00:09:18,005 --> 00:09:22,015
待會會介紹 他們會互相的溝通

185
00:09:22,015 --> 00:09:25,031
然後最後呢 就會找到一個方法就是說

186
00:09:25,031 --> 00:09:29,091
讓有迴路的網路呢 某些link

187
00:09:29,091 --> 00:09:33,031
就是某些連線 暫時不工作

188
00:09:33,031 --> 00:09:35,078
相當於暫時把它block住

189
00:09:35,078 --> 00:09:39,031
等於說暫時讓他中斷 等於說任何一個迴路

190
00:09:39,031 --> 00:09:42,055
我們只要把任何一個link呢把它切掉

191
00:09:42,055 --> 00:09:44,015
他就沒有迴路了嘛

192
00:09:44,015 --> 00:09:46,035
所以我們這個spanning tree的目的

193
00:09:46,035 --> 00:09:50,055
就是讓這個整個網路呢 某一些有loop的link

194
00:09:50,055 --> 00:09:52,075
讓他暫時block

195
00:09:52,075 --> 00:09:57,008
這樣我們 把每一個loop都把他暫時變成沒有loop

196
00:09:57,008 --> 00:09:58,098
那他就變成一個tree

197
00:09:58,098 --> 00:10:01,015
那一個tree的特色就是說

198
00:10:01,015 --> 00:10:04,028
任何兩點之間只有唯一的路徑

199
00:10:04,028 --> 00:10:06,041
就是沒有迴圈 只有一個路徑

200
00:10:06,041 --> 00:10:09,048
那這個路徑剛好就是我們最重要的routing

201
00:10:09,048 --> 00:10:13,051
就是說我們會在這個tree上面呢做封包的轉送

202
00:10:13,051 --> 00:10:18,005
那因為 網路呢 我們讓他在運作的時候沒有迴路

203
00:10:18,005 --> 00:10:22,035
那萬一如果有bridge壞掉 或者有link斷掉

204
00:10:22,035 --> 00:10:26,095
我們就把剛剛 暫時把它停止工作的link呢

205
00:10:26,095 --> 00:10:32,058
再把它恢復 那這樣的話他就可以達成我們的目的就是說

206
00:10:32,058 --> 00:10:36,055
我們利用迴路呢來增加網路的可靠性

207
00:10:36,055 --> 00:10:39,085
可是在運作的時候呢 讓他沒有迴路

208
00:10:39,085 --> 00:10:44,008
那萬一網路有壞掉 譬如說link斷掉啦 bridge壞掉

209
00:10:44,008 --> 00:10:47,011
我們就讓某一些link呢 再恢復起來

210
00:10:47,011 --> 00:10:49,081
讓他還是維持一個tree的狀態

211
00:10:49,081 --> 00:10:52,075
所以這就是最重要的 所謂的spanning tree的目的

212
00:10:52,075 --> 00:10:55,098
就是說在有迴路的網路上面

213
00:10:55,098 --> 00:11:00,021
讓他暫時沒有迴路的這樣的運作的方式

214
00:11:00,021 --> 00:11:01,085
底下我們就來看一下

215
00:11:01,085 --> 00:11:04,061
這個所謂的spanning tree的algorithm

216
00:11:04,061 --> 00:11:06,028
然後我們首先看一下說

217
00:11:06,028 --> 00:11:09,098
一般我們在一個B LAN呢

218
00:11:09,098 --> 00:11:14,035
的表達方式可以用一個比較簡單的 所謂的graph的方式

219
00:11:14,035 --> 00:11:17,038
就是圖形的方式來代表一個所謂的網路

220
00:11:17,038 --> 00:11:19,008
我們看 左邊這個圖

221
00:11:19,008 --> 00:11:22,095
左邊這個圖我們假設說 每一個圈圈

222
00:11:22,095 --> 00:11:25,065
我們叫做vertex 他代表一個LAN

223
00:11:25,065 --> 00:11:30,028
那這裡我們有5個LAN 就是這個紫色的圈圈

224
00:11:30,028 --> 00:11:33,081
然後我們假設呢每一個這個

225
00:11:33,081 --> 00:11:36,011
藍色的這個長方形呢是一個bridge

226
00:11:36,011 --> 00:11:39,068
所以在這個圖上面呢也是有5個bridge有5個LAN

227
00:11:39,068 --> 00:11:42,068
然後大概接成像左邊這個圖

228
00:11:42,068 --> 00:11:45,058
左邊這個圖呢 我們一看就知道說

229
00:11:45,058 --> 00:11:48,071
這裡面是有迴路的 譬如說

230
00:11:48,071 --> 00:11:50,068
這個地方就是一個迴路

231
00:11:50,068 --> 00:11:52,071
這個地方是一個迴路

232
00:11:52,071 --> 00:11:55,088
外面這個地方 這個事實上也是一個迴路

233
00:11:55,088 --> 00:11:57,075
所以事實上他是有迴路在的

234
00:11:57,075 --> 00:12:01,001
那這個迴路本身 就會形成我們剛剛提到的

235
00:12:01,001 --> 00:12:03,021
我封包可能會重複接收啊

236
00:12:03,021 --> 00:12:06,008
然後我在address learning的時候可能會發生錯誤

237
00:12:06,008 --> 00:12:10,081
那接下來我們就來看說 我們怎麼讓這個所謂的迴路呢

238
00:12:10,081 --> 00:12:14,048
暫時取消迴路 我們就是要把某一些link呢

239
00:12:14,048 --> 00:12:17,048
暫時把它變成 我們叫做block

240
00:12:17,048 --> 00:12:20,071
讓他不工作 怎麼做呢我們看一下

241
00:12:20,071 --> 00:12:24,041
首先也許會把這個link 這兩個link把它拿掉

242
00:12:24,041 --> 00:12:27,048
這兩個link拿掉之後 再拿掉一個link

243
00:12:27,048 --> 00:12:29,098
你就會發現 這個時候就沒有迴路了

244
00:12:29,098 --> 00:12:33,001
剛剛我們有很多迴路嘛

245
00:12:33,001 --> 00:12:36,005
現在我們把三個link拿掉之後就沒有迴路

246
00:12:36,005 --> 00:12:39,095
我們看結果就是像右邊這個圖

247
00:12:39,095 --> 00:12:44,005
那這個圖我們注意一下 我們現在把所有的link

248
00:12:44,005 --> 00:12:46,028
對不起 所有的這個LAN

249
00:12:46,028 --> 00:12:48,045
還有所有的bridge呢都連接起來

250
00:12:48,045 --> 00:12:50,058
就像紅色的這條線

251
00:12:50,058 --> 00:12:53,015
那把這些都連接起來之後呢

252
00:12:53,015 --> 00:12:55,041
他就是一個所謂的spanning tree

253
00:12:55,041 --> 00:12:58,051
這裏的所謂的spanning 談的就是說

254
00:12:58,051 --> 00:13:01,041
我們一般叫做所謂的擴張樹啦

255
00:13:01,041 --> 00:13:07,031
spanning的意思就是說 他要把所有的node

256
00:13:07,031 --> 00:13:09,065
通通要連起來 叫做spanning

257
00:13:09,065 --> 00:13:13,098
那tree呢代表說 他是用樹狀的結構把大家連起來

258
00:13:13,098 --> 00:13:16,028
也就是說 所謂的樹狀就是

259
00:13:16,028 --> 00:13:19,091
任何兩點之間 只有唯一的路徑

260
00:13:19,091 --> 00:13:26,011
我們看在這個樹狀裡面 譬如說假設我們是要這樣5到3的話

261
00:13:26,011 --> 00:13:29,001
這樣 這是唯一的路徑 任何兩點之間

262
00:13:29,001 --> 00:13:30,071
都只有唯一的路徑

263
00:13:30,071 --> 00:13:32,071
這是所謂的tree的特色

264
00:13:32,071 --> 00:13:36,045
那spanning tree 就是把所有的這個bridge呢

265
00:13:36,045 --> 00:13:39,008
所有的網路呢 都連起來

266
00:13:39,008 --> 00:13:42,075
而且任何兩個之間 只有唯一的路徑

267
00:13:42,075 --> 00:13:46,051
那這個路徑呢 就是我們在轉送封包的時候的路徑

268
00:13:46,051 --> 00:13:51,031
那因為是唯一的路經 所以就沒有剛剛提到的

269
00:13:51,031 --> 00:13:54,021
封包會重複接收的問題

270
00:13:54,021 --> 00:13:59,008
因為是唯一路徑 所以封包絕對不可能收到兩次

271
00:13:59,008 --> 00:14:02,038
或兩次以上 因為是唯一路徑

272
00:14:02,038 --> 00:14:04,065
所以他在做address learning的時候呢

273
00:14:04,065 --> 00:14:07,005
不會一下從左邊來一下從右邊來

274
00:14:07,005 --> 00:14:10,051
所以也不會有所謂的address learning錯誤的問題

275
00:14:10,051 --> 00:14:14,011
也就是說 如果我們把spanning tree把它找出來呢

276
00:14:14,011 --> 00:14:17,025
我一切後面的運作呢 就可以非常正常

277
00:14:17,025 --> 00:14:19,078
就是我也不會封包重複接收

278
00:14:19,078 --> 00:14:21,075
我address learning呢也不會錯誤

279
00:14:21,075 --> 00:14:24,065
所以這個是 spanning tree呢是一個很重要的關鍵

280
00:14:24,065 --> 00:14:26,071
我們再來看另外一個例子

281
00:14:26,071 --> 00:14:29,085
好 在這個例子裡面呢 我們一樣

282
00:14:29,085 --> 00:14:34,001
這個藍色的這個方塊呢就所謂的bridge

283
00:14:34,001 --> 00:14:36,098
我們這裡有5個bridge 我們也有5個LAN

284
00:14:36,098 --> 00:14:40,035
那接成這樣子的結構呢 事實上他還是一樣

285
00:14:40,035 --> 00:14:42,065
這裡面還是有所謂的loop

286
00:14:42,065 --> 00:14:47,001
像這個地方就是一個loop 這個地方也有一個loop

287
00:14:47,001 --> 00:14:50,045
那如果仔細看的話 外面這一圈

288
00:14:50,045 --> 00:14:52,098
這好像也是一個loop

289
00:14:52,098 --> 00:14:54,071
也就是在這個例子裡面呢

290
00:14:54,071 --> 00:14:57,078
我們又發現了 總共有三個loop

291
00:14:57,078 --> 00:15:01,005
那這三個loop呢 我們怎麼來把他

292
00:15:01,005 --> 00:15:04,071
把他所謂的loop暫時把它清除掉呢

293
00:15:04,071 --> 00:15:07,055
把loop暫時清除掉就是我們剛剛提到

294
00:15:07,055 --> 00:15:11,071
我們讓某些link 讓他變成說暫時斷線

295
00:15:11,071 --> 00:15:13,031
在這個例子我們注意到

296
00:15:13,031 --> 00:15:16,008
你看一下 我們如果讓這兩個link

297
00:15:16,008 --> 00:15:18,021
讓他斷線 ok

298
00:15:18,021 --> 00:15:20,085
就是說 讓這兩個link讓他斷線之後呢

299
00:15:20,085 --> 00:15:24,041
相當於是說 我們把這兩個link呢

300
00:15:24,041 --> 00:15:28,091
等於說先把它拿掉  這兩個 先把它拿掉

301
00:15:28,091 --> 00:15:32,071
好 那你就注意到 這個時候就沒有迴路了喔

302
00:15:32,071 --> 00:15:35,051
也就是我們剛剛提到說

303
00:15:35,051 --> 00:15:41,008
bridge本身 他會run一個所謂的spanning tree的algorithm

304
00:15:41,008 --> 00:15:43,035
一個演算法 這個演算法呢

305
00:15:43,035 --> 00:15:48,071
他們可能之間會互相的交換情報 互相的溝通

306
00:15:48,071 --> 00:15:52,068
反正就是分散式的嘛 大家互相溝通溝通溝通

307
00:15:52,068 --> 00:15:54,091
最後呢 可能就是把這兩條線

308
00:15:54,091 --> 00:15:57,005
剛提到 這兩個link呢先把它中斷

309
00:15:57,005 --> 00:15:58,095
他就變成一個spanning tree了

310
00:15:58,095 --> 00:16:02,081
那至於說 我要挑兩個link 也很多種挑法啊

311
00:16:02,081 --> 00:16:05,081
為什麼剛好挑到這兩個 為什麼不是另外兩個link

312
00:16:05,081 --> 00:16:09,015
這個我們後面會來解釋 到底是怎麼做的

313
00:16:09,015 --> 00:16:14,071
所以如果把剛剛這個 這兩個link把他所謂的

314
00:16:14,071 --> 00:16:16,065
把它中斷掉的時候呢

315
00:16:16,065 --> 00:16:18,081
這個spanning tree會變成什麼樣子呢

316
00:16:18,081 --> 00:16:21,011
我們說 一般這個spanning tree呢

317
00:16:21,011 --> 00:16:23,021
因為既然是一個樹嘛

318
00:16:23,021 --> 00:16:25,091
我們通常說數會有一個樹根嘛

319
00:16:25,091 --> 00:16:27,091
一般我們叫做所謂的root

320
00:16:27,091 --> 00:16:30,018
那一樣 這個spanning tree呢

321
00:16:30,018 --> 00:16:35,055
我們在這裡面呢會挑一個bridge 當成所謂的root

322
00:16:35,055 --> 00:16:37,065
那因為他有他的責任在身上

323
00:16:37,065 --> 00:16:40,088
譬如說他要負責 這個spanning tree的維護

324
00:16:40,088 --> 00:16:43,095
所以我們怎麼挑這個 所謂的root bridge呢

325
00:16:43,095 --> 00:16:47,008
就是挑那個id最小的bridge

326
00:16:47,008 --> 00:16:49,018
因為每一個bridge都有一個id

327
00:16:49,018 --> 00:16:53,035
那id最小的那個bridge呢 就會被挑成所謂的root

328
00:16:53,035 --> 00:16:56,078
依這個例子來看 我們知道這個bridge有12345嘛

329
00:16:56,078 --> 00:17:00,055
我們假設啦 就是1呢 假設他是最小的

330
00:17:00,055 --> 00:17:03,095
那如果這個bridge1呢 是最小的話

331
00:17:03,095 --> 00:17:06,038
就他是最小的 那就當root

332
00:17:06,038 --> 00:17:08,028
所以我們如果把剛剛提到

333
00:17:08,028 --> 00:17:12,001
這個link 把它拿掉 然後把這個root

334
00:17:12,001 --> 00:17:16,021
既然是當根嘛 我們把它往上提上來

335
00:17:16,021 --> 00:17:18,021
就像一串葡萄一樣

336
00:17:18,021 --> 00:17:21,035
然後把它抖一抖 把它抖一抖之後呢

337
00:17:21,035 --> 00:17:24,071
因為線很多都被剪掉了 這個時候沒有迴路了

338
00:17:24,071 --> 00:17:28,071
他就會形成這樣子 這個就是剛剛那個網路的結構

339
00:17:28,071 --> 00:17:31,061
我們把兩個link呢讓他中斷掉

340
00:17:31,061 --> 00:17:34,008
然後把root呢提到最上面來

341
00:17:34,008 --> 00:17:37,031
那這個root呢 我們就叫做所謂的root bridge

342
00:17:37,031 --> 00:17:42,011
就是這個 root bridge通常都是我們指id最小的

343
00:17:42,011 --> 00:17:43,091
我們假設id是10 他是最小

344
00:17:43,091 --> 00:17:47,078
把它提上來 那結果他就會形成現在這個結構

345
00:17:47,078 --> 00:17:50,001
就是一個tree 而且沒有loop

346
00:17:50,001 --> 00:17:53,021
事實上他當然真正的網路連結 就剛剛

347
00:17:53,021 --> 00:17:56,028
前面那一張所看到的 其實他是有loop啦

348
00:17:56,028 --> 00:17:59,021
可是因為我們run了這個spanning tree的演算法

349
00:17:59,021 --> 00:18:04,088
讓某些link呢暫時失去它的功用

350
00:18:04,088 --> 00:18:07,051
使得說 他在運作的時候呢

351
00:18:07,051 --> 00:18:10,025
是用一個tree的方式來運作

352
00:18:10,025 --> 00:18:12,025


