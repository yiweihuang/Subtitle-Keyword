1
00:00:08,075 --> 00:00:11,048
好 那接下來我們來介紹

2
00:00:11,048 --> 00:00:15,018
剛剛提到說 一個bridge本身收到封包的時候

3
00:00:15,018 --> 00:00:18,078
有兩個很重要的處理 一個是所謂的frame的forwarding

4
00:00:18,078 --> 00:00:21,021
一個是所謂的address learning

5
00:00:21,021 --> 00:00:23,098
那我們這張圖表 這個flow chart呢

6
00:00:23,098 --> 00:00:27,091
就告訴我們說 一個bridge呢 怎麼做forwarding

7
00:00:27,091 --> 00:00:29,035
怎麼做address learning

8
00:00:29,035 --> 00:00:33,045
我們看一下 在上半部這個藍色這個區塊呢

9
00:00:33,045 --> 00:00:37,008
就是談怎麼做所謂的forwarding這個過程

10
00:00:37,008 --> 00:00:41,015
那下半部這個綠色這塊呢 就所謂做address learning

11
00:00:41,015 --> 00:00:43,031
我們先假設 這個封包呢

12
00:00:43,031 --> 00:00:46,055
是從一個bridge的port x

13
00:00:46,055 --> 00:00:49,038
我們假設從port x把這個封包收進來

14
00:00:49,038 --> 00:00:52,028
那收進來之後呢 我們首先就要檢查說

15
00:00:52,028 --> 00:00:57,051
他這個MAC address 是不是在這個database裡面

16
00:00:57,051 --> 00:01:00,075
剛提到 我們會去檢查那個filtering database

17
00:01:00,075 --> 00:01:02,075
一開始的時候database是空的

18
00:01:02,075 --> 00:01:04,045
所以這個檢查就有兩個結果

19
00:01:04,045 --> 00:01:06,021
一個是在裡面 一個不在裡面

20
00:01:06,021 --> 00:01:09,028
我們先看假設不在裡面 所謂這個no

21
00:01:09,028 --> 00:01:14,005
那如果我們檢查發現說 這個封包的destination的MAC

22
00:01:14,005 --> 00:01:16,005
沒有在database裡面 就是代表說

23
00:01:16,005 --> 00:01:19,021
我們不知道這個station到底在什麼地方

24
00:01:19,021 --> 00:01:21,021
所以我們只有一個做法就是把它廣播

25
00:01:21,021 --> 00:01:23,085
所以後面就是說 我們把它forward到所有的port

26
00:01:23,085 --> 00:01:28,001
那除了port x 因為我們不能再送回去了

27
00:01:28,001 --> 00:01:30,091
就是說我們從port x把封包收進來

28
00:01:30,091 --> 00:01:33,088
x進來 就把它散到所有其他的port

29
00:01:33,088 --> 00:01:37,005
這所謂的forwarding 那如果我們找得到

30
00:01:37,005 --> 00:01:40,088
他在這個database裡面找得到 說他在哪一個port

31
00:01:40,088 --> 00:01:44,048
那代表說 我們知道這個destination呢 他在哪一個port

32
00:01:44,048 --> 00:01:46,048
如果知道在哪一個port就是yes

33
00:01:46,048 --> 00:01:50,091
那我們就把他送到那個port裡面去

34
00:01:50,091 --> 00:01:54,001
從那個port丟出去啦  當然有個特別的地方就是說

35
00:01:54,001 --> 00:01:57,088
如果我們從port x收到一個封包

36
00:01:57,088 --> 00:02:02,025
然後他說 他的目的地呢 也在這個port x

37
00:02:02,025 --> 00:02:06,068
這個意思就是說 你從port x收到一個封包

38
00:02:06,068 --> 00:02:10,048
結果說 這個封包的目的地呢 也在port x

39
00:02:10,048 --> 00:02:11,071
就代表說 這個

40
00:02:11,071 --> 00:02:15,065
source跟這個destination他們其實在同一個網路

41
00:02:15,065 --> 00:02:18,051
或在同一邊的意思 那這種封包

42
00:02:18,051 --> 00:02:20,018
我們當然就要把它濾掉啦

43
00:02:20,018 --> 00:02:22,018
因為你送過去也是浪費啦

44
00:02:22,018 --> 00:02:23,075
因為他根本在同一邊嘛

45
00:02:23,075 --> 00:02:25,071
所以這個地方就會走到我們這個右邊來

46
00:02:25,071 --> 00:02:28,038
就把它作為filter 就會把它濾掉

47
00:02:28,038 --> 00:02:30,045
這個濾掉的條件 就是說

48
00:02:30,045 --> 00:02:33,008
如果你從port x收到一個封包

49
00:02:33,008 --> 00:02:37,075
結果發現他的destination也在同樣port x

50
00:02:37,075 --> 00:02:41,011
就是他同一邊 就是送的跟收的都在同一邊

51
00:02:41,011 --> 00:02:42,055
我們就把它濾掉

52
00:02:42,055 --> 00:02:46,058
所以我們這個在這個藍色的這個部分呢

53
00:02:46,058 --> 00:02:48,015
事實上做了兩件事情

54
00:02:48,015 --> 00:02:51,068
第一個 他是不是需要做forwarding

55
00:02:51,068 --> 00:02:54,068
還是需要做filtering 該濾掉就濾掉

56
00:02:54,068 --> 00:02:56,075
那如果要轉送 還有兩個

57
00:02:56,075 --> 00:03:00,008
一個是做廣播 送到所有的port

58
00:03:00,008 --> 00:03:02,068
那一個就是說forward到特定的port

59
00:03:02,068 --> 00:03:05,038
這個是在forwarding的部分

60
00:03:05,038 --> 00:03:08,068
好那我們把一個封包不管是forwarding或者filtering

61
00:03:08,068 --> 00:03:11,081
做完之後呢 就要進到這個下半部

62
00:03:11,081 --> 00:03:14,081
所謂的綠色區塊 那進到綠色的區塊呢

63
00:03:14,081 --> 00:03:17,051
本身就是要 我們要做address learning

64
00:03:17,051 --> 00:03:19,065
就開始要學習啦 那address learning呢

65
00:03:19,065 --> 00:03:21,058
就會用到所謂的 剛提到

66
00:03:21,058 --> 00:03:23,078
所謂的source的MAC address

67
00:03:23,078 --> 00:03:26,081
我們看一下 就是這個source MAC address的部分

68
00:03:26,081 --> 00:03:29,078
就是說 我們看 這個source MAC address呢

69
00:03:29,078 --> 00:03:32,028
在不在我們的filtering database

70
00:03:32,028 --> 00:03:34,065
在不在代表說我們有沒有學過啦

71
00:03:34,065 --> 00:03:37,065
那如果在裡面 代表我們曾經學過

72
00:03:37,065 --> 00:03:41,035
那我們就再檢查說 那我們上次學到的時候呢

73
00:03:41,035 --> 00:03:45,005
是從port x學到的嗎 如果是

74
00:03:45,005 --> 00:03:47,065
代表說他跟上次呢 學到的時候呢

75
00:03:47,065 --> 00:03:50,065
這個port是一樣的 我們就把那個timer

76
00:03:50,065 --> 00:03:52,071
他的時間重新設就好了

77
00:03:52,071 --> 00:03:57,035
那如果說我們上次是從另外一個port收到這個封包

78
00:03:57,035 --> 00:04:00,048
譬如說port y 現在從port x

79
00:04:00,048 --> 00:04:04,075
那代表說 這個source呢 他可能換到不同的地方接進來

80
00:04:04,075 --> 00:04:07,091
那我們當然就要換成說 新的

81
00:04:07,091 --> 00:04:11,081
因為我們現在假設是說 這個封包是從port x收進來嘛

82
00:04:11,081 --> 00:04:13,081
所以我們在做address learning的時候呢

83
00:04:13,081 --> 00:04:16,078
就要把這個source呢 放到database裡面

84
00:04:16,078 --> 00:04:20,061
同時要記錄說 他是從port x進來

85
00:04:20,061 --> 00:04:23,091
然後再給他一個時間 譬如說一個上限

86
00:04:23,091 --> 00:04:26,048
時間的上限 我們一般標準是300秒左右啦

87
00:04:26,048 --> 00:04:30,091
這個是跟實作有關 你可以給他0 慢慢地累加

88
00:04:30,091 --> 00:04:33,028
也可以給他一個上限 慢慢地遞減

89
00:04:33,028 --> 00:04:35,008
這個都可以 這是實作的問題

90
00:04:35,008 --> 00:04:38,051
好 那接下來我們就來看 下一個部分就是講

91
00:04:38,051 --> 00:04:42,095
我們看例子 底下我們用幾個比較簡單的例子

92
00:04:42,095 --> 00:04:45,028
來看看說 我們這個database

93
00:04:45,028 --> 00:04:49,018
到底怎麼樣建構起來 就從0開始

94
00:04:49,018 --> 00:04:52,025
那這個例子裡面我們看一下 我們假設有五個LAN

95
00:04:52,025 --> 00:04:56,031
我們這個裡面有紫色的 有五個LAN 12345

96
00:04:56,031 --> 00:05:00,005
那我們假設有三個bridge 這個藍色的 XYZ

97
00:05:00,005 --> 00:05:03,035
三個bridge 那各有不同的port數

98
00:05:03,035 --> 00:05:05,061
有port1 port2 port3等等

99
00:05:05,061 --> 00:05:07,095
好 然後我們看一下最上面

100
00:05:07,095 --> 00:05:11,058
這個bridge本身 上面都有一個黃色的table

101
00:05:11,058 --> 00:05:13,051
就是filtering database的table

102
00:05:13,051 --> 00:05:17,015
那我們注意到 這個table一開始的時候呢通通都是空白的

103
00:05:17,015 --> 00:05:19,071
這個是正常 一開始通通沒有

104
00:05:19,071 --> 00:05:24,011
那我們這個例子呢 要經過五個封包的傳送

105
00:05:24,011 --> 00:05:27,005
我們來看 這個封包傳送的過程當中

106
00:05:27,005 --> 00:05:30,088
什麼時候封包會被轉送 什麼時候封包會被廣播

107
00:05:30,088 --> 00:05:33,055
什麼時候封包會被過濾

108
00:05:33,055 --> 00:05:36,061
那經過這個五次的封包轉送的過程之後

109
00:05:36,061 --> 00:05:37,095
我們再來檢查一下

110
00:05:37,095 --> 00:05:41,058
這三個bridge他們的database有什麼不一樣

111
00:05:41,058 --> 00:05:45,008
事實上database呢 是不一定會完全一樣

112
00:05:45,008 --> 00:05:47,095
有的有 不一定是完全會一樣的

113
00:05:47,095 --> 00:05:50,035
我們來看一下 這個五個例子裡面我們會

114
00:05:50,035 --> 00:05:54,018
第一個 A送給E 第二個會B送給D

115
00:05:54,018 --> 00:05:57,095
第三個 我們講C送給B 第四個D送給A

116
00:05:57,095 --> 00:05:59,048
第五個E送給C

117
00:05:59,048 --> 00:06:02,095
好我們就看看 一開始來檢查說

118
00:06:02,095 --> 00:06:06,025
這個database呢 到底是怎麼慢慢地學起來

119
00:06:06,025 --> 00:06:08,025
慢慢地建構起來 我們看第一個例子

120
00:06:09,005 --> 00:06:13,035
好 在這個第一個例子裡面 我們假設A送給E

121
00:06:13,035 --> 00:06:17,018
這是假設這樣 好 那A送給E呢 就代表說

122
00:06:17,018 --> 00:06:20,018
一開始呢 這個A呢 就要把這個封包呢

123
00:06:20,018 --> 00:06:22,075
做起來 我們看一下

124
00:06:22,075 --> 00:06:28,061
首先這個封包本身 在製作的時候呢 注意到這個地方

125
00:06:29,088 --> 00:06:32,015
我們說A要送給E嘛

126
00:06:32,015 --> 00:06:37,008
所以A呢就把這個封包的source的MAC就填自己

127
00:06:37,008 --> 00:06:40,048
我們叫A 這個A就代表說這是A送出來的

128
00:06:40,048 --> 00:06:44,078
那這個E呢 就代表說 這個封包呢是要送給E啦

129
00:06:44,078 --> 00:06:48,065
就是直接填E的MAC address 直接填進去

130
00:06:48,065 --> 00:06:52,035
好 就把這個封包呢 我們就丟給這個bridge就丟進去了

131
00:06:52,035 --> 00:06:55,001
好 那這個bridge呢 X

132
00:06:55,001 --> 00:06:57,075
他就從port1收到這個封包啦

133
00:06:57,075 --> 00:07:00,071
那因為一開始這個database都是空的嘛

134
00:07:00,071 --> 00:07:02,071
剛剛講 他根本不知道他在哪裡啊

135
00:07:02,071 --> 00:07:05,021
所以這個封包按照我們剛剛的演算法

136
00:07:05,021 --> 00:07:06,095
他就一定會被廣播

137
00:07:06,095 --> 00:07:10,001
那不過因為在這個例子裡面

138
00:07:10,001 --> 00:07:11,098
我們bridge x呢只有兩個port啦

139
00:07:11,098 --> 00:07:14,088
我們從port 1收進來 就把它轉到port 2

140
00:07:14,088 --> 00:07:16,091
就這樣 就轉到port2去了

141
00:07:16,091 --> 00:07:20,081
那同時轉出去的時候呢 他又做了learning

142
00:07:20,081 --> 00:07:23,058
我們注意到 learning的時候是要看

143
00:07:23,058 --> 00:07:26,018
source MAC address從哪個port進來

144
00:07:26,018 --> 00:07:27,078
我們注意看這個封包

145
00:07:27,078 --> 00:07:31,081
這個封包是A 送的 他從port1進來

146
00:07:31,081 --> 00:07:34,038
所以他的database裡面呢 就紀錄了一個叫

147
00:07:34,038 --> 00:07:37,061
A從port1進來 就這個

148
00:07:37,061 --> 00:07:43,031
這個欄位就告訴我們說 我們收到一個A丟出來的封包

149
00:07:43,031 --> 00:07:45,031
而且是走port1進來

150
00:07:45,031 --> 00:07:47,031
我們就把A跟E就寫在這個database

151
00:07:47,031 --> 00:07:49,018
那這裏我們為了簡單起見

152
00:07:49,018 --> 00:07:51,091
我們把時間的這個參數先把它放掉

153
00:07:51,091 --> 00:07:54,085
那這個我們再來看 bridge X呢

154
00:07:54,085 --> 00:07:57,041
把這個封包丟到這個網路之後呢

155
00:07:57,041 --> 00:08:01,038
就會送到這個地方來 就是bridge Y呢就收到了

156
00:08:01,038 --> 00:08:04,065
那bridge Y收到的時候 他就一樣 看這個封包

157
00:08:04,065 --> 00:08:06,071
第一個 看destination

158
00:08:06,071 --> 00:08:09,078
這destination是要給A的 剛剛這個封包是要給A

159
00:08:09,078 --> 00:08:11,078
對不起 封包是要給E啦

160
00:08:11,078 --> 00:08:14,045
但是呢這個database也是空的啊

161
00:08:14,045 --> 00:08:17,005
所以他做廣播 但是你注意到

162
00:08:17,005 --> 00:08:20,038
這個bridge本身 他的port有三個

163
00:08:20,038 --> 00:08:24,095
所以他從port2收到之後 他的廣播是要到1到3

164
00:08:24,095 --> 00:08:28,098
所以他會把這個封包呢 做這樣子跟這樣子

165
00:08:28,098 --> 00:08:33,035
兩個port都會出去 就同時都會出去喔 這個叫廣播

166
00:08:33,035 --> 00:08:35,078
好 那這個做完之後呢 一樣

167
00:08:35,078 --> 00:08:37,078
他會做address learning

168
00:08:37,078 --> 00:08:40,065
那我們發現說 這個封包是A送的

169
00:08:40,065 --> 00:08:44,081
可是對這個bridge來講 是從port2進來

170
00:08:44,081 --> 00:08:48,025
所以我們這個address呢 這個地方就是A 2

171
00:08:48,025 --> 00:08:51,061
A 2就是 source A從2進來

172
00:08:51,061 --> 00:08:55,055
好 一樣 那這個封包呢 進到這個下一個網路

173
00:08:55,055 --> 00:08:57,085
就所謂的下一個LAN之後呢

174
00:08:57,085 --> 00:09:00,088
就會讓這個 我們講bridge Z

175
00:09:00,088 --> 00:09:04,021
Z就會收到 那收到之後呢 他一樣

176
00:09:04,021 --> 00:09:07,035
他也不知道這個destination E在什麼地方

177
00:09:07,035 --> 00:09:09,038
因為這個database是空的嘛

178
00:09:09,038 --> 00:09:13,038
所以他還是做廣播 廣播的結果呢就是會從這邊送下來

179
00:09:13,038 --> 00:09:15,098
啊這個送下來 剛好就到E了

180
00:09:15,098 --> 00:09:20,005
所以在這個例子裡面 有點反正就是利用廣播

181
00:09:20,005 --> 00:09:24,068
讓這個封包呢 可以送到這個網路的任何一個角落

182
00:09:24,068 --> 00:09:28,051
所以這個E呢 是因為這樣子收到啦

183
00:09:28,051 --> 00:09:32,075
同時這個bridge Z呢

184
00:09:32,075 --> 00:09:35,021
他還是要做這個所謂的address learning

185
00:09:35,021 --> 00:09:40,015
他發現說 這個A送的 可是呢是從他的port 1進來

186
00:09:40,015 --> 00:09:43,055
所以對他來講 他學到的就是A 1

187
00:09:43,055 --> 00:09:46,038
然後呢 這個封包就送給Z

188
00:09:46,038 --> 00:09:48,018
對不起 送給E

189
00:09:48,018 --> 00:09:50,068
所以在這個例子裡面 我們就發現到說

190
00:09:50,068 --> 00:09:54,085
其實這個封包 他呢一直被廣播一直被廣播

191
00:09:54,085 --> 00:09:57,088
但是最後呢 E還是收到了

192
00:09:57,088 --> 00:10:00,058
那他的代價就是說 這個封包呢

193
00:10:00,058 --> 00:10:02,058
其實在網路上面 我們叫做flooding

194
00:10:02,058 --> 00:10:04,095
就是說所有人都收到

195
00:10:04,095 --> 00:10:07,051
當然E也收到 但是所有人也收到

196
00:10:07,051 --> 00:10:10,091
所以這個第一個他其實浪費頻寬 第二個他不太安全

197
00:10:10,091 --> 00:10:14,058
因為不該聽到的也聽到了 不該收到的也收到了

198
00:10:14,058 --> 00:10:17,065
但是沒有辦法 因為他不知道他在哪裡

199
00:10:17,065 --> 00:10:20,075
也就是當我們不知道這個destination在什麼地方的時候

200
00:10:20,075 --> 00:10:22,061
我們只好用這種方式

201
00:10:22,061 --> 00:10:25,098
就是全部把他送出去 管不了頻寬了 管不了安全了

202
00:10:25,098 --> 00:10:27,085
因為我要讓對方收到

203
00:10:27,085 --> 00:10:32,018
但是呢 雖然有這個代價 但是他還是有一點好處

204
00:10:32,018 --> 00:10:33,095
就是他至少已經注意到

205
00:10:33,095 --> 00:10:36,081
這個database呢已經學到了三個東西

206
00:10:36,081 --> 00:10:41,055
我們看 XYZ 這三個bridge他們的database呢

207
00:10:41,055 --> 00:10:45,061
各學到了一個A1 A2 A1

208
00:10:45,061 --> 00:10:47,025
這三個已經被學起來了

209
00:10:47,025 --> 00:10:50,025
這是第一個封包 我們再來看第二個封包

210
00:10:50,025 --> 00:10:53,055
第二個封包呢 我們假設是B要送給D

211
00:10:53,055 --> 00:10:58,008
就是我們B送給D 注意到我們剛剛這個database

212
00:10:58,008 --> 00:11:00,058
因為經過第一個封包的傳送呢

213
00:11:00,058 --> 00:11:03,001
三個database呢各有一個entry

214
00:11:03,001 --> 00:11:05,055
那現在我們看第二個封包出來了

215
00:11:05,055 --> 00:11:08,045
好 那第二個封包因為是B送給D啦

216
00:11:08,045 --> 00:11:11,028
所以我們注意一下 這個封包的這個內容

217
00:11:12,088 --> 00:11:17,055
我們看一下 這個封包的內容就是B送給D嘛

218
00:11:17,055 --> 00:11:20,071
就是填BD 那這個封包丟進去呢

219
00:11:20,071 --> 00:11:24,031
丟到這個LAN之後呢 當然是一個廣播的方式

220
00:11:24,031 --> 00:11:29,051
所以這兩個bridge都會收到 就是這個封包丟進去的時候

221
00:11:29,051 --> 00:11:32,001
丟到這個LAN的時候呢 我們注意到

222
00:11:32,001 --> 00:11:34,048
bridge X跟bridge Y

223
00:11:34,048 --> 00:11:38,075
都收到這個封包 那我們看一下這個封包是要B給D呀

224
00:11:38,075 --> 00:11:42,041
B給D 我們先看bridge X怎麼處理

225
00:11:42,041 --> 00:11:44,078
bridge X收到這個封包的時候他發現說

226
00:11:44,078 --> 00:11:48,035
這個封包是要給D的 B要給D嘛

227
00:11:48,035 --> 00:11:50,011
可這個時候他不知道D在哪裡

228
00:11:50,011 --> 00:11:52,011
因為那個database裡面還沒有

229
00:11:52,011 --> 00:11:55,098
所以他就轉送 就轉送到這個地方來

230
00:11:55,098 --> 00:11:59,095
那我們可以看得到 其實B並不在這個LAN上

231
00:11:59,095 --> 00:12:01,095
所以這個轉送其實是浪費啦

232
00:12:01,095 --> 00:12:06,045
因為我的B 這個D 目的地 根本不在這個LAN

233
00:12:06,045 --> 00:12:10,098
可是因為真的不知道他在哪裡 我只好先這樣盲目的先送出去

234
00:12:10,098 --> 00:12:13,081
那至少我要做一件事情就是做learning

235
00:12:13,081 --> 00:12:15,081
那我做learning的時候我們發現你看

236
00:12:15,081 --> 00:12:18,095
這個B 是經由哪一個port進到這個bridge呢

237
00:12:18,095 --> 00:12:22,088
經由port2 就是第二個port進來的

238
00:12:22,088 --> 00:12:26,095
所以我們新學到的一個欄位就是B 2

239
00:12:26,095 --> 00:12:30,005
就是因為這個封包是B送出來的

240
00:12:30,005 --> 00:12:33,021
而且他經過port2進到這個bridge

241
00:12:33,021 --> 00:12:36,051
就把B 2 就記在這個database裡面

242
00:12:36,051 --> 00:12:39,048
我們再回頭看這個bridge Y

243
00:12:39,048 --> 00:12:41,048
bridge Y呢也收到這個封包了

244
00:12:41,048 --> 00:12:43,081
就在這個地方 那收到這個封包之後呢

245
00:12:43,081 --> 00:12:46,061
他其實也還不知道D在什麼地方

246
00:12:46,061 --> 00:12:49,061
所以他做同樣的事情 就是廣播

247
00:12:49,061 --> 00:12:53,001
這個廣播呢 就發現這個封包就進到這裡來

248
00:12:53,001 --> 00:12:55,001
那同時也進到這裡來

249
00:12:55,001 --> 00:12:57,081
就是全部進到相連的這個LAN啦

250
00:12:57,081 --> 00:13:00,068
好 那進到這裡面來的時候呢

251
00:13:00,068 --> 00:13:04,015
就送出去了 同時他也一樣做address learning

252
00:13:04,015 --> 00:13:08,078
那我們發現到說 這個封包是從他的哪一個port進來呢

253
00:13:08,078 --> 00:13:13,078
是從一樣 從他的port2進來 這個封包是B送的

254
00:13:13,078 --> 00:13:18,021
所以新一個這個learning的entry就是B 2

255
00:13:18,021 --> 00:13:21,068
就是這個是 stationB送的

256
00:13:21,068 --> 00:13:25,078
而且從port2進來 所以是B 2 就放在database裡面

257
00:13:25,078 --> 00:13:29,008
其實這個封包進到這個LAN的時候呢

258
00:13:29,008 --> 00:13:32,031
因為我們注意到這個B在這個地方 B在這裡

259
00:13:32,031 --> 00:13:34,031
所以這個封包進到這個區域網路的時候

260
00:13:34,031 --> 00:13:38,071
B就已經收到了 所以B送給D到這個時候呢

261
00:13:38,071 --> 00:13:42,085
其實D已經收到了 可這個封包呢是沒辦法停的

262
00:13:42,085 --> 00:13:46,061
他繼續往前衝 就衝到這個bridge Z

263
00:13:46,061 --> 00:13:51,008
那bridge Z收到之後呢 他其實他也不知道這個D在哪裡

264
00:13:51,008 --> 00:13:53,008
因為他的database裡面還沒有

265
00:13:53,008 --> 00:13:56,025
所以他還是做了這個廣播的動作

266
00:13:56,025 --> 00:13:59,065
所以這個封包呢 還是被廣播送到這個下面這個LAN來

267
00:13:59,065 --> 00:14:02,055
當然他也做了address learning

268
00:14:02,055 --> 00:14:05,098
我們一直強調 一個bridge收到封包呢 做兩件事

269
00:14:05,098 --> 00:14:07,098
一個轉播 一個學習

270
00:14:07,098 --> 00:14:11,048
那學習的時候就發現說 這個封包是B送的

271
00:14:11,048 --> 00:14:14,055
而且從哪一個port進來呢 從port1進來

272
00:14:14,055 --> 00:14:17,021
所以他一樣把它address learning

273
00:14:17,021 --> 00:14:20,001
B 1呢就記起來 就B 1

274
00:14:20,001 --> 00:14:23,081
所以我們在這裡面呢 就講第二個封包

275
00:14:23,081 --> 00:14:30,058
B送給D的過程 一樣 我們發現這個封包其實也做了廣播

276
00:14:30,058 --> 00:14:31,081
我們發現這個封包

277
00:14:31,081 --> 00:14:35,048
也是被送到這個整個網路的任何一個角落

278
00:14:35,048 --> 00:14:37,048
其實他一樣 碰到一樣的問題

279
00:14:37,048 --> 00:14:41,088
他浪費了頻寬 第二個他其實增加了security的風險

280
00:14:41,088 --> 00:14:47,051
那是因為 我們這個所謂的database裡面 還不夠完整

281
00:14:47,051 --> 00:14:52,018
我們沒有任何有D 的位置的學習的資料

282
00:14:52,018 --> 00:14:55,048
所以是要用廣播 但是我們至少學到一個東西

283
00:14:56,008 --> 00:14:59,095
就是我們的database呢 已經學到了兩個

284
00:14:59,095 --> 00:15:03,081
我們第一個封包 我們讓這個database裡面多一項

285
00:15:03,081 --> 00:15:07,041
第二個封包我們發現已經多兩項 也就是說

286
00:15:07,041 --> 00:15:09,041
我們等下會再繼續的解釋

287
00:15:09,041 --> 00:15:13,041
就是說我們隨著這個封包送的數量越多

288
00:15:13,041 --> 00:15:17,031
我們這個filtering database呢學到的內容就會越完整

289
00:15:17,031 --> 00:15:19,008
當他越完整的時候呢

290
00:15:19,008 --> 00:15:23,068
這個廣播的現象就會越來越少

291
00:15:23,068 --> 00:15:25,068


