1
00:00:08,035 --> 00:00:10,051
好 那接下來我們來介紹

2
00:00:10,051 --> 00:00:11,071
這個spanning tree 怎麼做

3
00:00:11,071 --> 00:00:12,085
所謂的matainnus

4
00:00:12,085 --> 00:00:14,035
好 就是我們剛剛提到

5
00:00:14,035 --> 00:00:17,031
這個網路在開始建的時候

6
00:00:17,031 --> 00:00:19,015
可能會故意把她連成所謂的

7
00:00:19,015 --> 00:00:22,085
root 為了要提升整個網路的可靠度

8
00:00:22,085 --> 00:00:25,011
可是在運作的時候呢

9
00:00:25,011 --> 00:00:27,018
我們要讓它變成沒有root 所以

10
00:00:27,018 --> 00:00:29,018
我會run所謂的spanning tree 的

11
00:00:29,018 --> 00:00:32,095
結構出來 好

12
00:00:32,095 --> 00:00:34,028
封包的轉送

13
00:00:34,028 --> 00:00:36,028
這個過濾 adress learning

14
00:00:36,028 --> 00:00:38,028
都是從這個spanning tree 運作

15
00:00:38,028 --> 00:00:40,051
都是重這個spanning tree 來運作

16
00:00:40,051 --> 00:00:47,001
好 那可是呢 這個網路可能會因為bridge 突然當機

17
00:00:47,001 --> 00:00:49,065
網路線突然不小心斷掉

18
00:00:49,065 --> 00:00:52,058
那使得讓我們的tree 突然斷掉

19
00:00:52,058 --> 00:00:55,071
那突然斷掉的話 我們第一個要去怎麼偵測

20
00:00:55,071 --> 00:00:57,025
這個網路斷掉了

21
00:00:57,025 --> 00:01:04,011
然後怎麼再做復原 這個所謂spanning tree 的maintainus

22
00:01:04,011 --> 00:01:05,045
接下來再來看

23
00:01:05,045 --> 00:01:07,098
這個spanning tree 的maintainus 怎麼做

24
00:01:07,098 --> 00:01:09,048
我們說 第一個

25
00:01:09,048 --> 00:01:17,045
這個root bridege 本身 他要定期送所謂的communication BPDU

26
00:01:17,045 --> 00:01:20,008
就如各位剛剛看到 那個藍色的封包

27
00:01:20,008 --> 00:01:24,075
就是說 從root 呢 它每隔一秒鐘或每隔兩秒鐘

28
00:01:24,075 --> 00:01:27,045
他就會送這個BPDU出來

29
00:01:27,045 --> 00:01:29,045
在那個tree上面

30
00:01:29,045 --> 00:01:31,045
在tree上面一直轉

31
00:01:31,045 --> 00:01:32,081
那我們所謂的hotbin

32
00:01:32,081 --> 00:01:34,098
好像心跳一樣

33
00:01:34,098 --> 00:01:38,058
就這樣一直送 一直送 每個時間去送

34
00:01:38,058 --> 00:01:42,011
好 那如果說你有網路斷掉有bridge壞掉

35
00:01:42,011 --> 00:01:45,058
那他後面那個他就收不到了 因為它斷掉了

36
00:01:45,058 --> 00:01:47,041
所以變成說 沒有收到

37
00:01:47,041 --> 00:01:51,011
這種所謂的這種BPDU的這種bridge的話

38
00:01:51,011 --> 00:01:54,061
他就會發現說 這個網路可能是斷線了

39
00:01:54,061 --> 00:01:57,008
所以我才收不到 那他就會開始做反應

40
00:01:57,008 --> 00:02:00,015
等下會跟各位做比較詳細的介紹

41
00:02:00,015 --> 00:02:02,055
所以我們說 這個root本身

42
00:02:02,055 --> 00:02:06,028
他為了維護這個spanning tree的正常的運作呢

43
00:02:06,028 --> 00:02:10,078
他會 週期性的 可能是每隔一秒或兩秒鐘

44
00:02:10,078 --> 00:02:13,088
他會送出一個叫做configuration BPDU

45
00:02:13,088 --> 00:02:16,018
沿著 沿著這個spanning tree

46
00:02:16,018 --> 00:02:18,025
讓他沿著spanning tree走

47
00:02:18,025 --> 00:02:22,001
所以會沿著spanning tree呢 把他送到網路的各個角落去

48
00:02:22,001 --> 00:02:26,005
好 那一個bridge呢 他就會

49
00:02:26,005 --> 00:02:29,031
因為一個bridge本身 他也一定有一個R port嘛

50
00:02:29,031 --> 00:02:30,058
剛剛提到 他有一個R port

51
00:02:30,058 --> 00:02:35,028
可能會有一些D port 因為我們一個bridge有很多port

52
00:02:35,028 --> 00:02:39,055
其中有一個是R port 那有一些可能是D port

53
00:02:39,055 --> 00:02:42,028
代表他代理相連的這個LAN

54
00:02:42,028 --> 00:02:45,051
那剛才他可能也有一些所謂的block port

55
00:02:45,051 --> 00:02:48,031
就是他暫時被中斷掉的 好

56
00:02:48,031 --> 00:02:52,018
那這個R port呢一定是屬於spanning tree的一部分

57
00:02:52,018 --> 00:02:56,061
R port 所以他會從root這邊 收到剛剛那個

58
00:02:56,061 --> 00:03:00,075
每隔一個hello time送進來的這個BPDU

59
00:03:00,075 --> 00:03:04,055
等於他會收進來 一個bridge他會定期從這邊收進來

60
00:03:04,055 --> 00:03:06,031
正常都會這樣子 一直收進來

61
00:03:06,031 --> 00:03:10,071
那收進來之後呢 就會把他從別的port把他丟下去的意思

62
00:03:10,071 --> 00:03:14,071
從別的port把他丟下去 那所以每一個bridge呢

63
00:03:14,071 --> 00:03:18,048
就會從root這邊收到一個BPDU 然後把他轉出去

64
00:03:18,048 --> 00:03:21,081
再一個BPDU 再把他轉出去

65
00:03:21,081 --> 00:03:26,048
這是平常就會做事情 那接下來就是說

66
00:03:26,048 --> 00:03:30,055
好 這個root送出來這個BPDU呢

67
00:03:30,055 --> 00:03:32,075
就會經由bridge呢 就一個轉出去

68
00:03:32,075 --> 00:03:34,085
再轉出去 再轉出去

69
00:03:34,085 --> 00:03:37,081
就剛剛提到 他會沿著這個spanning tree呢

70
00:03:37,081 --> 00:03:42,028
就會送到這個網路的各個角落去 讓好像說

71
00:03:42,028 --> 00:03:43,095
這個spanning tree還是正常運作

72
00:03:43,095 --> 00:03:48,011
好 那可是呢 當我們bridge壞掉的時候

73
00:03:48,011 --> 00:03:51,071
譬如說這個bridge本來應該這樣子收 然後轉

74
00:03:51,071 --> 00:03:54,081
收 轉 那如果他一壞掉

75
00:03:54,081 --> 00:03:59,081
這個收就停止了 那轉也停止了

76
00:03:59,081 --> 00:04:04,058
那這個轉一停止 那後面這個診斷的spanning tree

77
00:04:04,058 --> 00:04:08,031
我們講一個subtree 那整個就沒有這種hello出來了

78
00:04:08,031 --> 00:04:12,085
就因為他進不去了嘛 那他們就會發生所謂的time out

79
00:04:12,085 --> 00:04:15,098
那time out之後 他就認為說

80
00:04:15,098 --> 00:04:18,071
一定是一個bridge壞掉 或者一個link斷掉

81
00:04:18,071 --> 00:04:21,095
那就開始要啟動復原的動作

82
00:04:21,095 --> 00:04:26,021
等下會跟各位介紹 好那復原的假設已經

83
00:04:26,021 --> 00:04:28,041
找到一個所謂的備援

84
00:04:28,041 --> 00:04:32,048
所謂的備援就是說 我們之前本來就是有loop

85
00:04:32,048 --> 00:04:36,068
那因為這個link 因為spanning tree呢故意讓他中斷了

86
00:04:36,068 --> 00:04:39,088
其實是網路是沒有把它扯斷的 網路還是在

87
00:04:39,088 --> 00:04:42,075
只是故意讓他變成好像中斷一樣

88
00:04:42,075 --> 00:04:47,001
那現在如果說這個地方不行了 我可以把它啟動

89
00:04:47,001 --> 00:04:50,045
才啟動之後可能就會把那個所謂的spanning tree呢

90
00:04:50,045 --> 00:04:53,058
稍微做個變更啦 就是我還是可以有一個spanning tree

91
00:04:53,058 --> 00:04:58,038
可是跟剛剛長得不一樣 這個叫所謂的topology change

92
00:04:58,038 --> 00:05:03,018
那這種所謂的拓墣變更了嘛 那這種我要通知這個root

93
00:05:03,018 --> 00:05:06,015
所以任何一個bridge 如果他發現說

94
00:05:06,015 --> 00:05:11,045
他的這個port的角色 譬如說port的角色呢變掉了

95
00:05:11,045 --> 00:05:13,085
原來是R port的 變成D port

96
00:05:13,085 --> 00:05:15,081
或者原來D port的變成R port

97
00:05:15,081 --> 00:05:19,061
反正他的port呢 這個角色的扮演如果有變更

98
00:05:19,061 --> 00:05:22,061
就代表這個spanning tree呢已經有變化

99
00:05:22,061 --> 00:05:24,088
那他就去通知這個root

100
00:05:24,088 --> 00:05:29,038
阿這個通知呢 就會送出這個叫做TCN

101
00:05:29,038 --> 00:05:34,005
叫做所謂的topology change notification的這種封包

102
00:05:34,005 --> 00:05:37,071
就要送給這個root 那這種所謂的

103
00:05:37,071 --> 00:05:41,015
拓墣變更的這個事情算是很嚴重的事情

104
00:05:41,015 --> 00:05:45,075
所以這種封包要送給root的話 他要非常可靠

105
00:05:45,075 --> 00:05:48,035
他一定要送到root 就是這種使命必達

106
00:05:48,035 --> 00:05:53,071
這種封包如果送到中間掉了 那root沒有被通知到

107
00:05:53,071 --> 00:05:55,075
那以後整個就完蛋了

108
00:05:55,075 --> 00:05:58,055
所以這種送就一定 我們叫做要reliable

109
00:05:58,055 --> 00:05:59,091
他用 就是透過TCP

110
00:05:59,091 --> 00:06:03,005
就變成說 一個交給一個 一個交給一個

111
00:06:03,005 --> 00:06:06,061
就沿著那個spanning tree 就是一步一步一步一步

112
00:06:06,061 --> 00:06:10,085
最後到達root 那root收到這種所謂的topology change

113
00:06:10,085 --> 00:06:13,018
他就知道說這個網路結構已經被變掉了

114
00:06:13,018 --> 00:06:17,008
那他就要通知大家說 這個網路的結構已經變調

115
00:06:17,008 --> 00:06:22,031
我們之前所學習的這個address呢 可能要重新學過

116
00:06:22,031 --> 00:06:26,001
因為位置 tree一變更 相對位置就變掉了

117
00:06:26,001 --> 00:06:29,018
本來可能在左邊的 現在可能變到右邊了

118
00:06:29,018 --> 00:06:32,048
左邊右邊 這個位置稍微一變更的話

119
00:06:32,048 --> 00:06:34,088
你之前的database可能就會沒有用

120
00:06:34,088 --> 00:06:36,091
所以要重新做這個learning

121
00:06:36,091 --> 00:06:38,065
會有這個動作 連鎖反應啦

122
00:06:38,065 --> 00:06:41,085
好 也就是說root如果收到這個

123
00:06:41,085 --> 00:06:44,041
所謂的topology change的BPDU

124
00:06:44,041 --> 00:06:48,095
收到之後呢 他就會設定一個topology change的flag

125
00:06:48,095 --> 00:06:51,048
因為這個root本身他那個藍色的

126
00:06:51,048 --> 00:06:53,041
他一直在送嘛 還是在送

127
00:06:53,041 --> 00:06:55,098
那這個送呢 他就會把一個bit說

128
00:06:55,098 --> 00:06:58,065
這個topology change flag 把他設定起來

129
00:06:58,065 --> 00:07:01,018
告訴大家說 這個topology已經變更了

130
00:07:01,018 --> 00:07:05,011
所以你們之前所學習的這個filtering database的資料呢

131
00:07:05,011 --> 00:07:08,098
可能要做一個所謂的reset 重新再學過

132
00:07:08,098 --> 00:07:10,008
因為資料不對

133
00:07:10,008 --> 00:07:12,041
好底下呢 我們就用這個例子呢

134
00:07:12,041 --> 00:07:16,065
來跟各位介紹說 好 當一個bridge壞掉的時候

135
00:07:16,065 --> 00:07:18,058
會發生什麼事情

136
00:07:18,058 --> 00:07:23,015
我們看這個圖 這個圖跟我們之前所看的圖是一樣的

137
00:07:23,015 --> 00:07:26,011
那我們也發現說這個root

138
00:07:26,011 --> 00:07:29,088
他就定期的在送這個所謂的BPDU

139
00:07:29,088 --> 00:07:35,035
那這個藍色的這個封包呢 事實上他就是沿著spanning tree

140
00:07:35,035 --> 00:07:38,068
到達這個所謂的 網路的任何一個角落

141
00:07:38,068 --> 00:07:43,081
所以任何一個bridge呢 他都會定期的收到這個封包

142
00:07:43,081 --> 00:07:46,051
就是有點像所謂的 heartbeat

143
00:07:46,051 --> 00:07:49,001
就是這個心跳 到底還在不在

144
00:07:49,001 --> 00:07:51,041
因為它固定的時間就會送出來

145
00:07:51,041 --> 00:07:55,095
好那我們現在就是說 假設呢

146
00:07:55,095 --> 00:07:59,018
發生了一個現象 就是這個

147
00:07:59,018 --> 00:08:01,065
bridge6 假設他掛掉了

148
00:08:01,065 --> 00:08:04,061
那掛掉的現象就是說 這個封包呢

149
00:08:04,061 --> 00:08:08,005
BPDU的封包呢 就送到這個bridge 6之後

150
00:08:08,005 --> 00:08:11,068
到這個地方 就停了

151
00:08:11,068 --> 00:08:15,021
就因為像他已經掛掉了 所以他就不會往下送了

152
00:08:15,021 --> 00:08:18,091
所以我們就注意到 注意到說這個時候呢

153
00:08:18,091 --> 00:08:26,021
這一段 他沒有BPDU進去了

154
00:08:26,021 --> 00:08:31,025
在這段這個紅色左上角這一塊呢 BPDU進不去了

155
00:08:31,025 --> 00:08:35,005
好 才沒有BPDU進來的話 他們就會time out

156
00:08:35,005 --> 00:08:37,085
誰會time out呢 就是說

157
00:08:37,085 --> 00:08:40,091
bridge3跟bridge4呢 他都會time out

158
00:08:40,091 --> 00:08:42,075
就是這個 這個地方

159
00:08:42,075 --> 00:08:45,051
因為他的地方本來是 本來這個地方會有這個

160
00:08:45,051 --> 00:08:47,045
藍色的應該要進到這裡面來

161
00:08:47,045 --> 00:08:51,031
本來要這樣子嘛 所以他本來就會收的到這個BPDU

162
00:08:51,031 --> 00:08:55,008
就是說 一旦這個bridge6壞掉之後呢

163
00:08:55,008 --> 00:08:58,051
他的BPDU就進不來啦 進不來之後 這個

164
00:08:58,051 --> 00:09:03,005
bridge3跟bridge4 他們就覺得說 本來看得到的

165
00:09:03,005 --> 00:09:05,001
現在都看不到了 聽不到了

166
00:09:05,001 --> 00:09:08,028
那通常他會經過一個比較長的時間

167
00:09:08,028 --> 00:09:11,055
譬如說 三個hello time的時間

168
00:09:11,055 --> 00:09:15,075
譬如說三到四秒 發現說這個BPDU都沒有來

169
00:09:15,075 --> 00:09:17,088
他就認為說 他大概知道說

170
00:09:17,088 --> 00:09:21,005
這個可能他掛掉了 那掛掉之後

171
00:09:21,005 --> 00:09:23,065
接下來就是說 那我可不可以成為

172
00:09:23,065 --> 00:09:25,045
這個LAN的代理

173
00:09:25,045 --> 00:09:29,081
所以接下來3跟4 bridge3跟bridge4呢

174
00:09:29,081 --> 00:09:34,018
他們就想成為這個LAN的代理 成為LAN2的代理

175
00:09:34,018 --> 00:09:37,078
那成為LAN2的代理 按照我們之前介紹的方法就說

176
00:09:37,078 --> 00:09:41,008
那我們就丟一個封包下去 丟一個封包下去說

177
00:09:41,008 --> 00:09:44,038
我可以成為這個LAN2的代理 所以他會做這個動作

178
00:09:44,038 --> 00:09:47,061
譬如說我們講 LAN4 他先丟下去

179
00:09:47,061 --> 00:09:50,075
剛剛提到我們剛注意到有一個封包從LAN4呢

180
00:09:50,075 --> 00:09:53,038
丟出來 這個LAN4丟出來

181
00:09:53,038 --> 00:09:56,055
他丟一個這樣的封包進來 進到這個LAN裡面來

182
00:09:56,055 --> 00:09:59,018
說 我可以成為這個LAN的代理

183
00:09:59,018 --> 00:10:01,035
他希望成為這個LAN的代理

184
00:10:01,035 --> 00:10:03,071
他丟進去什麼東西呢 一樣

185
00:10:03,071 --> 00:10:06,021
那個BPDU裡面有說 他的root是誰

186
00:10:06,021 --> 00:10:08,018
他的root是1嘛 現在是1

187
00:10:08,018 --> 00:10:11,041
那他的id是什麼 他的id是bridge4嘛

188
00:10:11,041 --> 00:10:16,005
那他的RPC是多少 那他的RPC是15

189
00:10:16,005 --> 00:10:17,095
也就是 注意到他的RPC是15

190
00:10:17,095 --> 00:10:20,081
所以他把這個15呢 就寫到這裡面去

191
00:10:20,081 --> 00:10:25,055
告訴他說 等於說這個bridge4把這個封包丟進去

192
00:10:25,055 --> 00:10:30,081
他其實是在做一種宣告就是說 如果這個LAN2

193
00:10:30,081 --> 00:10:35,055
由我來代理的話 我可以給他多少的這個好處呢

194
00:10:35,055 --> 00:10:40,071
就是透過我呢 到root呢 cost只要15就好了

195
00:10:40,071 --> 00:10:44,068
那這個bridge3 這個bridge3在這邊

196
00:10:44,068 --> 00:10:46,088
他收到這個的時候 他就看一下說

197
00:10:46,088 --> 00:10:50,071
那他可不可以是更好的代理呢

198
00:10:50,071 --> 00:10:54,028
所以他發現說 那如果我是bridge3呢

199
00:10:54,028 --> 00:10:58,068
我如果成為代理的話 那我到這個root 他是走這條路嘛

200
00:10:58,068 --> 00:11:03,015
他的cost也是15啊 跟剛剛那個bridge4是一樣啊

201
00:11:03,015 --> 00:11:06,045
所以我們bridge3跟bridge4都認為說

202
00:11:06,045 --> 00:11:09,031
那我的cost也是跟你一樣對不對

203
00:11:09,031 --> 00:11:12,088
你是15我也是15啊 而且呢我的id比你小

204
00:11:12,088 --> 00:11:16,015
bridge3的id比bridge4還小啊

205
00:11:16,015 --> 00:11:18,095
所以小的優先嘛 所以注意到

206
00:11:18,095 --> 00:11:21,018
接下來呢會發生一件事情

207
00:11:21,018 --> 00:11:26,048
就是bridge3他就認為說 我更具有資格

208
00:11:26,048 --> 00:11:30,021
來代理這個bridge 所以他就回送一個封包出去

209
00:11:30,021 --> 00:11:34,091
跟bridge4講說 我才是最好的代理

210
00:11:34,091 --> 00:11:37,068
我雖然cost跟你一樣 我id比你小

211
00:11:37,068 --> 00:11:43,058
也就是說 剛剛這個4送的時候 他就希望成為代理

212
00:11:43,058 --> 00:11:48,035
所以我們再回到前面去 就是4送出去的時候

213
00:11:48,035 --> 00:11:50,081
他就把這個port 注意到

214
00:11:50,081 --> 00:11:53,038
他就把這個送出去這個port

215
00:11:53,038 --> 00:11:56,058
就暫時把它變成所謂的D port

216
00:11:56,058 --> 00:11:59,038
他送出去就認為說 我是變回D port

217
00:11:59,038 --> 00:12:03,081
可是等一下這個3又回敬一個給他 說我更好

218
00:12:03,081 --> 00:12:06,075
所以這個port呢又變成block port了

219
00:12:06,075 --> 00:12:10,085
所以我們講那個port的state 他會變換

220
00:12:10,085 --> 00:12:14,068
當他想成為代理的時候 他就變成D port

221
00:12:14,068 --> 00:12:18,005
可是等下呢 這個bridge3又送來一個更好的

222
00:12:18,005 --> 00:12:19,098
所以他又會回到那個block port去了

223
00:12:19,098 --> 00:12:24,045
所以這個D port 反而應該這個時候是變成這個

224
00:12:24,045 --> 00:12:28,088
這個地方才對 變成是bridge3才是變成D port

225
00:12:28,088 --> 00:12:31,025
那這個就不是了 就不是

226
00:12:31,025 --> 00:12:34,095
才經過一段時間 因為這個時候可以有辦法來競爭

227
00:12:34,095 --> 00:12:38,051
成為這個LAN2的代理的這個bridge

228
00:12:38,051 --> 00:12:40,048
只有bridge3跟bridge4

229
00:12:40,048 --> 00:12:43,031
那他們經過bridge4先送一個封包

230
00:12:43,031 --> 00:12:45,055
然後bridge3再回一個封包

231
00:12:45,055 --> 00:12:49,068
那之間因為接下來就沒有其他的bridge可以來競爭了

232
00:12:49,068 --> 00:12:55,068
所以最後 這個bridge3就會成為這個LAN2的代理

233
00:12:55,068 --> 00:12:59,005
那成為LAN2的代理注意到 接下來會發生一個現象

234
00:12:59,005 --> 00:13:05,035
所以等於說 這個bridge3 他就把這個

235
00:13:05,035 --> 00:13:09,071
他的這個port 變成他的代理

236
00:13:09,071 --> 00:13:12,071
那他同時 我們再往前看一下

237
00:13:12,071 --> 00:13:18,015
同時呢這個 他會送一個這個所謂的

238
00:13:18,015 --> 00:13:22,028
這個 綠色的 給這個root

239
00:13:22,028 --> 00:13:26,065
這個綠色的就是topology change notification

240
00:13:26,065 --> 00:13:29,045
告訴他說 因為他的port改變了

241
00:13:29,045 --> 00:13:31,095
對bridge3來講的話 他本來這個port

242
00:13:31,095 --> 00:13:35,038
對bridge3來講 剛剛原來這個port本來是一個

243
00:13:35,038 --> 00:13:38,058
這個port 本來是一個block port

244
00:13:38,058 --> 00:13:40,001
現在變成D port了

245
00:13:40,001 --> 00:13:45,058
所以他就送這個topology change給這個root

246
00:13:45,058 --> 00:13:48,021
root就會告訴大家說 現在拓墣改變了

247
00:13:48,021 --> 00:13:51,031
那結果你會發現到 這個

248
00:13:51,031 --> 00:13:55,018
現在多了一個新的路徑出來

249
00:13:55,018 --> 00:13:57,095
就剛剛提到 本來送到這裡的

250
00:13:57,095 --> 00:14:01,065
到這裡 斷掉 就還是斷掉

251
00:14:01,065 --> 00:14:02,095
因為bridge6還是不見了

252
00:14:02,095 --> 00:14:05,098
可是他多了一條路喔 這樣子

253
00:14:05,098 --> 00:14:08,038
這樣進去了

254
00:14:08,038 --> 00:14:13,031
所以這一條路就變成說 我們只要把剛剛這個port

255
00:14:13,031 --> 00:14:17,045
這個port 本來從block port 把它改成D port

256
00:14:17,045 --> 00:14:20,031
整個spanning tree就又活起來了

257
00:14:20,031 --> 00:14:21,091
你看 在這個架構裡面

258
00:14:21,091 --> 00:14:25,008
雖然這個bridge6 這個已經壞掉了

259
00:14:25,008 --> 00:14:30,031
那這個封包 BPDU到這裡 就停滯了

260
00:14:30,031 --> 00:14:33,005
但是沒有關係 我們現在等於繞道

261
00:14:33,005 --> 00:14:37,081
從左邊這邊繞進來 到這邊 到這樣子進來

262
00:14:37,081 --> 00:14:41,061
所以我們還是把這個spanning tree呢給救回來了

263
00:14:41,061 --> 00:14:45,001
就是說 一個bridge壞掉 沒關係

264
00:14:45,001 --> 00:14:49,055
那相鄰的這個bridge呢會知道說 他可能壞掉了

265
00:14:49,055 --> 00:14:51,028
因為我沒有收到BPDU了

266
00:14:51,028 --> 00:14:52,071
所以我就會time out

267
00:14:52,071 --> 00:14:55,008
那time out之後我就會啟動一個動作就是說

268
00:14:55,008 --> 00:14:57,085
那既然這個birdge呢他掛掉了

269
00:14:57,085 --> 00:15:03,031
那他相連這個LAN 那我可不可以變成他的代理的bridge

270
00:15:03,031 --> 00:15:06,091
所以他們就會進行一個所謂的代理權的這個競爭

271
00:15:06,091 --> 00:15:09,031
互相競爭 那最後呢 有一個

272
00:15:09,031 --> 00:15:12,098
總有一個嘛 取得這個所謂的LAN的代理權

273
00:15:12,098 --> 00:15:15,081
那他的那個port 就變成D port

274
00:15:15,081 --> 00:15:17,051
那變成D port呢

275
00:15:17,051 --> 00:15:20,065
他就會經過 我們講一個forwarding delay

276
00:15:20,065 --> 00:15:22,015
經過兩個forwarding delay

277
00:15:22,015 --> 00:15:27,031
最後他大致底定之後 這個port的這個port呢就決定了

278
00:15:27,031 --> 00:15:30,035
決定之後呢 那spanning tree呢就

279
00:15:30,035 --> 00:15:33,021
換成這個新的spanning tree了

280
00:15:33,021 --> 00:15:35,081
也就是說 這個spanning tree他本身

281
00:15:35,081 --> 00:15:39,011
它具有 這個所謂的可靠度

282
00:15:39,011 --> 00:15:40,075
跟這個所謂的強韌性

283
00:15:40,075 --> 00:15:43,015
一個bridge壞掉 沒有問題的

284
00:15:43,015 --> 00:15:46,048
我們可以經過這個tree的這個重建之後

285
00:15:46,048 --> 00:15:49,091
就會得到一個這個新的spanning tree

286
00:15:49,091 --> 00:15:52,078
就是我們上面所 這個顯示的

287
00:15:52,078 --> 00:15:54,078


