1
00:00:10,011 --> 00:00:12,071
好 那我們剛剛有提到說

2
00:00:12,071 --> 00:00:17,045
假設我們的網路的結構呢 就像這個圖上面所顯示的

3
00:00:17,045 --> 00:00:19,028
譬如說我們這邊有5個bridge

4
00:00:19,028 --> 00:00:21,028
然後呢 也有5個LAN

5
00:00:21,028 --> 00:00:25,041
然後每一個bridge他的每一個port的transmission cost

6
00:00:25,041 --> 00:00:29,021
所謂的path cost 上面都有 不管是10啦5啊什麼

7
00:00:29,021 --> 00:00:31,081
好 那我們剛剛有提到說

8
00:00:31,081 --> 00:00:36,041
我們這個id最小的呢 會當成所謂root bridge

9
00:00:36,041 --> 00:00:40,035
那以這個圖的例子來講 我們的root bridge在這個地方

10
00:00:40,035 --> 00:00:42,095
因為他的id是最小的

11
00:00:42,095 --> 00:00:48,025
然後呢 id最小的這個root bridge找出來之後呢

12
00:00:48,025 --> 00:00:52,035
我們接下來就是每一個bridge呢 他就開始要找到說

13
00:00:52,035 --> 00:00:54,078
他到底哪一條路

14
00:00:54,078 --> 00:00:57,095
因為他可能好幾條路可以到這個root bridge

15
00:00:57,095 --> 00:01:00,071
哪一條路呢 他的cost是最小的

16
00:01:00,071 --> 00:01:03,081
然後就把那個路把它找出來

17
00:01:03,081 --> 00:01:06,078
而且把那個port找出來 那個port就叫做root port

18
00:01:06,078 --> 00:01:09,048
所以我們看一下 對bridge2來講

19
00:01:09,048 --> 00:01:11,045
我們講他的root port在這裡

20
00:01:11,045 --> 00:01:14,008
那bridge3來講的話呢 他的root port在這裡

21
00:01:14,008 --> 00:01:16,075
bridge4來講他的root port在這個地方

22
00:01:16,075 --> 00:01:18,075
bridge5呢 root port在這裡

23
00:01:18,075 --> 00:01:23,048
就是說除了root bridge之外 其他的bridge呢都找到

24
00:01:23,048 --> 00:01:26,085
到這個所謂的root port

25
00:01:26,085 --> 00:01:29,065
然後每一個LAN 注意到 每一個LAN

26
00:01:29,065 --> 00:01:33,031
像這個LAN2 他的port呢是這個

27
00:01:33,031 --> 00:01:35,028
我們叫做代理的port

28
00:01:37,081 --> 00:01:41,041
然後這個LAN5呢他的代理的port在這個地方

29
00:01:41,041 --> 00:01:45,058
然後LAN4呢 LAN4的代理的port在這個地方

30
00:01:45,058 --> 00:01:48,025
就是我們只要把這些都找出來之後呢

31
00:01:48,025 --> 00:01:51,045
就會發現到說 沒有被找到的

32
00:01:51,045 --> 00:01:53,095
就是每一個port 他其實只有一個角色

33
00:01:53,095 --> 00:01:57,015
注意到 每一個port他只有一個角色

34
00:01:57,015 --> 00:02:00,038
就是他如果 他是所謂的root port

35
00:02:00,038 --> 00:02:03,088
就像上個地方 他是root port 或者他是D port

36
00:02:03,088 --> 00:02:07,008
就是說每一個port呢 她要扮演一個角色

37
00:02:07,008 --> 00:02:11,045
要嘛就是所謂的root port 要嘛就是所謂的D port

38
00:02:11,045 --> 00:02:13,075
我們叫D  designated port

39
00:02:13,075 --> 00:02:16,015
如果不是這兩個port的角色的話呢

40
00:02:16,015 --> 00:02:19,008
那就是這種 就是紅色的這個

41
00:02:19,008 --> 00:02:22,035
那紅色這個port呢 就所謂的被block

42
00:02:22,035 --> 00:02:25,011
就是他如果沒有扮演一個port

43
00:02:25,011 --> 00:02:27,085
如果沒有扮演R port 所謂的root port

44
00:02:27,085 --> 00:02:31,011
或者沒有扮演D port 所謂的designated port

45
00:02:31,011 --> 00:02:34,088
那他就會被block 被block的意思就是說

46
00:02:34,088 --> 00:02:39,041
在這個上面紅色的就是說 這個port呢 就是暫時被中斷

47
00:02:39,041 --> 00:02:42,088
就是我們剛剛提到 我們有迴路嘛

48
00:02:42,088 --> 00:02:45,075
這個網路上面有迴路 這個每一個迴路呢

49
00:02:45,075 --> 00:02:49,058
我們都要找到一個edge 就一個link呢把它中斷

50
00:02:49,058 --> 00:02:53,075
把它中斷的意思就是 他這個連接的port呢把它變成紅色的

51
00:02:53,075 --> 00:02:56,085
就是變成block port 那block port的意思就是說

52
00:02:56,085 --> 00:02:59,065
他真的網路呢並不是把網路把它拔掉

53
00:02:59,065 --> 00:03:03,088
網路還是連在一起的 可是封包進來的時候呢

54
00:03:03,088 --> 00:03:09,025
就把它當成是斷線了 不再轉送 不再學習

55
00:03:09,025 --> 00:03:13,021
就是他相當於是一個斷線的 事實上是沒有斷線

56
00:03:13,021 --> 00:03:17,068
只是呢 把它當成是一個斷線的這個link來看

57
00:03:17,068 --> 00:03:20,098
譬如說 當你的封包進到這裡的時候呢

58
00:03:20,098 --> 00:03:24,035
你就不能轉送了 那data的封包呢

59
00:03:24,035 --> 00:03:27,041
剛剛提到 進到一個LAN的這個封包呢

60
00:03:27,041 --> 00:03:33,005
一定 會從他的代理的port進來

61
00:03:33,005 --> 00:03:35,078
也就是說 如果像這個case來講的話

62
00:03:35,078 --> 00:03:39,028
要進到LAN2的封包 譬如說

63
00:03:39,028 --> 00:03:42,041
譬如說我們這邊LAN4呢有一個封包

64
00:03:42,041 --> 00:03:46,041
他要送給這個LAN2呢 他就必須走這一條路

65
00:03:46,041 --> 00:03:49,091
進到這裡面來 就是說

66
00:03:49,091 --> 00:03:55,075
進到LAN2的那個port呢 一定是這個綠色的

67
00:03:55,075 --> 00:03:57,071
他的所謂的D port

68
00:03:57,071 --> 00:04:02,055
所謂的代理的port 就是進到這個LAN的呢

69
00:04:02,055 --> 00:04:06,038
一定都是要經過他的意思 才叫做代理的意思

70
00:04:06,038 --> 00:04:08,025
我們再來看一個 另外一個例子

71
00:04:08,025 --> 00:04:10,065
譬如說 假設我們從LAN5

72
00:04:10,065 --> 00:04:13,098
有一個封包 要丟到LAN2

73
00:04:13,098 --> 00:04:16,058
那我們還是要走這一條路

74
00:04:16,058 --> 00:04:20,011
因為我們一旦變成一個spanning tree之後呢

75
00:04:20,011 --> 00:04:23,075
他的特色就是說 他只有唯一的路了

76
00:04:23,075 --> 00:04:26,045
變這樣子 一樣 就是說

77
00:04:26,045 --> 00:04:29,018
可能會走比較遠 可是呢

78
00:04:29,018 --> 00:04:33,015
這是唯一的路徑 就是tree本身就是唯一的路徑

79
00:04:33,015 --> 00:04:36,058
所以我一旦把這個spanning tree找出來之後呢

80
00:04:36,058 --> 00:04:39,018
其實我們的routing就決定了

81
00:04:39,018 --> 00:04:41,018
就是說你要送到哪個地方去

82
00:04:41,018 --> 00:04:43,048
就是沿著這個spanning tree來

83
00:04:43,048 --> 00:04:45,095
做這個routing的路徑就可以了

84
00:04:45,095 --> 00:04:51,051
所以我們再看一次 如果剛才把這兩個port呢

85
00:04:51,051 --> 00:04:56,005
把它變成所謂的block port

86
00:04:56,005 --> 00:04:58,041
相當於我們把這兩個link把它切掉了

87
00:04:58,041 --> 00:05:01,091
那切掉之後呢 我們只要把這個root bridge呢

88
00:05:01,091 --> 00:05:04,038
這個 我們把他提到最上面去

89
00:05:04,038 --> 00:05:07,008
因為我們已經沒有迴路了

90
00:05:07,008 --> 00:05:10,085
把這個root提到最上面去 我們把他這樣一樣 抖一抖

91
00:05:10,085 --> 00:05:13,058
抖一抖的結果呢 就是下面這個

92
00:05:13,058 --> 00:05:17,058
我們再看一下 這個整個spanning tree就長個樣子了

93
00:05:17,058 --> 00:05:21,035
最上面 這個地方就是我們的root bridge

94
00:05:21,035 --> 00:05:23,085
跟剛才那個是一樣的

95
00:05:23,085 --> 00:05:28,028
那你就注意到 其他的五個bridge呢

96
00:05:28,028 --> 00:05:31,031
都有一個root port 就像這個地方

97
00:05:31,031 --> 00:05:33,068
這就是到這裡最短的路了

98
00:05:33,068 --> 00:05:35,078
這些都是最短的路 這樣子

99
00:05:35,078 --> 00:05:38,088
這對每一個LAN就是這樣子出去了

100
00:05:38,088 --> 00:05:40,075
每一個LAN就這樣子出去了

101
00:05:40,075 --> 00:05:43,008
所以這樣就是我們的一個spanning tree啦

102
00:05:43,008 --> 00:05:45,091
我們的spanning tree就找出來了

103
00:05:45,091 --> 00:05:50,018
好 那我們如果再來看他真正的步驟是什麼呢

104
00:05:50,018 --> 00:05:53,081
底下我們就來看 其實這個spanning tree algorithm呢

105
00:05:53,081 --> 00:05:56,081
分為三個步驟 那我們特別特別注意到

106
00:05:56,081 --> 00:06:00,005
這個演算法是一個分散式的演算法

107
00:06:00,005 --> 00:06:03,068
就是說這個bridge本身 他不知道其他的bridge到底

108
00:06:03,068 --> 00:06:08,071
有多少個 怎麼連接 id是多少 一開始他都不知道

109
00:06:08,071 --> 00:06:11,085
一個bridge本身 他就只知道自己

110
00:06:11,085 --> 00:06:17,001
那在這種環境之下 每一個bridge都只知道自己的條件之下

111
00:06:17,001 --> 00:06:22,011
我們要找到 到底哪一個bridge的id是最小的

112
00:06:22,011 --> 00:06:24,088
所以我們說 這個三個步驟呢

113
00:06:24,088 --> 00:06:29,081
第一個步驟 我們先決定到底誰是root bridge

114
00:06:29,081 --> 00:06:32,095
第一個 root bridge一定要先找出來

115
00:06:32,095 --> 00:06:36,095
那找出來之後呢 接下來就是針對每一個其他的bridge

116
00:06:36,095 --> 00:06:40,065
root先找出來 那每一個bridge就開始講說

117
00:06:40,065 --> 00:06:43,051
root已經找到了 譬如說是某一個bridge

118
00:06:43,051 --> 00:06:47,075
然後他就找自己到這個root裡面 很多路嘛

119
00:06:47,075 --> 00:06:50,051
可能走左邊可能走右邊可能走中間

120
00:06:50,051 --> 00:06:53,075
都沒有關係 反正cost最短的那個

121
00:06:53,075 --> 00:06:57,038
啊那個port呢 就叫做root port  剛剛提到 就是說

122
00:06:57,038 --> 00:07:02,031
第一個 我們先決定 到底哪一個bridge呢是root bridge

123
00:07:02,031 --> 00:07:07,065
第二個 針對其他的bridge呢 找到他的root port

124
00:07:07,065 --> 00:07:09,061
注意到 root port

125
00:07:09,061 --> 00:07:15,071
那第三個呢 就針對每一個LAN 我們講針對每一個LAN呢

126
00:07:15,071 --> 00:07:20,055
找到他的所謂的designated port 每一個LAN

127
00:07:20,055 --> 00:07:23,051
所以我們這個整個步驟呢 再講一次

128
00:07:23,051 --> 00:07:27,095
第一個 我們先找到誰是root bridge

129
00:07:27,095 --> 00:07:32,058
然後第二個 針對其他的bridge找到他的root port

130
00:07:32,058 --> 00:07:37,065
第三個 針對每一個LAN 找到他的所謂的designated port

131
00:07:37,065 --> 00:07:41,005
所謂的D port 只要這三個步驟呢都找到呢

132
00:07:41,005 --> 00:07:44,011
我們的spanning tree就造出來了

133
00:07:44,011 --> 00:07:47,028
這個就是步驟非常非常簡單 我們等下再來看例子

134
00:07:47,028 --> 00:07:50,021
好 其中 我們注意一下就是說

135
00:07:50,021 --> 00:07:55,031
所謂的針對每一個LAN 應該我們剛剛有提到

136
00:07:55,031 --> 00:07:58,045
因為LAN本身是比較特別 因為LAN本身是一個

137
00:07:58,045 --> 00:08:03,011
沒有計算能力的這種所謂的被動式的設備嘛

138
00:08:03,011 --> 00:08:06,098
所以針對每一個LAN來講 他沒有辦法自己去算那個cost

139
00:08:06,098 --> 00:08:11,028
所以只好 我們要找一個代理他的bridge來幫他做這件事情

140
00:08:11,028 --> 00:08:14,085
好 那我們說針對每一個LAN呢

141
00:08:14,085 --> 00:08:18,021
我們要找到所謂的designated port嘛

142
00:08:18,021 --> 00:08:20,098
就所謂的D port 那這個port是什麼意思

143
00:08:20,098 --> 00:08:25,045
因為剛提到 一個LAN本身可能有接好幾個bridge

144
00:08:25,045 --> 00:08:27,038
那走這邊 走這邊或走這邊

145
00:08:27,038 --> 00:08:32,008
我們說 哪一個port呢 就這個port

146
00:08:32,008 --> 00:08:35,005
他有minimum root path cost

147
00:08:35,005 --> 00:08:39,058
就經由這個port呢到root 剛剛我們一再強調

148
00:08:39,058 --> 00:08:43,065
這個整個演算法呢 第一件事都是先把root找出來

149
00:08:43,065 --> 00:08:45,085
就是我們一定先有一個目標啦

150
00:08:45,085 --> 00:08:48,025
先把root找出來 所以我們就開始找

151
00:08:48,025 --> 00:08:53,005
那我到root的路徑好幾個嘛 那哪一個是最小的

152
00:08:53,005 --> 00:08:54,061
哪一個是最小的

153
00:08:54,061 --> 00:08:57,018
所以我們講那個port找出來

154
00:08:57,018 --> 00:09:02,071
那如果說 有好幾個bridge接在這個LAN上

155
00:09:02,071 --> 00:09:05,078
那我們當然就要找這個嘛 如果你還是一樣

156
00:09:05,078 --> 00:09:09,001
譬如說我兩條路都可以走啊 啊cost是一樣

157
00:09:09,001 --> 00:09:11,051
剛我們也看到這個case 就是說

158
00:09:11,051 --> 00:09:13,051
走這個bridge跟走這個bridge呢

159
00:09:13,051 --> 00:09:15,051
他的cost都一樣 都是最小

160
00:09:15,051 --> 00:09:18,051
那我們到底挑哪一個 我們很簡單

161
00:09:18,051 --> 00:09:21,045
我們就挑那個bridge id比較小的

162
00:09:21,045 --> 00:09:24,031
id比較小 因為每一個bridge都有一個id嘛

163
00:09:24,031 --> 00:09:27,048
那也有可能說 一個bridge呢

164
00:09:27,048 --> 00:09:30,041
有兩個port 接在這個LAN上

165
00:09:30,041 --> 00:09:33,025
一個LAN可能幾好幾個bridge

166
00:09:33,025 --> 00:09:36,045
可是每一個bridge呢 說不定有兩個port接進來

167
00:09:36,045 --> 00:09:38,045
接到這個LAN 兩個port

168
00:09:38,045 --> 00:09:41,015
那兩個port的話 走這邊走這邊都一樣小

169
00:09:41,015 --> 00:09:42,091
因為都是同樣這個bridge嘛

170
00:09:42,091 --> 00:09:45,091
那我們就找那個port id呢 比較小的

171
00:09:45,091 --> 00:09:49,061
就是說 如果有兩個bridge呢cost一樣

172
00:09:49,061 --> 00:09:52,071
我們找bridge的id比較小的

173
00:09:52,071 --> 00:09:55,035
那如果針對某一個bridge他有兩個port

174
00:09:55,035 --> 00:09:58,058
那我們就找那個port id比較小的

175
00:09:58,058 --> 00:09:59,098
我們都是挑比較小的

176
00:09:59,098 --> 00:10:04,038
這樣就可以找到比較算是唯一的 所謂的D port

177
00:10:04,038 --> 00:10:06,038
這個就是他的過程

178
00:10:06,038 --> 00:10:11,035
所以在這個spanning tree演算法在跑的過程當中呢

179
00:10:11,035 --> 00:10:13,048
我們就可以看一個滿重要的

180
00:10:13,048 --> 00:10:15,048
這個所謂的state machine的diagram

181
00:10:15,048 --> 00:10:19,011
就是每一個port 我們剛剛提到

182
00:10:19,011 --> 00:10:21,078
在這個演算法裡面呢 每一個port

183
00:10:21,078 --> 00:10:24,068
每一個bridge port呢 他一定要扮演一個角色

184
00:10:24,068 --> 00:10:27,065
如果他是被選成所謂的root port

185
00:10:27,065 --> 00:10:31,071
或者被選成D port 都是很好的角色

186
00:10:31,071 --> 00:10:34,021
因為這個都是spanning tree的一部分

187
00:10:34,021 --> 00:10:38,088
那如果他也不是所謂的root port 也不是D port

188
00:10:38,088 --> 00:10:42,058
那他就是block 他就是變成他那個port

189
00:10:42,058 --> 00:10:46,061
就要 等於是要把那個link暫時給他剪斷掉一樣

190
00:10:46,061 --> 00:10:49,031
所以只有這個 角色只能挑一個

191
00:10:49,031 --> 00:10:51,025
那一開始的時候呢 我們就說

192
00:10:51,025 --> 00:10:53,081
任何一個port呢都在blocking state

193
00:10:53,081 --> 00:10:57,081
就是上面這個紅色的 initial呢是在這個地方

194
00:10:57,081 --> 00:11:00,058
我們叫做blocking 一開始就什麼都不動

195
00:11:00,058 --> 00:11:02,098
因為大家都還沒扮演角色確定嘛

196
00:11:02,098 --> 00:11:06,035
好 那一開始呢 這個port呢

197
00:11:06,035 --> 00:11:09,051
會不會被選成D port或R port

198
00:11:09,051 --> 00:11:12,041
我們講select 就是到底誰會來挑他

199
00:11:12,041 --> 00:11:16,018
把一個port的角色暫時從blocking port呢

200
00:11:16,018 --> 00:11:18,018
變成D port或R port呢

201
00:11:18,018 --> 00:11:21,031
這怎麼做呢 接下來我們就介紹這個觀念

202
00:11:21,031 --> 00:11:23,075
首先 我們剛剛有提到說

203
00:11:23,075 --> 00:11:26,048
這個演算法裡面他是一個分散式的演算法

204
00:11:26,048 --> 00:11:30,078
所以每一個bridge呢一開始呢只知道自己的id

205
00:11:30,078 --> 00:11:35,005
他也不知道別人的id 所以這個演算法一開始就很簡單

206
00:11:35,005 --> 00:11:40,068
就是每一個bridge呢都把自己 當成是一個root

207
00:11:40,068 --> 00:11:43,051
就想像說自己就是id最小的

208
00:11:43,051 --> 00:11:46,018
那如果你認為自己id是最小的

209
00:11:46,018 --> 00:11:48,091
你就開始 準備一個封包

210
00:11:48,091 --> 00:11:51,065
等下會介紹 叫做VPDU

211
00:11:51,065 --> 00:11:57,045
那這個封包本身會帶自己的id 送給其他的port

212
00:11:57,045 --> 00:12:00,011
就一開始呢 譬如說我們有兩個bridge

213
00:12:00,011 --> 00:12:02,045
那他有一個id 他有一個id

214
00:12:02,045 --> 00:12:05,098
假設他們有連起來 他就送一個封包給他嘛

215
00:12:05,098 --> 00:12:08,085
那這個封包裡面因為帶了他的id嘛

216
00:12:08,085 --> 00:12:14,018
所以如果左邊的id比較小 右邊的比較大

217
00:12:14,018 --> 00:12:17,081
他收到之後呢 他就因為這個封包裡面帶id

218
00:12:17,081 --> 00:12:21,048
他就發現說 我的id比你大

219
00:12:21,048 --> 00:12:26,028
那我們要找id小的啊 所以他就有點像被他征服了

220
00:12:26,028 --> 00:12:30,038
他就認為說 那我就承認這個id是比較小的

221
00:12:30,038 --> 00:12:32,048
所以你就可以想像說

222
00:12:32,048 --> 00:12:36,031
如果有一個bridge呢 他的id呢是這個網路裡面

223
00:12:36,031 --> 00:12:40,058
他是真正最小的 所以這個最小的這個id

224
00:12:40,058 --> 00:12:43,015
他的封包一往外送的時候呢

225
00:12:43,015 --> 00:12:46,021
旁邊最周邊的這個bridge就被他征服了嘛

226
00:12:46,021 --> 00:12:48,068
因為都看到這個id 他就說他是最小

227
00:12:48,068 --> 00:12:53,091
然後被征服的這個bridge本身呢 就要把這個id呢再轉出去

228
00:12:53,091 --> 00:12:57,018
再轉出去 再轉出去

229
00:12:57,018 --> 00:13:00,028
所以你可以想像成 這個網路上面

230
00:13:00,028 --> 00:13:03,011
剛一開機的時候呢 大家都在送這個封包

231
00:13:03,011 --> 00:13:06,025
一開始都自己認為最小 自己最小

232
00:13:06,025 --> 00:13:09,035
可是他一旦接觸到一個真的比他小的時候呢

233
00:13:09,035 --> 00:13:11,078
他就馬上轉向 因為他已經被他征服了

234
00:13:11,078 --> 00:13:14,078
他就開始轉向封包 本來往這邊送的

235
00:13:14,078 --> 00:13:17,095
結果來一個更小的 我們講id更小的

236
00:13:17,095 --> 00:13:22,035
那他就開始轉送 等於說我一旦被征服之後呢

237
00:13:22,035 --> 00:13:29,008
我就要代替 或者說我就要替這個新的這個所謂的root

238
00:13:29,008 --> 00:13:32,038
幫他去 再轉送這個更小的

239
00:13:32,038 --> 00:13:36,035
所以你可以想像是說 有一個場景就是說

240
00:13:36,035 --> 00:13:42,015
假設左邊這個地方是最小的 右邊他是第二小

241
00:13:42,015 --> 00:13:44,008
阿網路中間有很多bridge

242
00:13:44,008 --> 00:13:46,055
所以最小的這個他開始送的時候

243
00:13:46,055 --> 00:13:50,051
他開始征服這一邊 那因為右邊是第二小

244
00:13:50,051 --> 00:13:54,055
第二小也是很小 所以第二小本身他開始征服一堆嘛

245
00:13:54,055 --> 00:13:58,011
所以他的BPD就開始降 開始開始開始 瘦到這樣

246
00:13:58,011 --> 00:14:00,081
可是一旦碰在一起的時候

247
00:14:00,081 --> 00:14:04,038
他就開始過來 開始過來 開始過來

248
00:14:04,038 --> 00:14:07,048
所以最後最後一定是那個最小的

249
00:14:07,048 --> 00:14:11,068
他的封包才可以一圈一圈的

250
00:14:11,068 --> 00:14:17,008
就是第一圈 第二圈 第三圈這樣子擴散出去

251
00:14:17,008 --> 00:14:21,008
就是說真正的id最小的那個bridge

252
00:14:21,008 --> 00:14:25,065
他的id 才是真正的最小的

253
00:14:25,065 --> 00:14:30,011
那他的封包才有機會送到每個角落上面去

254
00:14:30,011 --> 00:14:33,035
所以大家就知道說 誰是最小的意思啦

255
00:14:33,035 --> 00:14:37,061
就是說我們現在在介紹就是說 一個分散式的演算法

256
00:14:37,061 --> 00:14:40,088
可以找到誰是最小的意思

257
00:14:40,088 --> 00:14:44,015
那你如果不是最小的 一開始你可能認為是最小的

258
00:14:44,015 --> 00:14:47,005
可是你也可能會有一陣子 我還是最小最小最小

259
00:14:47,005 --> 00:14:50,051
可是你的封包一旦被這個真正的最小的一碰到

260
00:14:50,051 --> 00:14:54,078
就開始倒回來了嘛 就等於說有點像那個浪潮

261
00:14:54,078 --> 00:14:57,078
你現在先打過來 等下我碰到他 他就把他壓過去了

262
00:14:57,078 --> 00:15:03,025
所以只有真正的id最小的bridge

263
00:15:03,025 --> 00:15:07,001
他的封包呢可以擴散出去 不過這個過程當中

264
00:15:07,001 --> 00:15:09,038
就是說 任何一個bridge

265
00:15:09,038 --> 00:15:13,061
因為他還沒有看到真正最小的封包流進來之前

266
00:15:13,061 --> 00:15:15,095
他會認為自己是最小的嘛

267
00:15:15,095 --> 00:15:17,065
如果認為自己是最小

268
00:15:17,065 --> 00:15:20,051
他就開始送出去 封包往外送

269
00:15:20,051 --> 00:15:23,028
那我們就是說 一個port

270
00:15:23,028 --> 00:15:27,091
如果你認為自己是最小的 那一開始丟出去的時候呢

271
00:15:27,091 --> 00:15:29,071
這個port都是D port

272
00:15:29,071 --> 00:15:33,035
D port 就是說如果你一開始認為自己是最小嘛

273
00:15:33,035 --> 00:15:36,048
所以這個bridge本身會連了很多的LAN

274
00:15:36,048 --> 00:15:40,078
連了很多的網路 那一開始都把自己這個當作D port

275
00:15:40,078 --> 00:15:42,015
然後送進去啦

276
00:15:42,015 --> 00:15:44,061
好那我們剛剛提到 很關鍵就是說

277
00:15:44,061 --> 00:15:47,068
如果一開始呢 他這樣送出來

278
00:15:47,068 --> 00:15:49,051
他認為這個port是D port

279
00:15:49,051 --> 00:15:52,055
那這個是 真正的最小在左邊啦

280
00:15:52,055 --> 00:15:56,021
啊他送過來 他就被征服了 從這個地方被征服了

281
00:15:56,021 --> 00:16:00,018
好那這個port 就要暫時變成R port了

282
00:16:00,018 --> 00:16:02,088
因為他認為從這個port會到這個最小嘛

283
00:16:02,088 --> 00:16:06,011
這個是真正的root 所以從這個port過來的話

284
00:16:06,011 --> 00:16:08,098
這個port就是所謂的R port ok

285
00:16:08,098 --> 00:16:11,051
所以也就是說 一開始呢

286
00:16:11,051 --> 00:16:13,091
每一個port一開始都是blocking

287
00:16:13,091 --> 00:16:17,028
但是因為這個角色的這個過程

288
00:16:17,028 --> 00:16:20,085
就是這個在交換情報的過程當中

289
00:16:20,085 --> 00:16:25,048
一個port呢 可能就會被選成所謂的D port或者R port

290
00:16:25,048 --> 00:16:28,098
就是說 一個port可能會被選成D port或R port

291
00:16:28,098 --> 00:16:32,045
但是一旦他被選擇成D port跟R port的時候呢

292
00:16:32,045 --> 00:16:35,051
什麼時候會被 我們叫做所謂的cancel呢

293
00:16:35,051 --> 00:16:39,005
被取消掉 就是因為剛開始 譬如剛剛提到 我們右邊這個

294
00:16:39,005 --> 00:16:41,098
他一開始送這個port的時候 他認為他是D port

295
00:16:41,098 --> 00:16:44,048
可是他馬上被征服之後呢 他就變成R port了

296
00:16:44,048 --> 00:16:48,068
好 那等下可能又有個更好的封包從另外一個地方進來

297
00:16:48,068 --> 00:16:51,028
假設又更短的封包 再從別的port進來

298
00:16:51,028 --> 00:16:54,075
那這個port就被取消了嘛 因為我們剛剛提到

299
00:16:54,075 --> 00:16:58,078
每一個bridge呢 都要找一個R port

300
00:16:58,078 --> 00:17:01,025
也就是一個bridge呢只有一個R port

301
00:17:01,025 --> 00:17:03,088
每一個bridge只有一個R port

302
00:17:03,088 --> 00:17:06,045
所以一開始從這個最短的封包從這邊進來

303
00:17:06,045 --> 00:17:07,098
他可能認為這個是R port

304
00:17:07,098 --> 00:17:10,075
等下可能還有另外一個封包從這個地方進來

305
00:17:10,075 --> 00:17:12,048
那個R port就要換到這裡來

306
00:17:12,048 --> 00:17:15,028
就是如果說 所謂的R port就是

307
00:17:15,028 --> 00:17:18,071
到那個root bridge呢最短的路的那個port嘛

308
00:17:18,071 --> 00:17:20,031
最短的路的port

309
00:17:20,031 --> 00:17:22,091
所以有可能一開始進來的時候呢 可能不是最短的

310
00:17:22,091 --> 00:17:26,078
那最短的從這邊才進來 所以一開始這個地方是R port

311
00:17:26,078 --> 00:17:29,055
可是等一下子呢 可能R port要換到這裡來

312
00:17:29,055 --> 00:17:31,005
那這個port就會被取消

313
00:17:31,005 --> 00:17:34,078
所以我們在這個所謂的port state的diagram裡面呢

314
00:17:34,078 --> 00:17:39,088
我們說 一個port他可能被選成一個D port或者一個R port

315
00:17:39,088 --> 00:17:44,025
可是呢 可能過一陣子呢他會被取消掉

316
00:17:44,025 --> 00:17:47,025
因為有更好的port呢又被找到的意思

317
00:17:47,025 --> 00:17:54,068
如果說 經過15秒呢 沒有這個port呢的角色呢沒有被變更

318
00:17:54,068 --> 00:17:59,048
我們就說 他就進到所謂的這個 叫listening state

319
00:17:59,048 --> 00:18:01,095
對不起 叫進到所謂的learning state

320
00:18:01,095 --> 00:18:05,051
那如果你可以進到learning state 就代表說

321
00:18:05,051 --> 00:18:09,021
你這個port 已經可以開始做address learning

322
00:18:09,021 --> 00:18:10,091
因為我們之前有提到

323
00:18:10,091 --> 00:18:14,011
bridge本身要做address learning的工作嘛

324
00:18:14,011 --> 00:18:17,095
也就是說一個port 從這個blocking開始 從blocking

325
00:18:17,095 --> 00:18:22,035
那如果他被選成一個R port或一個D port呢

326
00:18:22,035 --> 00:18:25,001
我們就進到所謂的listening state

327
00:18:25,001 --> 00:18:28,095
那經過一個所謂的我們叫做 forwarding delay

328
00:18:28,095 --> 00:18:31,071
forwarding delay呢事實上是這樣子定義的

329
00:18:31,071 --> 00:18:34,015
就是根據我們的網路的大小

330
00:18:34,015 --> 00:18:38,008
剛提到 譬如說我最小的是在最左邊

331
00:18:38,008 --> 00:18:42,061
第二小的在最右邊 那對於第二小的來講

332
00:18:42,061 --> 00:18:45,081
他的封包可能一開始這樣子征服過去

333
00:18:45,081 --> 00:18:49,078
那一直碰到他 真的最小的 封包才會被蓋過來

334
00:18:49,078 --> 00:18:54,078
也就是說事實上 他所需要最最多的時間就是

335
00:18:54,078 --> 00:19:00,011
一個來去 就是一個round trip 就可以底定

336
00:19:00,011 --> 00:19:02,065
就大勢就底定了 那這是因為說

337
00:19:02,065 --> 00:19:06,045
假設我們這個第二小的先開機

338
00:19:06,045 --> 00:19:08,071
他的封包就開始送過來了

339
00:19:08,071 --> 00:19:11,051
開始征服這邊一大片了 他第二小嘛

340
00:19:11,051 --> 00:19:15,025
那最後這個真的最小一起來 他又再把它蓋過去了嘛

341
00:19:15,025 --> 00:19:17,075
那這樣等於說 一來一回

342
00:19:17,075 --> 00:19:20,051
大概就需要 這個叫做forwarding delay

343
00:19:20,051 --> 00:19:24,035
那在標準裡面就把它訂為大概是15秒

344
00:19:24,035 --> 00:19:27,021
那來回兩趟 就所謂的30秒

345
00:19:27,021 --> 00:19:29,088
這邊就是要兩個forwarding delay的意思是這樣

346
00:19:29,088 --> 00:19:33,035
就是說一開始呢 這個port呢是在blocking

347
00:19:33,035 --> 00:19:36,048
當他被選成一個R port或一個D port的時候呢

348
00:19:36,048 --> 00:19:38,025
他進到所謂的listening

349
00:19:38,025 --> 00:19:40,018
經過一個forwarding delay

350
00:19:40,018 --> 00:19:44,088
經過一個所謂的diameter 一個直徑的時間呢

351
00:19:44,088 --> 00:19:50,038
這個port的角色沒有變更 他就進到這個所謂的learning state

352
00:19:50,038 --> 00:19:54,051
那進到learning呢 他就可以開始做address learning了

353
00:19:54,051 --> 00:19:56,098
但是呢還不可以做forwarding

354
00:19:56,098 --> 00:19:59,065
那也有可能再經過一個forwarding delay

355
00:19:59,065 --> 00:20:02,058
就進到這個forwarding 這個是最重要的

356
00:20:02,058 --> 00:20:07,008
一旦進到forwarding 就是說這個spanning tree已經建完了

357
00:20:07,008 --> 00:20:11,015
對他來講 他就可以開始做封包的forwarding

358
00:20:11,015 --> 00:20:15,098
所以我們等於說 如果有這個 所謂的state diagram的話

359
00:20:15,098 --> 00:20:20,068
我們就可以看 每一個port 他到底在扮演什麼角色

360
00:20:20,068 --> 00:20:25,021
就是說 一開始是blocking 那可能一下他會變成R port

361
00:20:25,021 --> 00:20:30,015
一下他會變成D port 那變成R port 或D port呢

362
00:20:30,015 --> 00:20:32,098
可能一下又會變掉 那最後最後就是

363
00:20:32,098 --> 00:20:36,011
我們可以看一下 這個簡單的講

364
00:20:36,011 --> 00:20:38,035
就是一個port可能會這樣子

365
00:20:38,035 --> 00:20:42,005
可能又被拉回去 等下可能又進來

366
00:20:42,005 --> 00:20:44,085
可能變到這邊 可能又被拉回去

367
00:20:44,085 --> 00:20:48,051
這樣這樣這樣 沒關係 這個port可以換 最後換到這裡來

368
00:20:48,051 --> 00:20:51,041
一旦換到這個forwarding state

369
00:20:51,041 --> 00:20:54,061
他就是在spanning tree的那個port了

370
00:20:54,061 --> 00:20:58,035
好 那forwarding裡面就是 他可能是一個D port

371
00:20:58,035 --> 00:20:59,095
或可能是一個R port

372
00:20:59,095 --> 00:21:01,021
that’s fine 都ok

373
00:21:01,021 --> 00:21:02,091
都是叫forwarding port

374
00:21:02,091 --> 00:21:06,008
R port或D port 那不是在R port或D port的

375
00:21:06,008 --> 00:21:08,055
最後他就會在這個blocking port

376
00:21:08,055 --> 00:21:10,031
就是在這個blocking state

377
00:21:10,031 --> 00:21:14,038
那每一個port都是這樣子

378
00:21:14,038 --> 00:21:17,011
那等到這個經過我們講 兩個

379
00:21:17,011 --> 00:21:20,038
最重要的是這個地方 兩個forwarding delay呢

380
00:21:20,038 --> 00:21:22,035
他就大勢底定了 就是說

381
00:21:22,035 --> 00:21:25,011
這個一開始我們很多bridge嘛 連起來

382
00:21:25,011 --> 00:21:27,075
然後打開 電源一打開

383
00:21:27,075 --> 00:21:31,008
他們就開始找最小的 就交換交換交換

384
00:21:31,008 --> 00:21:33,061
然後每個port就開始變化變化變化

385
00:21:33,061 --> 00:21:36,031
最後經過30秒之後 就定下來了

386
00:21:36,031 --> 00:21:40,075
就是每一個port就決定了 他是R port, D port還是block

387
00:21:40,075 --> 00:21:43,001
那spanning tree就造出來了

388
00:21:43,001 --> 00:21:45,001


