1
00:00:08,061 --> 00:00:12,098
好 那我來再來看看說 前面我們有介紹說

2
00:00:12,098 --> 00:00:16,041
如果你一次傳送的時候呢

3
00:00:16,041 --> 00:00:19,025
是有分好幾個所謂的fragmentation

4
00:00:19,025 --> 00:00:25,015
就是你送的封包 不是送一個 而是送一連串的

5
00:00:25,015 --> 00:00:27,071
我們叫做fragmentation 剛提到

6
00:00:27,071 --> 00:00:29,098
像fragment1 ACK1

7
00:00:29,098 --> 00:00:33,018
fragment2 ACK2 fragment3 ACK3

8
00:00:33,018 --> 00:00:36,061
那 可是你在這個傳輸的過程當中

9
00:00:36,061 --> 00:00:40,051
你一開始不是會有一個request to send, clear to send

10
00:00:40,051 --> 00:00:45,018
就是宣告周邊的人 告訴周邊的人 說你等一下要用多久

11
00:00:45,018 --> 00:00:50,031
可是我們的這個RTS跟CTS本身

12
00:00:50,031 --> 00:00:56,065
只宣告下一個封包跟ACK

13
00:00:56,065 --> 00:00:59,028
可是你這個結束之後你還有下一個fragment啊

14
00:00:59,028 --> 00:01:02,058
因為我們好幾個fragment嘛 所以我們就變成說

15
00:01:02,058 --> 00:01:07,081
我不可能為了每一個fragment 都去送這個RTS跟CTS啊

16
00:01:07,081 --> 00:01:11,088
就是RTS CTS本來的目的我們之前說過

17
00:01:11,088 --> 00:01:14,091
是因為你的封包可能是很長啦 比較長

18
00:01:14,091 --> 00:01:18,075
這麼長的封包如果沒有一個保護的話 就把他丟出去

19
00:01:18,075 --> 00:01:22,015
發生collision的機會很大 那就很浪費

20
00:01:22,015 --> 00:01:25,021
所以我們用RTS CTS呢 先做一個預約

21
00:01:25,021 --> 00:01:28,048
那你預約的結果 結果你送的是一個fragment

22
00:01:28,048 --> 00:01:31,035
我們講fragment是比較 通常比較小的片段

23
00:01:31,035 --> 00:01:34,051
那因此呢我們就讓說

24
00:01:34,051 --> 00:01:38,091
那後續的fragment我要當data跟ACK

25
00:01:38,091 --> 00:01:43,011
就把它當成下一輪的

26
00:01:43,011 --> 00:01:46,095
這種所謂的RTS跟CTS的意思 就是說

27
00:01:46,095 --> 00:01:48,048
我們等下會用例子來看

28
00:01:48,048 --> 00:01:51,098
就是如果我們送的是有好幾個fragment的話

29
00:01:51,098 --> 00:01:56,075
那後面到底要預約多少時間

30
00:01:56,075 --> 00:01:59,058
就是前面的data呢跟ACK呢

31
00:01:59,058 --> 00:02:05,048
同時就扮演下一個fragment的RTS跟CTS的意思

32
00:02:05,048 --> 00:02:08,021
那最後一個 last fragment

33
00:02:08,021 --> 00:02:11,025
最後一個fragment 跟最後一個ACK的話

34
00:02:11,025 --> 00:02:13,095
那這個duration呢 就把它設為0啦

35
00:02:13,095 --> 00:02:16,028
因為他們是最後一個 後面就不需要

36
00:02:16,028 --> 00:02:21,018
我們來看一個例子 在這個例子裡面我們一樣 假設呢

37
00:02:21,018 --> 00:02:25,091
我們是由一個source呢 要送給這個destination

38
00:02:25,091 --> 00:02:29,045
那我們注意到這邊 所謂的others

39
00:02:29,045 --> 00:02:31,045
就是我有其他的node

40
00:02:31,045 --> 00:02:35,021
那我要聽聽看這個source跟destination

41
00:02:35,021 --> 00:02:37,051
他們在溝通的過程當中

42
00:02:37,051 --> 00:02:41,018
我因為他們會送好幾個封包嘛

43
00:02:41,018 --> 00:02:42,071
好幾個fragment

44
00:02:42,071 --> 00:02:45,065
所以這些fragment都會帶著duration

45
00:02:45,065 --> 00:02:47,065
阿這個duration就是下一個

46
00:02:47,065 --> 00:02:50,098
下一個fragment跟下一個ACK的這個時間

47
00:02:50,098 --> 00:02:54,098
那他就會一直累積這個所謂剛剛提到 這個NAV

48
00:02:54,098 --> 00:02:57,035
network allocation vector的值

49
00:02:57,035 --> 00:02:59,095
他就會累積 我們先看第一個

50
00:02:59,095 --> 00:03:04,068
首先 在送之前 我們講source呢送一個RTS

51
00:03:04,068 --> 00:03:07,051
那我們知道RTS裡面會帶一個duration啊

52
00:03:07,051 --> 00:03:10,058
這個duration就是下一個封包加ACK的時間

53
00:03:10,058 --> 00:03:14,008
所以我們注意到 他的時間在這裡

54
00:03:14,008 --> 00:03:18,095
就是下一個封包加ACK的時間 因為我們封包多長

55
00:03:18,095 --> 00:03:22,061
自己送的人知道 ACK的長度呢是固定長度

56
00:03:22,061 --> 00:03:25,075
所以封包加ACK的時間呢是知道的

57
00:03:25,075 --> 00:03:27,048
所以就放在RTS裡面

58
00:03:27,048 --> 00:03:30,098
他就廣播出去 所以聽到這個RTS的呢

59
00:03:30,098 --> 00:03:33,035
就上面這個 這個所謂的紫色的

60
00:03:33,035 --> 00:03:37,085
他們就會把他們時間保留到這個時間通通都是busy

61
00:03:37,085 --> 00:03:42,011
好 然後接下來就會回到一個clear to send 就是說

62
00:03:42,011 --> 00:03:44,068
這個destination回一個clear to send

63
00:03:44,068 --> 00:03:47,028
那聽到clear to send的人

64
00:03:47,028 --> 00:03:49,068
因為clear to send裡面也帶一個duration

65
00:03:49,068 --> 00:03:52,085
這個duration也是到這個ACK 第一個ACK結束

66
00:03:52,085 --> 00:03:55,031
所以等於說 這個時候

67
00:03:55,031 --> 00:03:58,038
聽到這個clear to send的node呢

68
00:03:58,038 --> 00:04:01,035
他們的時間也是一樣 定到這裡來

69
00:04:01,035 --> 00:04:06,095
所以這個是 RTS跟CTS呢 各自預留了一個時間

70
00:04:06,095 --> 00:04:08,055
時間點就到這個時間點

71
00:04:08,055 --> 00:04:12,008
等下呢 就開始送封包 fragment1

72
00:04:12,008 --> 00:04:14,045
那注意到 這個fragment1

73
00:04:14,045 --> 00:04:17,078
現在要特別說明的就是這個fragment1本身

74
00:04:17,078 --> 00:04:22,021
他裡面也帶一個duration 他也帶一個duration

75
00:04:22,021 --> 00:04:24,051
這個duration呢 就到這裡

76
00:04:24,051 --> 00:04:27,008
特別注意到 這個fragment1裡面帶了duration

77
00:04:27,008 --> 00:04:32,098
duration就是下一個fragment 到跟下一個ACK

78
00:04:32,098 --> 00:04:35,095
ACK2就在這個地方 下一個fragment就在這裡

79
00:04:35,095 --> 00:04:40,068
那ACK在這個地方嘛 所以ACK2在這個地方結束

80
00:04:40,068 --> 00:04:43,001
所以他就帶這個時間軸

81
00:04:43,001 --> 00:04:46,011
好 一樣 當我回一個這個ACK的時候呢

82
00:04:46,011 --> 00:04:50,051
這個ACK也是一樣 這個ACK本身他也會帶一個

83
00:04:50,051 --> 00:04:54,085
這個時間軸到這個地方來 所以聽到這個ACK的人

84
00:04:54,085 --> 00:05:00,068
他的這個所謂的network allocation vector 就到這裡來

85
00:05:00,068 --> 00:05:02,055
再看一下 他會這樣子

86
00:05:02,055 --> 00:05:05,081
好 那接下來就會繼續可以送

87
00:05:05,081 --> 00:05:09,015
因為對我們剛提到 對其他的node來講

88
00:05:09,015 --> 00:05:11,071
這些其他node 那他們就

89
00:05:11,071 --> 00:05:14,025
本來的vector大概是到這裡嘛

90
00:05:14,025 --> 00:05:16,025
現在又被延長 一樣

91
00:05:16,025 --> 00:05:18,035
聽到clear to send的本來是到這裡

92
00:05:18,035 --> 00:05:20,071
現在因為看到ACK又被延長

93
00:05:20,071 --> 00:05:23,071
接下來再一個封包 fragment2

94
00:05:23,071 --> 00:05:27,008
那fragment2出來的時候呢 他又帶另外一個duration

95
00:05:27,008 --> 00:05:30,001
這個duration就是下一個

96
00:05:30,001 --> 00:05:33,071
來回 下一輪的 就到這裡來 到這裡來

97
00:05:33,071 --> 00:05:35,058
變成他就要放這個地方

98
00:05:35,058 --> 00:05:38,031
所以這個fragment 2他就帶一個duration到這裡

99
00:05:38,031 --> 00:05:40,031
那接下來回ACK

100
00:05:40,031 --> 00:05:43,065
那ACK本身他帶一個duration呢到這裡

101
00:05:43,065 --> 00:05:45,081
等於說 這個時候已經是最後一個了

102
00:05:45,081 --> 00:05:50,008
所以這個時候再來的這個 這個地方

103
00:05:50,008 --> 00:05:52,028
這個fragment因為他已經是最後一個fragment

104
00:05:52,028 --> 00:05:57,061
我們說 他的duration呢 就是等於0啦

105
00:05:57,061 --> 00:06:00,018
就不用帶 這個ACK也不用帶

106
00:06:00,018 --> 00:06:02,095
等到送完的時候 就結束了

107
00:06:02,095 --> 00:06:06,051
所以從這個過程當中我們如果來簡單看一下

108
00:06:06,051 --> 00:06:11,031
就是說 對於source送給destination呢

109
00:06:11,031 --> 00:06:14,035
這個是比較容易了解 那我們看

110
00:06:14,035 --> 00:06:17,028
對其他的station來講的話 就這個地方

111
00:06:17,028 --> 00:06:21,045
其他station本身他到底怎麼來看待這件事情呢

112
00:06:21,045 --> 00:06:24,048
我們說 對於其他的station 在這裏

113
00:06:24,048 --> 00:06:28,061
他一開始呢聽到 譬如說RTS到這裡

114
00:06:28,061 --> 00:06:31,058
等下又聽到fragment1裡面又帶一個時間

115
00:06:31,058 --> 00:06:35,051
一聽到fragment又帶這個時間 所以他在這個時間裡面

116
00:06:35,051 --> 00:06:39,098
通通都是busy 那對於聽到clear to send 一樣

117
00:06:39,098 --> 00:06:43,028
他這個時間裡面 就變成通通都是busy

118
00:06:44,035 --> 00:06:46,065
就看你是聽的到clear to send

119
00:06:46,065 --> 00:06:48,008
還是聽得到request to send

120
00:06:48,008 --> 00:06:50,025
就聽到不同的 反正這個時間裡面

121
00:06:50,025 --> 00:06:54,001
source跟destination他會送好幾個fragment

122
00:06:54,001 --> 00:06:56,018
fragment1, ACK, fragment2, ACK, fragment3, ACK

123
00:06:56,018 --> 00:06:58,055
那這個期間之內 通通都是busy

124
00:06:58,055 --> 00:07:03,018
事實上 他們都不一定真的聽得到那個資料在傳送

125
00:07:03,018 --> 00:07:04,081
因為聽得到clear to send的

126
00:07:04,081 --> 00:07:08,008
可能聽不到那個fragment真的在傳輸

127
00:07:08,008 --> 00:07:10,031
不過都把它變成busy 那一樣

128
00:07:10,031 --> 00:07:13,035
這個 等到這個時間都結束之後呢

129
00:07:13,035 --> 00:07:17,038
我們才這個 我們講 才能叫做idle

130
00:07:17,038 --> 00:07:20,075
那idle之後呢 一樣要聽一個這個時間

131
00:07:20,075 --> 00:07:23,021
要聽一個這段時間 聽完時間之後

132
00:07:23,021 --> 00:07:26,038
誒一樣 才可以再做一個random back-off的時間

133
00:07:26,038 --> 00:07:29,001
也就是說 這段期間之內

134
00:07:29,001 --> 00:07:33,025
我們講 都把它當成是busy的意思啦

135
00:07:33,025 --> 00:07:37,011
就是說我們雖然封包有送有回ACK

136
00:07:37,011 --> 00:07:39,071
可是呢 對於其他node來講的話

137
00:07:39,071 --> 00:07:45,015
這段期間 通通都把它當成是busy

138
00:07:45,015 --> 00:07:49,055
通通都是busy的 那等到這個時間點到了結束

139
00:07:49,055 --> 00:07:53,048
才叫做idle 那idle呢要等一個DIFS的時間

140
00:07:53,048 --> 00:07:55,021
等到這個時間之後

141
00:07:55,021 --> 00:07:56,088
還要產生一個random back-off

142
00:07:56,088 --> 00:07:59,081
因為在這個期間之內 我們講通通都是busy的

143
00:08:00,041 --> 00:08:02,088
好 那最後我們再來看就是說

144
00:08:02,088 --> 00:08:08,011
那一個RTS跟CTS本身 如果他本身剛提到

145
00:08:08,011 --> 00:08:11,021
每一個這個fragment跟每一個ACK呢

146
00:08:11,021 --> 00:08:18,008
他其實就扮演了一個virtual的CTS跟RTS

147
00:08:18,008 --> 00:08:20,038
就剛剛提到的啦 好那我們說

148
00:08:20,038 --> 00:08:23,075
那如果說有ACK沒有被收到的問題

149
00:08:23,075 --> 00:08:25,078
就是一個ACK沒有被收到啊

150
00:08:25,078 --> 00:08:27,061
那ACK沒有被收到的話

151
00:08:27,061 --> 00:08:33,035
那你那個NAV本身就沒辦法很正確的計算了嘛

152
00:08:33,035 --> 00:08:35,075
那這個時候怎麼辦呢 我們講

153
00:08:35,075 --> 00:08:41,038
就是說 如果呢 我們說 如果這個ACK本身

154
00:08:41,038 --> 00:08:43,095
destination沒有把它送出來

155
00:08:43,095 --> 00:08:47,038
就ACK本身 等於說

156
00:08:47,038 --> 00:08:50,075
 destination送這個ACK的時候呢假設就壞掉了啦

157
00:08:50,075 --> 00:08:55,075
那些 本來有一些station呢 他只聽得到這個ACK的

158
00:08:55,075 --> 00:08:58,098
等於說他比較靠近這個receiver這一端

159
00:08:58,098 --> 00:09:01,065
就是送封包回ACK嘛 聽得到ACK的

160
00:09:01,065 --> 00:09:04,021
可是因為現在ACK沒有被送出來啊

161
00:09:04,021 --> 00:09:07,088
所以他們的這個NAV呢 就沒有辦法被更新嘛

162
00:09:07,088 --> 00:09:11,041
因為ACK裡面會帶一下輪的 下一輪

163
00:09:11,041 --> 00:09:14,071
我們下一個round 下一個round需要多少時間

164
00:09:14,071 --> 00:09:17,005
萬一這個ACK沒有被送出來的話

165
00:09:17,005 --> 00:09:19,058
那他的NAV就不會被更新了嘛

166
00:09:20,048 --> 00:09:25,068
那不會被更新怎麼辦咧 那只好用這個 所有的NAV

167
00:09:25,068 --> 00:09:28,031
我們講from fragment1

168
00:09:28,031 --> 00:09:32,088
等真的data由fragment1所得來的NAV

169
00:09:32,088 --> 00:09:37,071
讓他expired 就讓它算到0 才能為主嘛

170
00:09:37,071 --> 00:09:40,065
那我們就讓這個source本身就必須等

171
00:09:40,065 --> 00:09:46,031
等到這個所謂的fragment1的NAV

172
00:09:46,031 --> 00:09:49,028
讓他變成0之後 才代表說

173
00:09:49,028 --> 00:09:52,068
好這個 這一輪 反正你沒有收到ACK你已經不能送了

174
00:09:52,068 --> 00:09:56,055
不能送也不能馬上停掉 因為其他人還在聽嘛

175
00:09:56,055 --> 00:09:58,055
因為其他人都已經把這個值設好了

176
00:09:58,055 --> 00:10:00,025
所以要等這個值等於說

177
00:10:00,025 --> 00:10:03,081
讓他回歸 降到0的時候呢才開始

178
00:10:03,081 --> 00:10:07,015
來試著所謂的重送啦 我們看一個例子

179
00:10:07,015 --> 00:10:09,071
一樣 在這個例子裡面我們說

180
00:10:09,071 --> 00:10:14,015
好 這個source呢送一個request to send

181
00:10:14,015 --> 00:10:16,091
那其他的node聽到這個的話

182
00:10:16,091 --> 00:10:20,001
跟剛才一樣 他們就把這個NAV的值

183
00:10:20,001 --> 00:10:24,051
設到 就是送一個封包回一個ACK所需要的總時間

184
00:10:24,051 --> 00:10:28,038
那這個destination呢 他回一個clear to send

185
00:10:28,038 --> 00:10:30,068
一樣 clear to send帶了一個duration

186
00:10:30,068 --> 00:10:35,025
就是那個封包加上這個ACK結束的時間 在這個地方

187
00:10:35,025 --> 00:10:38,055
那等下data真的送的時候呢 我們剛提到

188
00:10:38,055 --> 00:10:41,021
這個真的送這個fragment的時候

189
00:10:41,021 --> 00:10:43,095
他其實會帶下一個duration的時間

190
00:10:43,095 --> 00:10:46,025
他也把它帶進去了 帶進去了

191
00:10:46,025 --> 00:10:49,085
然後接下來 這個destination回一個ACK

192
00:10:49,085 --> 00:10:51,051
這個ACK其實他也帶了一個

193
00:10:51,051 --> 00:10:55,035
他也帶一個 就下一個round所需要的時間

194
00:10:55,035 --> 00:10:57,031
他本來也帶這個值啦

195
00:10:57,031 --> 00:10:59,061
就是說我們這個地方其實帶了這個值

196
00:10:59,061 --> 00:11:05,071
只是萬一 是說 這個不巧的 這個ACK呢就失敗

197
00:11:05,071 --> 00:11:10,008
這個ACK沒有成功的送出來 就是毀掉了 不見了

198
00:11:10,008 --> 00:11:14,088
那毀掉不見之後呢 那我們就是說 那這個值就沒有啊

199
00:11:14,088 --> 00:11:18,065
因為這個值並沒有被公佈出來嘛

200
00:11:18,065 --> 00:11:22,078
所以這個值就沒有了 那其他的node呢

201
00:11:22,078 --> 00:11:27,055
聽到request to send的人 有這個值啦 到這邊

202
00:11:27,055 --> 00:11:30,038
那只聽到前面clear to send只能到這裡

203
00:11:30,038 --> 00:11:31,091
因為其他沒有了嘛

204
00:11:31,091 --> 00:11:33,031
所以這個source本身

205
00:11:33,031 --> 00:11:37,025
他就必須等到這個時間點結束之後

206
00:11:37,025 --> 00:11:40,088
他才認為說 這個channel呢 現在才有辦法變成idle

207
00:11:40,088 --> 00:11:45,025
他才有辦法開始再來 再來開始送這個資料

208
00:11:45,098 --> 00:11:50,095
好 那我們說 這個什麼時候需要用到RTS

209
00:11:50,095 --> 00:11:53,071
什麼時候用到CTS這樣的所謂的

210
00:11:53,071 --> 00:11:57,065
事先的交握呢 我們說 因為我們這個封包呢

211
00:11:57,065 --> 00:12:02,011
如果比較長的話 為了避免他丟出去的時候呢

212
00:12:02,011 --> 00:12:05,008
發生了collision 而且我們又沒有辦法偵測collision

213
00:12:05,008 --> 00:12:08,008
所以我們說 如果封包比較長的時候呢

214
00:12:08,008 --> 00:12:12,075
最好可以用一個RTS跟CTS呢 先做一個類似公告

215
00:12:12,075 --> 00:12:15,055
然後先把這個channel預約下來

216
00:12:15,055 --> 00:12:19,045
那我們說這個封包到底長或短 怎麼決定呢

217
00:12:19,045 --> 00:12:21,058
我們有定一個 在標準裡面呢

218
00:12:21,058 --> 00:12:23,091
有一個叫RTS的threshold

219
00:12:23,091 --> 00:12:27,088
等於說我們定一個定一個所謂的臨界值或訂一個參考值

220
00:12:27,088 --> 00:12:33,041
那如果我們的封包長度呢 大於這個RTS的threshold

221
00:12:33,041 --> 00:12:37,025
那我們就要用RTS 因為這是為了讓傳輸的時候呢

222
00:12:37,025 --> 00:12:41,058
更有效率 不要因為發生衝撞 讓大封包呢就不見了

223
00:12:41,058 --> 00:12:44,085
但是如果說我們送的封包呢 本來就比較短

224
00:12:44,085 --> 00:12:48,031
也就是說短封包 短封包就不需要

225
00:12:48,031 --> 00:12:51,061
再用RTS跟CTS的交握的過程當中

226
00:12:51,061 --> 00:12:53,061
那這樣的話反而變成說

227
00:12:53,061 --> 00:12:57,088
短封包也需要一個RTS CTS反而這個效率會更

228
00:12:57,088 --> 00:12:59,048
等於是說效率更差啦

229
00:12:59,048 --> 00:13:03,065
所以我們說 如果呢我們的這個封包比較短的話呢

230
00:13:03,065 --> 00:13:06,038
我們就不需要RTS CTS啦

231
00:13:06,038 --> 00:13:10,065
那我們來看看 那沒有用RTS 沒有用CTS呢

232
00:13:10,065 --> 00:13:13,021
到底怎麼傳輸呢 我們看一下

233
00:13:13,021 --> 00:13:15,075
在這個例子裡面 我們也是一樣

234
00:13:15,075 --> 00:13:17,021
我們假設有一個source呢

235
00:13:17,021 --> 00:13:19,028
他要送給這個destination

236
00:13:19,028 --> 00:13:22,078
那我們有其他的工作站 那我們假設source本身

237
00:13:22,078 --> 00:13:26,041
在這個時間 在這個時間點進來 想要送了

238
00:13:26,041 --> 00:13:28,098
一樣 這個時候sense到說

239
00:13:28,098 --> 00:13:31,015
這個channel呢 叫做所謂的free

240
00:13:31,015 --> 00:13:33,005
這個channel現在沒有人在用

241
00:13:33,005 --> 00:13:35,068
那我們知道 即使free也不能馬上送

242
00:13:35,068 --> 00:13:39,061
即使free的話 我必須等一個DIF的時間

243
00:13:39,061 --> 00:13:43,098
那我等到了 等到就是說 我真的也可以聽到這個

244
00:13:43,098 --> 00:13:48,025
所謂的busy的 channel這個idle的時間

245
00:13:48,025 --> 00:13:52,015
這個時間讓我等到了 而且呢我就開始送了

246
00:13:52,015 --> 00:13:53,015
我就開始送

247
00:13:53,015 --> 00:13:56,088
因為我不需要送一個RTS 然後用一個CTS

248
00:13:56,088 --> 00:14:00,051
我就是開始送data 只是說data送完之後呢

249
00:14:00,051 --> 00:14:02,091
我一定要等一個這個ACK回來

250
00:14:02,091 --> 00:14:06,028
就是這個data呢 跟ACK呢 是一定要綁在一起的

251
00:14:06,028 --> 00:14:10,015
而且這個ACK呢一定會在一個short的時間

252
00:14:10,015 --> 00:14:12,005
就一定要回來

253
00:14:12,005 --> 00:14:14,048
就是說 我們有特別強調

254
00:14:14,048 --> 00:14:17,035
data跟ACK他們中間的時間間隔

255
00:14:17,035 --> 00:14:21,058
一定呢只能是一個所謂的short short的時間

256
00:14:21,058 --> 00:14:24,048
所以這是很特別的地方 好

257
00:14:24,048 --> 00:14:30,051
那等到這個時間過了之後 其他的node呢來看的時候

258
00:14:30,051 --> 00:14:33,055
對於 我們講 對其他的工作站來講的話

259
00:14:33,055 --> 00:14:37,015
他們如果在這個中間

260
00:14:37,015 --> 00:14:41,021
在這個中間 進來想要送的話 一樣

261
00:14:41,021 --> 00:14:43,075
他們看到 有data在送的一定是busy嘛

262
00:14:43,075 --> 00:14:47,038
然後必須等待一個時間 結果發現等的過程當中

263
00:14:47,038 --> 00:14:50,005
又出現一個ACK 又一個封包跑進來

264
00:14:50,005 --> 00:14:53,085
所以他要等這一輪送完之後 在這個時間點

265
00:14:53,085 --> 00:14:57,001
之後 一樣 等一個DIFS的時間

266
00:14:57,001 --> 00:14:59,058
然後他們再產生一個random back-off的時間

267
00:14:59,058 --> 00:15:03,001
然後開始送資料 所以後面這一段呢

268
00:15:03,001 --> 00:15:06,008
都是跟我們之前介紹的是一樣的

269
00:15:06,008 --> 00:15:09,031
就是我們如果發現這個channel是busy

270
00:15:09,031 --> 00:15:11,065
那你就必須一直等到他idle

271
00:15:11,065 --> 00:15:16,038
等到他idle的時候 必須等到一個DIFS的時間喔

272
00:15:16,038 --> 00:15:20,018
像這個地方 其實在這個中間過程 其實他也是idle了

273
00:15:20,018 --> 00:15:23,095
因為他是data跟ACK中間有一個小空檔

274
00:15:23,095 --> 00:15:26,001
可是這空檔的時間不夠短

275
00:15:26,001 --> 00:15:30,025
這個空檔只有一個short IFS 不是一個DIFS

276
00:15:30,025 --> 00:15:34,068
所以對其他工作站來講的話 那麼短的空檔

277
00:15:34,068 --> 00:15:37,038
對他來看 其實沒有用 還是busy

278
00:15:37,038 --> 00:15:40,091
所以等於說沒有效 所以一直要等到這段時間

279
00:15:40,091 --> 00:15:43,038
這個聽到這個這麼長的

280
00:15:43,038 --> 00:15:46,098
這麼長的時間都是這個所謂的idle

281
00:15:46,098 --> 00:15:50,005
這個才叫做idle 好 阿這個就是說

282
00:15:50,005 --> 00:15:54,058
我們如果封包比較長 就用RTS CTS呢來保護

283
00:15:54,058 --> 00:15:58,078
如果封包本身本來就很短 那就不需要RTS CTS

284
00:15:58,078 --> 00:16:03,011
直接在適當的時間點 等於說我們如果發現是idle

285
00:16:03,011 --> 00:16:06,065
我只要等到一個DIFS的空檔

286
00:16:06,065 --> 00:16:08,031
你封包就可以直接丟出來

287
00:16:08,031 --> 00:16:11,011
丟出來之後 後面馬上跟著一個ACK

288
00:16:11,011 --> 00:16:15,048
那這樣就等於說 一個來回 這個封包就算成功的送出去

289
00:16:15,048 --> 00:16:17,048


