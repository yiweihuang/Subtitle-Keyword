1
00:00:08,075 --> 00:00:13,008
好 接下來我們來介紹 所謂的DCF

2
00:00:13,008 --> 00:00:16,088
就是所謂的802.11裡面 CSMA/CA的主體

3
00:00:16,088 --> 00:00:20,028
我們說這個DCF裡面呢

4
00:00:20,028 --> 00:00:25,045
最主要就是說 他要讓這些工作站呢

5
00:00:25,045 --> 00:00:31,048
可以來分享現在上面的頻寬 那他的做法就是說

6
00:00:31,048 --> 00:00:35,098
我們用了剛剛有提到 叫CSMA/CA這個protocol

7
00:00:35,098 --> 00:00:38,051
然後再加上一個我們叫做

8
00:00:38,051 --> 00:00:41,075
random back-off time的方法來避免

9
00:00:41,075 --> 00:00:45,025
因為我們這裡叫做CA嘛 就collision avoidance

10
00:00:45,025 --> 00:00:50,018
那如果我們知道說 大家現在如果同時傳送

11
00:00:50,018 --> 00:00:53,075
會有collision 那我們當然就要把他避開來啊

12
00:00:53,075 --> 00:00:56,058
作法就這樣 譬如說我們現在如果去聽聽看

13
00:00:56,058 --> 00:00:57,085
我們剛剛提到說

14
00:00:57,085 --> 00:01:00,058
當我在做carrier sense的時候有兩種結果

15
00:01:00,058 --> 00:01:03,058
一個就是現在是idle 另外一個就是busy

16
00:01:03,058 --> 00:01:07,095
那如果現在是busy的話 一般我們就 那我就繼續聽

17
00:01:07,095 --> 00:01:10,071
讓這個busy的這個 讓他等於說

18
00:01:10,071 --> 00:01:12,075
這部分都是busy啦 讓他結束

19
00:01:12,075 --> 00:01:15,048
這邊是代表clear了 好

20
00:01:15,048 --> 00:01:18,021
那如果我們在這過程當中 我們因為都在聽嘛

21
00:01:18,021 --> 00:01:21,061
我們聽到他busy 當它變成idle 我一送 那一定collision

22
00:01:21,061 --> 00:01:25,065
這個我們在CSMA/CD的時候就介紹過了

23
00:01:25,065 --> 00:01:28,041
就是說 我們一開始聽 如果他是busy呢

24
00:01:28,041 --> 00:01:31,088
我們就讓他把他送完 變成一個idle

25
00:01:31,088 --> 00:01:34,061
那變成一個idle的時候 我們剛剛提到

26
00:01:34,061 --> 00:01:36,075
那我們還要等到一個gap

27
00:01:36,075 --> 00:01:39,018
等一個我們叫做inter frame gap

28
00:01:39,018 --> 00:01:41,098
等到這個gap結束之後

29
00:01:41,098 --> 00:01:44,098
這個gap等待的時間 是為了我們剛剛提到

30
00:01:44,098 --> 00:01:47,095
為了有ㄧ些priority 就是說

31
00:01:47,095 --> 00:01:51,048
我們等一下會介紹我們的priority有三層啦

32
00:01:51,048 --> 00:01:55,058
就是說這個等待的時間呢 有三種不同的時間間隔

33
00:01:55,058 --> 00:02:01,031
如果是所謂的像RTS啦 CTS 控制方面的話

34
00:02:01,031 --> 00:02:05,091
他這個間隔很短 啊如果是剛剛提到的 PCF

35
00:02:05,091 --> 00:02:10,045
就是要做real time傳輸的話 他中間時間比較長一點

36
00:02:10,045 --> 00:02:15,078
那如果是一般正常的data 那他的時間間隔就更長

37
00:02:15,078 --> 00:02:22,058
所以有短 中 長的時間間隔 那我們現在談的是

38
00:02:22,058 --> 00:02:26,055
假設我們是長時間間隔 因為我們要做資料的傳輸

39
00:02:26,055 --> 00:02:28,081
就一般的資料傳輸 也就是說

40
00:02:28,081 --> 00:02:32,005
我們一般就假設要送的時候來聽聽看

41
00:02:32,005 --> 00:02:35,091
說這個頻道是不是有資料在送 如果有

42
00:02:35,091 --> 00:02:39,025
你當然不能送 你送就撞在一起 所以我們會聽到他結束

43
00:02:39,025 --> 00:02:42,028
那聽到他結束之後呢 我們還要再等一段

44
00:02:42,028 --> 00:02:44,078
剛剛提到 這個所謂的等待時間

45
00:02:44,078 --> 00:02:49,051
這個等待時間是為了讓比較有優先權的

46
00:02:49,051 --> 00:02:53,098
因為有優先權他等待時間很短 更短他們就會更早動作

47
00:02:53,098 --> 00:02:57,045
好 那我們說假設這邊有好幾個node

48
00:02:57,045 --> 00:02:59,041
在這個時間點想要送

49
00:02:59,041 --> 00:03:02,091
那等到聽到這個channel變idle的時候呢

50
00:03:02,091 --> 00:03:04,098
我們還繼續會等一段時間

51
00:03:04,098 --> 00:03:08,038
那如果我們有 譬如說有三個都想送

52
00:03:08,038 --> 00:03:12,055
那等到這個時間都到了 到這個時間點了

53
00:03:12,055 --> 00:03:16,011
三個 如果你三個都送上來 那也是collision啊

54
00:03:16,011 --> 00:03:19,088
那我們既然叫做collision avoidance

55
00:03:19,088 --> 00:03:22,068
就是我們盡量來避免collision

56
00:03:22,068 --> 00:03:27,031
就是說 我聽這個頻道變idle的時候

57
00:03:27,031 --> 00:03:31,085
我會等待一段時間 這個時間等到了之後

58
00:03:31,085 --> 00:03:37,008
等到之後 我還要再加上一個random back-off

59
00:03:37,008 --> 00:03:41,005
就時間等到了 還是不能送

60
00:03:41,005 --> 00:03:44,055
大家再等一個random delay

61
00:03:44,055 --> 00:03:48,071
啊既然叫做random delay 就他把它錯開的意思

62
00:03:48,071 --> 00:03:51,058
就有的人等的 既然是random的時間嘛

63
00:03:51,058 --> 00:03:55,071
有的等的比較長 有的等的比較短 然後再來聽聽看

64
00:03:55,071 --> 00:03:58,095
就是每次等到的時間 到了之後呢

65
00:03:58,095 --> 00:04:01,045
一定要來再來聽聽看 再聽聽看

66
00:04:01,045 --> 00:04:04,025
然後就可以 如果是idle就可以送出去了

67
00:04:04,025 --> 00:04:08,011
所以我們說 如果呢我們發現說

68
00:04:08,011 --> 00:04:10,075
這個medium本身是busy的

69
00:04:10,075 --> 00:04:12,055
就是我們等一下會有例子

70
00:04:12,055 --> 00:04:14,045
就是說我們先聽聽看這個媒介

71
00:04:14,045 --> 00:04:17,071
如果是busy的 那我們就會等待一個時間

72
00:04:17,071 --> 00:04:21,025
啊等待一個時間 等了 等這時間是看什麼

73
00:04:21,025 --> 00:04:25,058
等多久 就看我們是PCF啦 還是我們是DCF嘛

74
00:04:25,058 --> 00:04:28,051
那等下還會介紹另外一個 更重要的

75
00:04:28,051 --> 00:04:30,081
那你即使這個時間等到了

76
00:04:30,081 --> 00:04:34,001
我們說還要一個叫做random back-off time

77
00:04:34,001 --> 00:04:37,058
你還是要變成一個亂數等待 最主要是要錯開

78
00:04:37,058 --> 00:04:40,095
錯開這個衝撞的這個機率啦

79
00:04:40,095 --> 00:04:42,081
但是說我們既然是亂數嘛

80
00:04:42,081 --> 00:04:46,051
所以就有可能他們還是會 時間是一樣

81
00:04:46,051 --> 00:04:50,015
所以雖然叫做CA 我們一直強調

82
00:04:50,015 --> 00:04:52,078
雖然這個演算法叫做collision avoidance

83
00:04:52,078 --> 00:04:55,091
但是他沒有辦法百分之百avoidance

84
00:04:55,091 --> 00:04:57,095
有時候還是會衝撞啦

85
00:04:57,095 --> 00:05:02,061
那既然衝撞呢是沒有辦法百分之百避免啦

86
00:05:02,061 --> 00:05:05,041
那封包衝撞了怎麼辦呢

87
00:05:05,041 --> 00:05:08,085
因為我們又沒有辦法做collision detection

88
00:05:08,085 --> 00:05:12,035
我們特別強調802.11 有一個很重要的特色

89
00:05:12,035 --> 00:05:15,001
就是他沒有辦法做collision detection

90
00:05:15,001 --> 00:05:18,031
就封包真的撞掉了 我們上次有介紹過

91
00:05:18,031 --> 00:05:21,025
所謂的hidden terminal 就是說我聽不到你

92
00:05:21,025 --> 00:05:24,041
但是呢 你的傳輸可能跟我的會撞在一起

93
00:05:24,041 --> 00:05:28,098
那撞在一起呢我又不知道 所以我們說802.11呢

94
00:05:28,098 --> 00:05:33,058
他用了一個叫做所謂的ACK frame的方式

95
00:05:33,058 --> 00:05:37,055
我們叫做immediate positive的ACK frame

96
00:05:37,055 --> 00:05:43,048
也就是說 如果我送一個封包給你 如果你成功收到的話

97
00:05:43,048 --> 00:05:45,088
你要立刻回我一個ACK

98
00:05:45,088 --> 00:05:50,061
就是說 我就用這個機制來保證你有收到

99
00:05:50,061 --> 00:05:57,055
那如果我沒有收到ACK 我就會做一個叫做重送

100
00:05:57,055 --> 00:05:59,045
我們叫做retransmission的動作

101
00:05:59,045 --> 00:06:02,041
所以在802.11非常特別就是說

102
00:06:02,041 --> 00:06:05,035
我送一個封包出去 我一定要收一個ACK

103
00:06:05,035 --> 00:06:08,081
我ACK沒有收到 我就認為我這個封包失敗了

104
00:06:08,081 --> 00:06:12,058
那可能就是collision或者掉了 那我就會重送

105
00:06:12,058 --> 00:06:15,048
這個是非常非常重要的觀念

106
00:06:15,048 --> 00:06:17,091
就是說我任何一個封包丟出去

107
00:06:17,091 --> 00:06:20,041
我都要收一個ACK 我沒有收到ACK

108
00:06:20,041 --> 00:06:24,045
我就認為這個封包是錯誤了 這個是他的特色

109
00:06:24,045 --> 00:06:28,035
另外一個我們也提到說 我們這個CSMA

110
00:06:28,035 --> 00:06:30,038
叫做carrier sense嘛

111
00:06:30,038 --> 00:06:35,018
那carrier sense就是說我要聽聽看這個carrier

112
00:06:35,018 --> 00:06:38,035
就現在有沒有正在送這個封包啊

113
00:06:38,035 --> 00:06:41,028
那這個carrier sense本身可以有兩種作法

114
00:06:41,028 --> 00:06:44,098
一個叫做physical 一個叫做virtual的mechanism

115
00:06:44,098 --> 00:06:48,041
physical carrier sense就是說我就真的去聽那個頻道

116
00:06:48,041 --> 00:06:50,098
聽那個頻道有沒有訊號

117
00:06:50,098 --> 00:06:53,035
這個就是用physical真的去聽

118
00:06:53,035 --> 00:06:56,041
那什麼叫做virtual呢 就是我們之前介紹的啊

119
00:06:56,041 --> 00:06:59,095
我的request to send就是告訴你說

120
00:06:59,095 --> 00:07:01,075
我等一下要送多久

121
00:07:01,075 --> 00:07:03,008
那等一下要送多久 就有點像是

122
00:07:03,008 --> 00:07:05,035
我只是宣告我等一下要送多久

123
00:07:05,035 --> 00:07:07,088
那我的clear to send 就是我等下說

124
00:07:07,088 --> 00:07:10,055
我等下要花多就時間來收封包

125
00:07:10,055 --> 00:07:13,068
啊你們聽到的等下就不要來鬧

126
00:07:13,068 --> 00:07:16,091
那不要來鬧的那個期間

127
00:07:16,091 --> 00:07:20,088
就把它當成這個channel是busy的

128
00:07:20,088 --> 00:07:24,058
就是說雖然channel不一定是busy 因為你也聽不到

129
00:07:24,058 --> 00:07:29,005
但是呢 我就告訴你說等下這段期間呢是我要用的

130
00:07:29,005 --> 00:07:32,098
所以你們雖然聽不到 就把它當成是busy的

131
00:07:32,098 --> 00:07:35,031
這個就所謂的virtual這種carrier sense

132
00:07:35,031 --> 00:07:37,001
因為他並不是真的做carrier sense

133
00:07:37,001 --> 00:07:41,041
而是用 我們用那個所謂的虛擬的方式呢

134
00:07:41,041 --> 00:07:44,001
讓他變成好像很忙的樣子 就剛剛提到

135
00:07:44,001 --> 00:07:47,065
說 這個所謂的virtual carrier sense呢

136
00:07:47,065 --> 00:07:53,021
virtual 這句話就是說 因為我們在送封包之前

137
00:07:53,021 --> 00:07:54,095
有必要的時候呢

138
00:07:54,095 --> 00:07:58,071
我們會用所謂的clear to send跟request to send

139
00:07:58,071 --> 00:08:01,081
就RTS跟CTS 他們會交換說

140
00:08:01,081 --> 00:08:04,068
送的這一端送一個request to send

141
00:08:04,068 --> 00:08:07,058
收的這一端回應一個clear to send

142
00:08:07,058 --> 00:08:10,005
所以等於說他們的範圍之內

143
00:08:10,005 --> 00:08:14,038
各有人聽到RTS 有人聽到這個CTS嘛

144
00:08:14,038 --> 00:08:18,015
那裡面呢 涵蓋了一個叫做duration field

145
00:08:18,015 --> 00:08:21,008
代表說等一下要送多久的時間

146
00:08:21,008 --> 00:08:25,018
另外一端說我等下要花多少時間來收 一個送一個收

147
00:08:25,018 --> 00:08:30,028
那聽到 分別聽到RTS聽到這個CTS就知道說

148
00:08:30,028 --> 00:08:36,025
等一下這個channel會被保留下來做這個資料的傳輸要多久

149
00:08:36,025 --> 00:08:41,018
阿在這個時間之內 你就把它當成這個channel是busy的

150
00:08:41,018 --> 00:08:42,045
所以我們叫做virtual

151
00:08:42,045 --> 00:08:46,045
就是因為他並不是真的去聽有沒有封包在送

152
00:08:46,045 --> 00:08:48,005
因為他聽不到

153
00:08:48,005 --> 00:08:52,071
那就把它當成等下會很忙 你不要來鬧的意思啦

154
00:08:52,071 --> 00:08:57,068
那我們說 那什麼時候要用這個RTS什麼要用CTS呢

155
00:08:57,068 --> 00:09:00,068
我們剛剛有提到說 因為ethernet的封包

156
00:09:00,068 --> 00:09:02,065
對不起 802.11的封包呢

157
00:09:02,065 --> 00:09:04,065
他最常有2000多個bytes

158
00:09:04,065 --> 00:09:07,085
2000多個bytes如果又沒有辦法發

159
00:09:07,085 --> 00:09:11,005
又沒有辦法做所謂的collision detection

160
00:09:11,005 --> 00:09:13,005
就是說我的封包很長

161
00:09:13,005 --> 00:09:16,091
那如果丟出去萬一發生衝撞我又不知道

162
00:09:16,091 --> 00:09:20,021
我封包會把它送完的 就是他會把封包送完

163
00:09:20,021 --> 00:09:23,081
把封包送完又發生衝撞 那這個就是很虧了

164
00:09:23,081 --> 00:09:26,025
變成說你這個非常非常浪費 所以我們說

165
00:09:26,025 --> 00:09:29,081
如果你的封包很長 那你在真的送封包之前

166
00:09:29,081 --> 00:09:34,005
先用RTS CTS做一個交握 做一個預約

167
00:09:34,005 --> 00:09:37,028
但是我想說那如果我的封包很短

168
00:09:37,028 --> 00:09:39,001
就我本來就是短封包

169
00:09:39,001 --> 00:09:42,091
那如果短封包本身 我還要做一個RTS CTS

170
00:09:42,091 --> 00:09:45,045
其實RTS CTS也是在佔頻寬啦

171
00:09:45,045 --> 00:09:48,048
因為他本身也是要一個封包去一個封包回

172
00:09:48,048 --> 00:09:50,048
他要佔時間 他要佔頻寬

173
00:09:50,048 --> 00:09:55,071
那我們會設定一個叫做所謂的RTS的threshold

174
00:09:55,071 --> 00:09:59,005
就是類似設一個叫所謂的臨界值

175
00:09:59,005 --> 00:10:02,025
就是說我們的封包呢的資料

176
00:10:02,025 --> 00:10:08,021
資料如果太短的話 那就不需要RTS CTS啦

177
00:10:08,021 --> 00:10:11,035
就是如果我的封包是很短的 我就直接送封包啦

178
00:10:11,035 --> 00:10:15,025
那我們剛提到 送封包我就等ACK嘛

179
00:10:15,025 --> 00:10:18,051
我如果收到ACK 就代表成功收到了

180
00:10:18,051 --> 00:10:20,091
如果沒有收到ACK 我就會重送

181
00:10:20,091 --> 00:10:22,081
就我們如果封包很短

182
00:10:22,081 --> 00:10:26,041
其實我就不需要RTS CTS來幫我打頭陣的意思

183
00:10:26,041 --> 00:10:31,031
封包很長 因為封包很長如果發生衝撞 你要很久才知道

184
00:10:31,031 --> 00:10:36,041
那這個非常危險 所以長封包我就用RTS CTS打頭陣

185
00:10:36,041 --> 00:10:39,035
先幫我預約一下 啊如果我的封包很短

186
00:10:39,035 --> 00:10:41,095
我直接就去送了 說不定我直接就成功了

187
00:10:41,095 --> 00:10:44,071
那如果我直接失敗 那我就再送一次嘛

188
00:10:44,071 --> 00:10:49,048
因為封包很短 所以再送一次呢也不是太複雜的事情

189
00:10:49,048 --> 00:10:54,025
好那我們剛剛也提到說 那我們怎麼做carrier sense呢

190
00:10:54,025 --> 00:10:57,055
剛有提到 physical carrier sense

191
00:10:57,055 --> 00:11:00,008
physical就是我們真的有一個天線

192
00:11:00,008 --> 00:11:03,035
他就去聽 說這個carrier本身

193
00:11:03,035 --> 00:11:07,008
到底現在是不是busy 這個是很直接的做法

194
00:11:07,008 --> 00:11:08,025
那我們剛提到

195
00:11:08,025 --> 00:11:14,021
那如果是virtual的話 就是用RTS CTS

196
00:11:14,021 --> 00:11:18,021
他們做一個交握 做預約 上面有一個叫做duration

197
00:11:18,021 --> 00:11:22,028
好那這個duration的值 我們就會把它記下來

198
00:11:22,028 --> 00:11:28,005
叫做net allocation vector 叫做NAV 這個等一下會用到

199
00:11:28,005 --> 00:11:35,048
因為 因為我們在兩個node送封包的時候呢

200
00:11:35,048 --> 00:11:40,035
有時候呢他會送好幾個封包 會連續送好幾次

201
00:11:40,035 --> 00:11:43,055
就是 因為我們有時候封包比較大

202
00:11:43,055 --> 00:11:47,048
一個封包要送給對方 可能有時候要切成好幾個

203
00:11:47,048 --> 00:11:50,005
我們叫做fragment 切成小片段

204
00:11:50,005 --> 00:11:52,071
如果你有好幾個小片段要送的時候

205
00:11:52,071 --> 00:11:55,015
那我們前面介紹說  所謂的

206
00:11:55,015 --> 00:11:58,098
那我在做RTS跟CTS交握的時候呢

207
00:11:58,098 --> 00:12:01,045
上面會帶那個duration

208
00:12:01,045 --> 00:12:04,061
這個duration到底怎麼填呢

209
00:12:04,061 --> 00:12:09,025
就是RTS跟CTS呢他們所填的duration呢

210
00:12:09,025 --> 00:12:14,015
都是指一個封包傳輸跟接收的一個時間啦

211
00:12:14,015 --> 00:12:18,038
所以這個所謂的virtual的這個carrier sense的方法呢

212
00:12:18,038 --> 00:12:23,025
就是靠像RTS或CTS呢 他會帶這個duration

213
00:12:23,025 --> 00:12:27,035
而我們會把這個duration的這個訊息呢 把它寄到

214
00:12:27,035 --> 00:12:32,098
這個叫做net allocation vector 因為他是一個數字

215
00:12:32,098 --> 00:12:38,058
這個數字就是我們要認為這個channel 會busy到多久

216
00:12:38,058 --> 00:12:40,085
所以他是一個參數

217
00:12:40,085 --> 00:12:45,001
那如果你看到一個RTS或看到一個CTS

218
00:12:45,001 --> 00:12:48,011
裡面帶了duration 就把這個duration的數字就

219
00:12:48,011 --> 00:12:50,078
放到這個所謂的net allocation vector

220
00:12:50,078 --> 00:12:54,095
我們做NAV 那這個NAV呢我們剛剛提到

221
00:12:54,095 --> 00:12:57,095
他不是一次的值 他可能等一下呢

222
00:12:57,095 --> 00:13:00,008
又會收到另外一個duration

223
00:13:00,008 --> 00:13:03,058
所以他會累加 他等下會越變越長也有可能

224
00:13:03,058 --> 00:13:06,008
我們現在 等下會有例子來說明

225
00:13:06,008 --> 00:13:10,085
好 那接下來我們說 802.11裡面

226
00:13:10,085 --> 00:13:15,078
因為沒辦法做這個所謂的collision detection

227
00:13:15,078 --> 00:13:21,025
所以我們怎麼確保對方有正確的收到這個封包呢

228
00:13:21,025 --> 00:13:23,071
我們說 我們會用所謂的ACK

229
00:13:23,071 --> 00:13:26,041
而且是positive的acknowledgement

230
00:13:26,041 --> 00:13:29,045
就是說 對方如果有收到的話

231
00:13:29,045 --> 00:13:32,041
他一定要回一個ACK的frame

232
00:13:32,041 --> 00:13:36,018
一定要回一個ACK的frame 而且這個回ACK frame呢

233
00:13:36,018 --> 00:13:41,001
必須我們說 必須立刻回 立刻回

234
00:13:41,001 --> 00:13:43,045
就是說你收到一個封包 你要馬上回喔

235
00:13:43,045 --> 00:13:48,015
你太晚回他就認為這個封包已經掉了 錯誤掉了

236
00:13:48,015 --> 00:13:51,058
也就是說這個送一個封包 一定要回一個ACK

237
00:13:51,058 --> 00:13:56,061
這是很重要的一個機制 送一個封包 如果正確的話

238
00:13:56,061 --> 00:14:01,035
一定要回一個ACK 送封包一定要回ACK

239
00:14:01,035 --> 00:14:07,008
第二個就是說這個ACK 一定要在最短的時間內回

240
00:14:07,008 --> 00:14:10,085
啊什麼叫做最短的時間呢 我們就叫做這個

241
00:14:10,085 --> 00:14:15,058
S short inter frame space 我們剛提到

242
00:14:16,098 --> 00:14:22,098
回ACK本身 一定要立刻回

243
00:14:22,098 --> 00:14:26,031
那所謂的立刻回就是說 我們訂一個時間

244
00:14:26,031 --> 00:14:31,038
這個時間就是送封包跟回ACK 這個時間差

245
00:14:31,038 --> 00:14:34,068
啊這個時間差呢 他一定是最短的

246
00:14:34,068 --> 00:14:37,061
就叫做short inter frame space

247
00:14:37,061 --> 00:14:41,005
那我們說 到底有哪些封包呢

248
00:14:41,005 --> 00:14:46,041
一定要收到一個ACK才算數呢

249
00:14:46,041 --> 00:14:50,041
首先我們看data 送data的時候一定

250
00:14:50,041 --> 00:14:53,055
我送一個封包出去 data你一定要回一個ACK

251
00:14:53,055 --> 00:14:57,008
另外一個就是像polling 我們在PCF裡面

252
00:14:57,008 --> 00:15:00,068
就是說我在poll 我在詢問你說你到底要不要送

253
00:15:00,068 --> 00:15:02,068
你一定要回我一個ACK

254
00:15:02,068 --> 00:15:05,058
好 那我們說我如果提出request

255
00:15:05,058 --> 00:15:08,058
像我們之前介紹有probe request啦

256
00:15:08,058 --> 00:15:12,041
probe request 你收到你就馬上回我 response

257
00:15:12,041 --> 00:15:15,035
所以request啦 response啦

258
00:15:15,035 --> 00:15:19,065
這些都是 這些都是需要回ACK的

259
00:15:19,065 --> 00:15:23,065
那我們說 像這些封包 不管是data啦

260
00:15:23,065 --> 00:15:27,031
或者polling啦 或者request啦

261
00:15:27,031 --> 00:15:31,001
或者response 就是說我送一個request你要回我ACK喔

262
00:15:31,001 --> 00:15:34,001
那我送你一個response 你也要回我一個ACK喔

263
00:15:34,001 --> 00:15:38,008
就是這四類 data啦 poll啦 request啦 response

264
00:15:38,008 --> 00:15:42,001
都需要回一個ACK 那如果沒有ACK的話

265
00:15:42,001 --> 00:15:45,051
我們就把它當成是一個error 就當成錯誤啦

266
00:15:45,051 --> 00:15:51,045
好那我們就說 這個因為我們在不同的環境之下

267
00:15:51,045 --> 00:15:53,088
我們會出現剛剛提到

268
00:15:53,088 --> 00:15:56,095
不同的所謂的inter frame space

269
00:15:56,095 --> 00:16:00,071
不同的這個frame跟frame之間的這個時間間隔

270
00:16:00,071 --> 00:16:04,055
現在我們又介紹了這個short嘛 所以變成有三種了

271
00:16:04,055 --> 00:16:09,091
這三種 其實呢就是定義了802.11裡面

272
00:16:09,091 --> 00:16:13,041
最重要的所謂的priority的概念

273
00:16:13,041 --> 00:16:18,068
就是什麼叫做優先的優先概念呢 就是說 像short本身

274
00:16:18,068 --> 00:16:21,095
就是為什麼 你要回ACK 剛提到

275
00:16:21,095 --> 00:16:23,075
你回ACK一定要很快回

276
00:16:23,075 --> 00:16:27,045
就是你的時間間隔必須在一個short的時間之內

277
00:16:27,045 --> 00:16:33,011
那我如果回CTS呢 剛提到 CTS是回什麼呢

278
00:16:33,011 --> 00:16:39,055
是回RTS啊 就是我們送一個request to send 送過去

279
00:16:39,055 --> 00:16:45,025
那你要回一個所謂的clear to send 我們說

280
00:16:45,025 --> 00:16:46,091
這個clear to send

281
00:16:46,091 --> 00:16:54,005
你要回也必須在一個這個short的時間之內 就要回的意思

282
00:16:54,005 --> 00:16:57,078
如果你沒有回 他就那個送這個

283
00:16:57,078 --> 00:17:02,021
request to send的node 就認為他的RTS已經不見了

284
00:17:02,021 --> 00:17:04,041
沒有成功 他等一下就會重送

285
00:17:04,041 --> 00:17:08,085
也就是說RTS跟CTS這兩個封包出現的時間間隔

286
00:17:08,085 --> 00:17:11,071
只有這個short的inter frame space這麼短

287
00:17:11,071 --> 00:17:14,095
那你送data回ACK 送poll回ACK

288
00:17:14,095 --> 00:17:19,035
就是ACK 他們跟前面那個封包的時間呢 也是最短

289
00:17:19,035 --> 00:17:22,091
也是要最短 這是一個很重要的特色

290
00:17:22,091 --> 00:17:28,091
那第二個呢 我們就是 我們講在PCF的時候

291
00:17:28,091 --> 00:17:33,028
那他的時間間隔呢就稍微長一點點

292
00:17:33,028 --> 00:17:38,018
這個地方是說 在contention free的period

293
00:17:38,018 --> 00:17:40,028
在super frame裡面

294
00:17:40,028 --> 00:17:44,091
我們講一個super frame 前面的那一段叫做非競爭型的

295
00:17:44,091 --> 00:17:48,015
就是免競爭 在免競爭的時候

296
00:17:48,015 --> 00:17:50,038
我們這個封包的時間間隔呢

297
00:17:50,038 --> 00:17:55,018
稍微長一點點 那在所謂的競爭型的

298
00:17:55,018 --> 00:17:58,095
我們叫做asynchronous的這個MPDU

299
00:17:58,095 --> 00:18:01,085
在asynchronous 就是非同步的封包 大家去搶的時候呢

300
00:18:01,085 --> 00:18:08,091
那他的時間間隔呢 我們叫做DCF的IFS 叫DIFS呢

301
00:18:08,091 --> 00:18:12,071
他的時間就更長 所以我們現在有知道說

302
00:18:12,071 --> 00:18:18,081
不同的用途 他有不同的封包時間間隔

303
00:18:18,081 --> 00:18:22,015
那如果是在前面所講的這一塊

304
00:18:22,015 --> 00:18:25,015
變成說 只要是回ACK的

305
00:18:25,015 --> 00:18:30,008
或者回CTS的 他們的時間間隔呢是最短的

306
00:18:30,008 --> 00:18:35,095
那如果是在非競爭型的 他的時間間隔呢 稍微長一點

307
00:18:35,095 --> 00:18:38,048
這個叫所謂的第二個priority

308
00:18:38,048 --> 00:18:44,025
那如果是所謂的DIFS的話

309
00:18:44,025 --> 00:18:46,065
就是所謂的非同步競爭型的

310
00:18:46,065 --> 00:18:49,045
他的時間就等待的時間就更長了

311
00:18:49,045 --> 00:18:53,098
就等ACK 等CTS呢 等待時間呢 就我們講

312
00:18:53,098 --> 00:18:56,081
這個inter frame gap是很短 最短

313
00:18:56,081 --> 00:18:59,091
那在非競爭型的話呢 時間長一點

314
00:18:59,091 --> 00:19:02,045
在競爭型的話呢 時間就更長

315
00:19:02,045 --> 00:19:07,088
那等待的時間長短 就決定了說 他的優先的這個順序

316
00:19:07,088 --> 00:19:14,085
好 那我們說 在傳輸所謂的非同步之前

317
00:19:14,085 --> 00:19:17,065
剛提到等待時間 即使你等到了

318
00:19:17,065 --> 00:19:19,065
那後面還是要加上一個random back-off

319
00:19:19,065 --> 00:19:22,081
就是說 我們雖然等待那個長時間等到了

320
00:19:22,081 --> 00:19:26,058
等到了長時間 如果大家都等到這個長時間

321
00:19:26,058 --> 00:19:28,025
所謂的等到的意思就是說

322
00:19:28,025 --> 00:19:30,025
在這個長時間的時間間隔之內

323
00:19:30,025 --> 00:19:32,068
都沒有封包送出來 剛提到

324
00:19:32,068 --> 00:19:34,068
因為如果等的比較短 他就先送了

325
00:19:34,068 --> 00:19:38,055
那你這個等待就算失敗 你要等下一次再等

326
00:19:38,055 --> 00:19:42,025
如果你可以等到一個長時間 通通都沒有人送

327
00:19:42,025 --> 00:19:44,055
等那麼長的時間 從這邊開始等

328
00:19:44,055 --> 00:19:46,085
等一個長時間都沒有送

329
00:19:46,085 --> 00:19:49,051
中間有人送 就說等待失敗了

330
00:19:49,051 --> 00:19:52,045
如果你可以等待成功 到這個時間點

331
00:19:52,045 --> 00:19:55,021
好 那即使你等到了 你也不能馬上送

332
00:19:55,021 --> 00:19:57,035
你馬上送可能就跟人家造成collision了

333
00:19:57,035 --> 00:19:59,058
所以即使等到了那個時間

334
00:19:59,058 --> 00:20:02,031
後面還是要再加上一個random back-off

335
00:20:02,031 --> 00:20:04,038
那我們說 這個random back-off到底

336
00:20:04,038 --> 00:20:07,088
怎麼算他的back-off的時間呢

337
00:20:07,088 --> 00:20:10,065
我們就說 我們的back-off time

338
00:20:10,065 --> 00:20:14,091
back-off time就是說 那我們到底要這個後退多久的時間啦

339
00:20:14,091 --> 00:20:17,081
就是有一個叫做contention window

340
00:20:17,081 --> 00:20:19,081
等一下會跟各位介紹

341
00:20:19,081 --> 00:20:23,051
contention window就是一個 反正就是一個範圍的值

342
00:20:23,051 --> 00:20:26,031
然後乘上一個random number 亂數

343
00:20:26,031 --> 00:20:29,005
一定會有一個亂數 因為這樣才有辦法錯開來

344
00:20:29,005 --> 00:20:30,085
然後乘上一個slow time

345
00:20:30,085 --> 00:20:36,001
slow time 我們在802.3 在ethernet裡面

346
00:20:36,001 --> 00:20:39,015
CSMA/CD裡面 我們一個slow time

347
00:20:39,015 --> 00:20:42,085
是一個網路最常的兩端來回的時間

348
00:20:42,085 --> 00:20:48,018
在802.3裡面 一個slow time就通常就是51.2µs

349
00:20:48,018 --> 00:20:50,038
就是來回最長的時間 好

350
00:20:50,038 --> 00:20:54,095
那在802.11 在我們這個wifi這裡面呢

351
00:20:54,095 --> 00:20:57,068
我們的slow time又怎麼算呢？

352
00:20:57,068 --> 00:20:59,025
我們的slow time是這樣子算的

353
00:20:59,025 --> 00:21:03,055
就是transmitter turn-on的時間 delay

354
00:21:03,055 --> 00:21:06,021
加上我們的medium propagation delay

355
00:21:06,021 --> 00:21:09,048
就是在無線的這個space空氣上面

356
00:21:09,048 --> 00:21:12,061
傳送的這個delay 然後加上說

357
00:21:12,061 --> 00:21:16,095
我可能要偵測這個medium是不是busy的一個response time

358
00:21:16,095 --> 00:21:22,001
這個叫一個slow time 那我們剛提到說

359
00:21:22,001 --> 00:21:24,091
那我的這個contention window到底怎麼算呢？

360
00:21:24,091 --> 00:21:27,018
contention window就是說

361
00:21:27,018 --> 00:21:34,038
我們看你這個封包呢 現在是第一次嘗試送

362
00:21:34,038 --> 00:21:38,071
還是說是第二次嘗送 還是第三次嘗試

363
00:21:38,071 --> 00:21:42,018
也就是說 你可能會重送 就如果萬一你的封包

364
00:21:42,018 --> 00:21:45,051
曾經送過一次 可是沒有收到ACK

365
00:21:45,051 --> 00:21:46,075
我們特別注意到

366
00:21:46,075 --> 00:21:50,078
因為在無線網路裡面是沒有辦法偵測collision

367
00:21:50,078 --> 00:21:53,071
所以我們是不知道有沒有collision的 但是呢

368
00:21:53,071 --> 00:21:55,051
我們從你有沒有收到ACK

369
00:21:55,051 --> 00:21:58,001
來決定你的封包是不是成功還失敗

370
00:21:58,001 --> 00:22:00,051
也就是說這個封包 你手上要送的

371
00:22:00,051 --> 00:22:04,035
第一次傳送 就是這個 你是第一次送嘛

372
00:22:04,035 --> 00:22:08,005
所以我們說 這個CW contention window值就是7

373
00:22:08,005 --> 00:22:12,031
如果回到前面這邊來就是說 這個值呢 第一次送的話

374
00:22:12,031 --> 00:22:15,025
他就是用第一次初始值

375
00:22:15,025 --> 00:22:18,081
相當於這個就是用7來傳輸

376
00:22:18,081 --> 00:22:26,005
那如果說妳現在這個封包要送的呢 是第一次要重送的

377
00:22:26,005 --> 00:22:29,041
代表說你之前送過一次 可是沒有收到ACK

378
00:22:29,041 --> 00:22:32,058
好 接下來你要第二次重送 但是第二次重送

379
00:22:32,058 --> 00:22:35,005
你還是要follow剛剛講的那個過程喔

380
00:22:35,005 --> 00:22:37,098
先等到這個譬如說他是idle

381
00:22:37,098 --> 00:22:41,055
等待一個時間 然後再來產生那個random time

382
00:22:41,055 --> 00:22:44,035
就是說如果是你第二次要傳輸的話

383
00:22:44,035 --> 00:22:48,048
代表說你之前曾經送過一次呢 可是沒有成功

384
00:22:48,048 --> 00:22:51,005
那就代表說 那你現在要送的話

385
00:22:51,005 --> 00:22:54,078
可能就應該稍微等稍微久一點啦

386
00:22:54,078 --> 00:22:57,028
所以我們如果是第二次傳送的話

387
00:22:57,028 --> 00:23:00,025
我們的這個等待時間會長一點

388
00:23:00,025 --> 00:23:08,001
我們就用所謂的這個15來作為這個 所謂的CW的值

389
00:23:08,001 --> 00:23:10,055
這是第二次傳輸的時候用15

390
00:23:10,055 --> 00:23:14,018
那如果是 第二次重送呢用31

391
00:23:14,018 --> 00:23:19,045
第三次傳送用63 然後127 然後最後最多是255

392
00:23:19,045 --> 00:23:21,035
所以這個值最主要是

393
00:23:21,035 --> 00:23:27,045
讓我們如果說這個封包重送的次數越多

394
00:23:27,045 --> 00:23:30,098
通常就代表說 這個網路呢是越壅擠

395
00:23:30,098 --> 00:23:34,085
那我們那個整個可能要delay的時間呢

396
00:23:34,085 --> 00:23:38,098
就要長一點 所以我們剛看到說 如果呢

397
00:23:38,098 --> 00:23:44,061
我們現在網路的狀況越嚴重 就是越擁擠

398
00:23:44,061 --> 00:23:47,075
然後你重送的次數比較多的話

399
00:23:47,075 --> 00:23:53,095
那這個數字會從7 可能跑到剛剛講的255

400
00:23:53,095 --> 00:23:58,018
然後一樣 產生一個random time乘上一個slow time

401
00:23:58,018 --> 00:24:02,091
就是如果撞得越嚴重 或者是說網路越擁擠

402
00:24:02,091 --> 00:24:06,058
我們這個random back-off的時間可能就會長一點

403
00:24:06,058 --> 00:24:10,048
那如果說網路現在其實也沒有很擁擠

404
00:24:10,048 --> 00:24:15,061
第一次送這個封包的話 那我們說

405
00:24:15,061 --> 00:24:19,095
第一次送封包我們就用7就可以了 那第二次呢

406
00:24:19,095 --> 00:24:23,025
重送我們就用15 再來用31

407
00:24:23,025 --> 00:24:26,018
每次重送呢 就有點是double啦

408
00:24:26,018 --> 00:24:31,011
就在等於說 兩倍兩倍兩倍這樣子加

409
00:24:31,011 --> 00:24:34,035
那我算出一個這個back-off time

410
00:24:34,035 --> 00:24:36,038
接下來我們後面再來介紹說

411
00:24:36,038 --> 00:24:39,028
好 當你每次要送的時候 剛提到

412
00:24:39,028 --> 00:24:43,035
先看這個channel 如果他是busy 等他變idle

413
00:24:43,035 --> 00:24:46,098
然後等待一個時間 時間到了時候呢

414
00:24:46,098 --> 00:24:50,035
產生一個 所謂的random back-off time

415
00:24:50,035 --> 00:24:54,065
這個時間產生之後呢 我們就要等待一段時間

416
00:24:54,065 --> 00:24:57,021
就等這個random time 等到時間到了

417
00:24:57,021 --> 00:24:58,088
你才能送出去嘛

418
00:24:58,088 --> 00:25:02,095
最重要是在這裡 就是說封包你從busy變成idle

419
00:25:02,095 --> 00:25:04,021
你要等一段時間喔

420
00:25:04,021 --> 00:25:08,038
等到時間之後在這個地方產生一個random time

421
00:25:08,038 --> 00:25:09,071
random back-off time

422
00:25:09,071 --> 00:25:11,045
這個時間產生出來之後

423
00:25:11,045 --> 00:25:14,085
等下還要繼續等這個所謂的等待時間

424
00:25:14,085 --> 00:25:18,011
等待時間到的時候才能送

425
00:25:18,011 --> 00:25:20,048
那我們等下就來介紹說

426
00:25:20,048 --> 00:25:22,058
這個時間到底怎麼等待

427
00:25:22,058 --> 00:25:24,091
阿這個時間怎麼算出來

428
00:25:24,091 --> 00:25:26,091


