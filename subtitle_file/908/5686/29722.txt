1
00:00:08,088 --> 00:00:14,098
我們說這個802.11的這個protocol 叫做CSMA/CA

2
00:00:14,098 --> 00:00:17,001
我們盡量來避免collision

3
00:00:17,001 --> 00:00:19,078
那他的主要的idea就是說

4
00:00:19,078 --> 00:00:22,001
我如果把封包丟出去

5
00:00:22,001 --> 00:00:25,038
那可能發生collision 但是我也不知道

6
00:00:25,038 --> 00:00:27,045
那這個對我來講來還是有點麻煩

7
00:00:27,045 --> 00:00:29,051
所以我們的做法就是說

8
00:00:29,051 --> 00:00:32,051
在送真正的封包之前

9
00:00:32,051 --> 00:00:36,048
我們先送一個叫做所謂的control frame

10
00:00:36,048 --> 00:00:39,041
就是說我在送真正的封包之前

11
00:00:39,041 --> 00:00:43,098
我先跟我的目的地 譬如說A要送給B

12
00:00:43,098 --> 00:00:47,025
A就先送一個 一個所謂的control frame

13
00:00:47,025 --> 00:00:51,025
我們叫做request to send RTS

14
00:00:51,025 --> 00:00:54,001
就代表說 我要送封包出去了

15
00:00:54,001 --> 00:00:59,061
告訴那個我的傳輸範圍內的這些其他的node說

16
00:00:59,061 --> 00:01:06,021
我要送一個封包出去了 那對方如果收到了這個RTS呢

17
00:01:06,021 --> 00:01:12,021
他要回一個叫做clear to send 代表說 我已經清空了

18
00:01:12,021 --> 00:01:14,078
我等著收這個封包

19
00:01:14,078 --> 00:01:18,091
也就是說送封包的先送一個request to send出去

20
00:01:18,091 --> 00:01:20,091
做一個宣告 說我要送一個封包

21
00:01:20,091 --> 00:01:27,008
那接收的這一端 也送一個封包出去說 告訴周邊的node說

22
00:01:27,008 --> 00:01:29,021
我等一下要收一個封包

23
00:01:29,021 --> 00:01:31,095
一個是說我等一下要送一個封包

24
00:01:31,095 --> 00:01:34,045
一個是說我等一下要收一個封包

25
00:01:34,045 --> 00:01:39,071
啊這個我等一下要送封包或等下要收封包 這個都是廣播

26
00:01:39,071 --> 00:01:43,028
他會告訴周邊的node 就跟他說我等一下要做一件事

27
00:01:43,028 --> 00:01:45,051
就是我這邊等一下要送封包

28
00:01:45,051 --> 00:01:47,078
我這邊等一下要收封包

29
00:01:47,078 --> 00:01:50,065
然後這個交換的封包裡面

30
00:01:50,065 --> 00:01:53,065
還有一個很重要的資訊就是說

31
00:01:53,065 --> 00:01:55,081
我等一下封包要送多久

32
00:01:55,081 --> 00:01:57,068
就是說 再講一遍

33
00:01:57,068 --> 00:02:01,078
送的人說 我等一下要送一個封包 我要送多久

34
00:02:01,078 --> 00:02:03,095
多久是不是看我們封包的長度嘛

35
00:02:03,095 --> 00:02:05,085
還有跟我們網路的速度

36
00:02:05,085 --> 00:02:07,085
譬如說可能要送100ms

37
00:02:07,085 --> 00:02:11,028
然後接受這一端 他就告訴旁邊的人說

38
00:02:11,028 --> 00:02:14,078
我等一下要收封包 我要收100ms

39
00:02:14,078 --> 00:02:18,075
所以他就告訴周邊的node說 等一下不要來鬧

40
00:02:18,075 --> 00:02:21,068
因為我等一下要送封包 等一下要收封包

41
00:02:21,068 --> 00:02:26,045
而且要送多久要收多久 聽到這樣子宣告的node呢

42
00:02:26,045 --> 00:02:31,021
你等一下在這個時間之內 你千萬不要送封包出來

43
00:02:31,021 --> 00:02:32,081
免得跟我撞在一起

44
00:02:32,081 --> 00:02:35,028
因為我們有hidden terminal的問題嘛

45
00:02:35,028 --> 00:02:37,075
就是說 我那聽不到對方

46
00:02:37,075 --> 00:02:40,028
但是我送出去可能會把它打掉啊

47
00:02:40,028 --> 00:02:44,008
所以我們就變成說 在真正送data之前

48
00:02:44,008 --> 00:02:47,011
先送一個類似宣告的意思啦 就是說

49
00:02:47,011 --> 00:02:49,058
我等一下要送一個封包 要用多久的時間

50
00:02:49,058 --> 00:02:51,015
那接收這一端說

51
00:02:51,015 --> 00:02:54,078
我等一下要收一個封包 要收多久的時間

52
00:02:54,078 --> 00:02:57,065
然後這個兩個一告訴周邊的node之後呢

53
00:02:57,065 --> 00:03:00,001
好 我再開始送封包

54
00:03:00,001 --> 00:03:05,025
那這個時候送的封包基本上就不會發生collision

55
00:03:05,025 --> 00:03:09,011
就我可以讓這個傳送呢就比較順利

56
00:03:09,011 --> 00:03:12,021
所以我們說 我們叫做collision avoidance

57
00:03:12,021 --> 00:03:13,095
就是我盡量避免collision

58
00:03:13,095 --> 00:03:17,051
我避免的方式就是在送封包之前

59
00:03:17,051 --> 00:03:19,001
我先告訴大家說

60
00:03:19,001 --> 00:03:20,091
我等一下要送封包 我等一下要收封包

61
00:03:20,091 --> 00:03:24,071
啊你們千萬不要來鬧我 類似這樣的概念

62
00:03:24,071 --> 00:03:27,038
那什麼意思呢 我們用一個例子來說明

63
00:03:27,038 --> 00:03:31,051
就是說我們假設現在有兩個station

64
00:03:31,051 --> 00:03:34,048
一個是B 一個是C

65
00:03:34,048 --> 00:03:37,001
啊我們知道這個圈圈 像這個圈圈

66
00:03:37,001 --> 00:03:40,008
這是B B所涵蓋的範圍啦

67
00:03:40,008 --> 00:03:44,071
那這個圈圈呢 是C所涵蓋的範圍

68
00:03:44,071 --> 00:03:47,018
因為這是他的範圍 C所涵蓋的範圍

69
00:03:47,018 --> 00:03:52,025
我們假設就是B跟C 這是我們現在的主角

70
00:03:52,025 --> 00:03:55,015
我們來看 就是說 好

71
00:03:55,015 --> 00:03:58,018
現在假設B要送一個封包給C

72
00:03:58,018 --> 00:04:02,041
那注意到 他就會送這個叫做request to send

73
00:04:02,041 --> 00:04:05,078
他會說 我要送封包 注意到

74
00:04:05,078 --> 00:04:09,035
他會丟一個 先送一個叫做request to send

75
00:04:09,035 --> 00:04:13,018
的這個control frame 短短的 告訴周邊的人說

76
00:04:13,018 --> 00:04:15,098
我等一下要送一個封包出去

77
00:04:15,098 --> 00:04:19,095
所以注意到 現在我們這個灰色的這個圈圈呢

78
00:04:19,095 --> 00:04:24,005
就是B他送出去所涵蓋的範圍

79
00:04:24,005 --> 00:04:28,008
在這個範圍裡面的 那些小圈 小圓點

80
00:04:28,008 --> 00:04:30,078
就是其他的node 他們就聽到了

81
00:04:30,078 --> 00:04:34,031
等一下B要送一個封包 好

82
00:04:34,031 --> 00:04:38,045
那這個request to send呢就送給這個C嘛

83
00:04:38,045 --> 00:04:43,001
等於說這個就送給這個C 然後 C就要回一個

84
00:04:43,001 --> 00:04:46,008
等於說剛剛是送給C request to send

85
00:04:46,008 --> 00:04:49,001
接下來C就要回一個clear to send

86
00:04:49,001 --> 00:04:52,011
我們注意到 這個clear to send怎麼送呢

87
00:04:52,011 --> 00:04:55,065
一樣 C呢就回一個clear to send

88
00:04:55,065 --> 00:05:01,048
那這個藍色的圈圈呢 就是C所覆蓋的範圍

89
00:05:01,048 --> 00:05:04,011
那在這個範圍裡面的每一個node

90
00:05:04,011 --> 00:05:06,055
就聽到的clear to send

91
00:05:06,055 --> 00:05:09,061
所以我們知道現在有顏色覆蓋的

92
00:05:09,061 --> 00:05:12,041
灰色的是聽到request to send

93
00:05:12,041 --> 00:05:15,041
藍色的是聽到clear to send

94
00:05:15,041 --> 00:05:19,058
所以在這中間的 像這個node呢

95
00:05:19,058 --> 00:05:22,078
這個node是 這個喔 sorry

96
00:05:22,078 --> 00:05:26,061
中間這個node呢 他是聽到clear to send

97
00:05:26,061 --> 00:05:28,038
也聽到request to send

98
00:05:28,038 --> 00:05:31,068
這個node比較特別啦 因為他在兩個中間

99
00:05:31,068 --> 00:05:35,021
他兩個都聽到 那在這個node呢

100
00:05:35,021 --> 00:05:37,078
她只聽到request to send

101
00:05:37,078 --> 00:05:39,095
這個node只聽到request to send

102
00:05:39,095 --> 00:05:44,028
這個node呢只聽到clear to send

103
00:05:44,028 --> 00:05:48,065
他們都聽到clear to send 就是說在藍色的這個圈圈裡面呢

104
00:05:48,065 --> 00:05:53,011
都只聽到clear to send 然後在灰色的圈圈裡面呢

105
00:05:53,011 --> 00:05:55,011
聽到的是request to send

106
00:05:55,011 --> 00:06:00,011
那我們說 這個request to send跟clear to send裡面呢

107
00:06:00,011 --> 00:06:03,028
這個雖然是一個短短的control的frame

108
00:06:03,028 --> 00:06:06,048
但是裡面呢 他放了一個叫做duration

109
00:06:06,048 --> 00:06:10,065
duration field 就是說 等一下要用多久

110
00:06:10,065 --> 00:06:13,008
這個會在這邊宣告

111
00:06:13,008 --> 00:06:15,045
好所以我們特別注意到 這個

112
00:06:15,045 --> 00:06:18,001
像這樣這個聽到這個clear to send

113
00:06:18,001 --> 00:06:22,021
好 那就是紅色的這幾個點 他們等一下呢

114
00:06:22,021 --> 00:06:28,018
就不能送封包 因為剛剛B說他要送一個封包給C

115
00:06:28,018 --> 00:06:32,041
大概用多久的時間 這些node呢就不可以

116
00:06:32,041 --> 00:06:34,008
因為這些node送的時候呢

117
00:06:34,008 --> 00:06:36,021
如果這些node送給C的話

118
00:06:36,021 --> 00:06:38,085
就會撞在一起了 注意到

119
00:06:38,085 --> 00:06:40,045
我們的hidden node的問題

120
00:06:40,045 --> 00:06:44,045
就是說如果B送給C 而其他的node

121
00:06:44,045 --> 00:06:47,005
譬如說這個node如果他也送給C的話

122
00:06:48,005 --> 00:06:52,071
那他們就會在C撞在一起 而注意到

123
00:06:52,071 --> 00:06:57,011
這些node 跟B他們之間是什麼？

124
00:06:57,011 --> 00:07:01,015
這兩個node之間 他們就是hidden terminal

125
00:07:01,015 --> 00:07:03,091
譬如說這個node 假如這個 我們講這個node

126
00:07:03,091 --> 00:07:08,081
假設他叫做D好了 B跟D互相聽不到

127
00:07:08,081 --> 00:07:14,058
因為D是在B的範圍之外 就B跟D互相聽不到

128
00:07:14,058 --> 00:07:18,025
可是如果他們同時送給C 他就會collision

129
00:07:18,025 --> 00:07:21,065
這就剛剛講的 所謂hidden terminal的問題

130
00:07:21,065 --> 00:07:25,008
就是 D聽不到B

131
00:07:25,008 --> 00:07:29,025
但是如果他們同時送給C 他就會collision

132
00:07:29,025 --> 00:07:33,035
也就是說 C送這個clear to send

133
00:07:33,035 --> 00:07:34,098
是有很特別的意義喔

134
00:07:34,098 --> 00:07:37,065
就是說所有聽到clear to send的node

135
00:07:37,065 --> 00:07:41,021
就是這個紅色的node 等一下都不能送給C

136
00:07:41,021 --> 00:07:43,018
因為B要送給C

137
00:07:43,018 --> 00:07:47,048
這些紅色的node如果也送給C 就會collision

138
00:07:47,048 --> 00:07:52,028
那為什麼是紅色的node呢 因為只有這些紅色的node呢

139
00:07:52,028 --> 00:07:55,028
他聽到了clear to send

140
00:07:55,028 --> 00:07:57,028
為什麼他聽得到clear to send

141
00:07:57,028 --> 00:08:00,041
因為他在C的範圍之內 就是B要送給C

142
00:08:00,041 --> 00:08:04,078
C告訴周邊的人說 你們等一下千萬不要送給我

143
00:08:04,078 --> 00:08:08,051
不要送給我 送給別人可以 千萬不要送給我

144
00:08:08,051 --> 00:08:11,088
因為我等一下要收B過來的封包

145
00:08:11,088 --> 00:08:15,031
所以在這個C所涵蓋範圍之內的其他node

146
00:08:15,031 --> 00:08:17,025
等一下千萬不要送給我

147
00:08:17,025 --> 00:08:21,051
要不然的話你的封包就會跟B撞在一起

148
00:08:21,051 --> 00:08:26,031
所以這個很特別就是說 一個request to send給C

149
00:08:26,031 --> 00:08:28,068
那C回一個clear to send

150
00:08:28,068 --> 00:08:31,025
這個clear to send所涵蓋的node

151
00:08:31,025 --> 00:08:33,038
像這個例子是紅色的5個node

152
00:08:33,038 --> 00:08:35,075
等一下這5個node都不可以送

153
00:08:35,075 --> 00:08:38,045
其他的node呢 通通可以送

154
00:08:38,045 --> 00:08:40,061
其他node不影響 都不影響

155
00:08:40,061 --> 00:08:42,051
為什麼就是因為剛剛提到

156
00:08:42,051 --> 00:08:46,011
當我等一下B送給C的時候呢

157
00:08:46,011 --> 00:08:50,048
好 有哪些node傳輸會跟這個撞在一起

158
00:08:50,048 --> 00:08:54,075
只有這5個node送給C的時候會撞在一起

159
00:08:54,075 --> 00:08:57,091
那我如果說 那我這5個node我如果送給別人呢

160
00:08:57,091 --> 00:09:01,005
譬如說我送給別人 送給別人就送給別人啊

161
00:09:01,005 --> 00:09:04,075
跟我沒關係啊 你只要不是送給C就不會跟我撞在一起啊

162
00:09:04,075 --> 00:09:07,015
那我聽到clear to send

163
00:09:07,015 --> 00:09:09,041
譬如說我這個地方可不可以送給別人

164
00:09:09,041 --> 00:09:11,075
對不起 聽到request to send啦

165
00:09:11,075 --> 00:09:13,011
這個地方可不可以送給別人

166
00:09:13,011 --> 00:09:16,091
我可不可以這樣送 通通可以 歡迎你

167
00:09:16,091 --> 00:09:21,088
就是說 當B要送給C的時候 只有這

168
00:09:21,088 --> 00:09:25,055
注意到 只有這5個聽到clear to send

169
00:09:25,055 --> 00:09:29,068
的這5個node 他不可以送給C

170
00:09:29,068 --> 00:09:33,081
他可以送給別人 那其他聽到request to send

171
00:09:33,081 --> 00:09:35,078
也一樣 你要送給誰都可以

172
00:09:35,078 --> 00:09:42,031
所以最重要最重要的就是 聽到clear to send的這5個node

173
00:09:42,031 --> 00:09:47,025
這5個node 等一下千萬千萬不要送給C

174
00:09:47,025 --> 00:09:49,025
要不然他就會發生collision

175
00:09:49,025 --> 00:09:51,038
otherwise都可以

176
00:09:51,038 --> 00:09:52,028
那這個就是

177
00:09:52,028 --> 00:09:56,045
我們用了request to send跟clear to send來解這個問題啦

178
00:09:56,045 --> 00:09:58,041
我們說假設呢 我們講

179
00:09:58,041 --> 00:10:04,035
任何node他如果看到了這個request to send

180
00:10:04,035 --> 00:10:08,035
就剛剛那個藍色的圈圈所涵蓋的node

181
00:10:08,035 --> 00:10:12,098
就代表說他非常靠近這個receiver 靠近C

182
00:10:12,098 --> 00:10:16,038
因為他聽到clear to send

183
00:10:16,038 --> 00:10:18,001
clear to send是C送出來的嘛

184
00:10:18,001 --> 00:10:19,085
他如果聽得的到 就代表他

185
00:10:19,085 --> 00:10:24,028
在那個C的覆蓋範圍之內 他很靠近C

186
00:10:24,028 --> 00:10:28,085
等一下 在那個時間之內 我們講那個所謂的period

187
00:10:28,085 --> 00:10:33,028
在那個時間之內 你絕對不可以傳送給C

188
00:10:33,028 --> 00:10:35,075
要不然他就會造成collision

189
00:10:35,075 --> 00:10:40,068
那我們說任何node 如果她看到了request to send

190
00:10:40,068 --> 00:10:44,001
就是一開始送的那個request to send的話

191
00:10:44,001 --> 00:10:47,021
但是沒有聽到clear to send

192
00:10:47,021 --> 00:10:50,098
就代表在那個灰色的這個覆蓋範圍裡面

193
00:10:50,098 --> 00:10:53,095
他收到request to send沒有收到clear to send

194
00:10:53,095 --> 00:11:01,075
這代表說他跟這個C呢是比較遠的 那他並沒有很靠近

195
00:11:01,075 --> 00:11:04,088
所以也不會造成interference 所以他可以呢

196
00:11:04,088 --> 00:11:06,061
我們講free to transmit

197
00:11:06,061 --> 00:11:09,085
他可以反正自由的傳輸的意思

198
00:11:09,085 --> 00:11:13,081
好也就是說 那雖然是這樣子

199
00:11:13,081 --> 00:11:17,068
就是說我們說 我們用request to send跟clear to send

200
00:11:17,068 --> 00:11:22,081
來做一個所謂的collision avoidance的機制嘛

201
00:11:22,081 --> 00:11:26,031
就是說我在真正的送我的封包 我的封包可能很長

202
00:11:26,031 --> 00:11:29,055
我在真正的送封包之前 我先送一個很短短的

203
00:11:29,055 --> 00:11:32,041
就request to send, clear to send做一個宣告

204
00:11:32,041 --> 00:11:35,005
啊這一圈這一圈 這兩個人一圈畫下來

205
00:11:35,005 --> 00:11:36,085
就知道誰可以送誰不可以送

206
00:11:36,085 --> 00:11:38,061
不要來干擾不要來鬧

207
00:11:38,061 --> 00:11:44,031
好 但是針對這個RTS呢 我們講request to send呢

208
00:11:44,031 --> 00:11:49,025
他倒是本身就是一個問題 因為送RTS這個時候

209
00:11:49,025 --> 00:11:52,065
本能就有可能造成collision 譬如剛剛提到講

210
00:11:52,065 --> 00:11:55,095
我們是B要送給C嘛 假設有另外一個D

211
00:11:55,095 --> 00:11:59,055
他在C的範圍之內 假設他也想送給C

212
00:11:59,055 --> 00:12:02,065
就是這兩個 假設有兩個工作站

213
00:12:02,065 --> 00:12:06,071
他們都同時送出request to send

214
00:12:06,071 --> 00:12:10,018
同時 送給一個共同的這個目的地

215
00:12:10,018 --> 00:12:12,045
那這兩個request to send

216
00:12:12,045 --> 00:12:15,011
就會在那個C就發生collision

217
00:12:15,011 --> 00:12:17,085
我們剛剛提到 B要送給C

218
00:12:17,085 --> 00:12:23,068
我們回到前面這邊來看 假設 我們講 sorry

219
00:12:23,068 --> 00:12:28,018
假設這個B要送給C 他會送一個request to send

220
00:12:28,018 --> 00:12:30,091
假設這個node 他也送給C

221
00:12:30,091 --> 00:12:33,031
那他也送一個 等於說這兩個node

222
00:12:33,031 --> 00:12:36,085
假如這個node是B好了 就是B跟D

223
00:12:36,085 --> 00:12:41,018
他們假設都同時送RTS

224
00:12:41,018 --> 00:12:44,035
因為B跟C反正他們彼此也聽不到對方嘛

225
00:12:44,035 --> 00:12:47,091
所以他們 就有可能同時送RTS啊

226
00:12:47,091 --> 00:12:52,051
所以他們的RTS呢 就會在C這個地方就發生collision了

227
00:12:52,051 --> 00:12:56,068
就RTS本身就會撞在一起 這是絕對有可能的

228
00:12:56,068 --> 00:13:01,065
那我們就說 如果呢 有兩個或兩個以上的node

229
00:13:01,065 --> 00:13:07,035
他發現這個link呢是idle的 他也是要先聽啦

230
00:13:07,035 --> 00:13:11,061
如果是idle的話 那他們就送的request to send

231
00:13:11,061 --> 00:13:14,011
同一個時間送 那這個request to send

232
00:13:14,011 --> 00:13:17,018
可能就會互相就撞在一起了

233
00:13:17,018 --> 00:13:22,045
那撞在一起的話 這個RTS封包就毀掉了

234
00:13:22,045 --> 00:13:25,048
啊結果是怎麼樣  就是說兩個封包

235
00:13:25,048 --> 00:13:28,075
對不起 兩個node同時送request to send

236
00:13:28,075 --> 00:13:31,091
啊結果這個撞在一起 結果呢

237
00:13:31,091 --> 00:13:35,041
結果就是說 他怎麼知道發生collision呢

238
00:13:35,041 --> 00:13:39,055
因為我們剛剛提到是說 在無線網路裡面

239
00:13:39,055 --> 00:13:41,075
我們根本沒有辦法知道有發生collision

240
00:13:41,075 --> 00:13:43,091
可是這個封包就是撞在一起

241
00:13:43,091 --> 00:13:46,018
那可是我們送的人又不知道

242
00:13:46,018 --> 00:13:51,068
還好我們的機制是說 送一個RTS一定要回一個CTS

243
00:13:51,068 --> 00:13:54,031
就request to send一定對應一個clear to send

244
00:13:54,031 --> 00:13:58,088
也就是如果這個request to send呢 他發生了collision

245
00:13:58,088 --> 00:14:02,071
那我們就是說 那你就收不到這個clear to send

246
00:14:02,071 --> 00:14:05,021
你就收不到clear to send

247
00:14:05,021 --> 00:14:07,071
因為你的request to send呢撞在一起了

248
00:14:07,071 --> 00:14:10,061
所以你會等不到一個所謂的

249
00:14:10,061 --> 00:14:12,061
clear to send這個封包 等不到

250
00:14:12,061 --> 00:14:17,051
那等不到的話怎麼辦 沒關係 等不到的時候呢

251
00:14:17,051 --> 00:14:22,048
我們就說我們就等待 等一個random

252
00:14:22,048 --> 00:14:26,071
wait a random time 然後try again

253
00:14:26,071 --> 00:14:29,091
就是我送一個RTS出去

254
00:14:29,091 --> 00:14:33,048
我suppose要等一個CTS回來

255
00:14:33,048 --> 00:14:38,005
但是呢 我這個RTS呢也可能跟人家撞在一起了

256
00:14:38,005 --> 00:14:40,001
所以CTS就沒有回來

257
00:14:40,001 --> 00:14:43,001
那沒有回來的話我就等待一段時間

258
00:14:43,001 --> 00:14:46,028
我再送一次request to send

259
00:14:46,028 --> 00:14:50,038
我再等待一段時間 好那這個到底要等待多久呢

260
00:14:50,038 --> 00:14:52,095
其實他的idea就跟我們在講

261
00:14:52,095 --> 00:14:55,068
介紹ethernet的時候是相同的

262
00:14:55,068 --> 00:14:59,011
他會用exponential back-off的algorithm

263
00:14:59,011 --> 00:15:01,061
exponential back-off又出來了

264
00:15:01,061 --> 00:15:04,028
就是說我如果這次送request to send

265
00:15:04,028 --> 00:15:08,095
結果等不到CTS 我就等待一個random

266
00:15:08,095 --> 00:15:11,081
一開始的時候等一個比較小的random time

267
00:15:11,081 --> 00:15:14,031
那我等到的時候呢 我再送

268
00:15:14,031 --> 00:15:17,005
所謂的request to send出去 第二次

269
00:15:17,005 --> 00:15:21,031
那萬一又撞掉了 我又沒有收到clear to send

270
00:15:21,031 --> 00:15:26,011
我一樣 我再等 就是說你這個RTS送出去

271
00:15:26,011 --> 00:15:29,041
沒有等到CTS 就代表collision

272
00:15:29,041 --> 00:15:36,025
那連續這個次數越多 那我等待的時間就越久

273
00:15:36,025 --> 00:15:39,011
就我們所謂exponential back-off algorithm

274
00:15:39,011 --> 00:15:41,048
又再用一次的意思啦

275
00:15:41,048 --> 00:15:45,051
好那我們說 因為802.11呢

276
00:15:45,051 --> 00:15:47,051
沒有support collision detection

277
00:15:47,051 --> 00:15:51,025
這是一個非常非常重要的觀念

278
00:15:51,025 --> 00:15:55,091
就是說802.11沒有support collision detection的技術

279
00:15:55,091 --> 00:15:58,085
所以我們不知道封包到底有沒有發生collision

280
00:15:58,085 --> 00:16:02,038
好 那我們就說 那如果我們沒有辦法知道

281
00:16:02,038 --> 00:16:05,075
我們送出去的封包有沒有發生collision

282
00:16:05,075 --> 00:16:08,028
雖然有啦 只是我們沒有辦法知道嘛

283
00:16:08,028 --> 00:16:11,045
那我們說 那我們到底怎麼知道

284
00:16:11,045 --> 00:16:14,015
我們丟出去的封包到底是成功還是失敗

285
00:16:14,015 --> 00:16:16,055
到底對方有沒有成功收到呢

286
00:16:16,055 --> 00:16:19,085
他可能發生collision 可能是成功收到

287
00:16:19,085 --> 00:16:23,078
那到底是怎麼樣呢 我們不知道啊

288
00:16:23,078 --> 00:16:27,061
那我們也可以說 我們也可以用最簡單的

289
00:16:27,061 --> 00:16:31,061
所謂的CSMA的protocol 我們之前也介紹過嘛

290
00:16:31,061 --> 00:16:36,021
CSMA就是說我只做carrier sense multiple access

291
00:16:36,021 --> 00:16:39,088
就是說我聽聽看 idle我就送 busy我就等

292
00:16:39,088 --> 00:16:43,008
那我送出去我就把封包全部丟出去

293
00:16:43,008 --> 00:16:45,068
中間發生collision我也不管

294
00:16:45,068 --> 00:16:50,008
那我們知道CSMA也是非常有名的方法 但是呢

295
00:16:50,008 --> 00:16:52,095
他的效能會比較差 好

296
00:16:52,095 --> 00:16:56,058
那我們說呢 802.11呢 他用了一個技巧

297
00:16:56,058 --> 00:16:58,035
就叫做ACK

298
00:16:58,035 --> 00:17:00,055
ACK 這是非常非常關鍵的 就是說

299
00:17:00,055 --> 00:17:06,011
我既然不知道我們有送出去的封包有沒有發生collision

300
00:17:06,011 --> 00:17:10,018
但是我要求 如果對方成功的收到

301
00:17:10,018 --> 00:17:12,088
他要回給我一個ACK frame

302
00:17:12,088 --> 00:17:17,078
就是要清清楚楚地告訴我 他有沒有成功收到

303
00:17:17,078 --> 00:17:23,018
如果對方正確的收到 他一定要回我一個ACK

304
00:17:23,018 --> 00:17:26,055
一個也是control frame 告訴我說他收到了

305
00:17:26,055 --> 00:17:30,081
也就是說我們在802.11裡面是有這樣的設計

306
00:17:30,081 --> 00:17:34,008
就是說如果receiver呢他成功收到的話

307
00:17:34,008 --> 00:17:39,038
他就一定會回一個ACK 那也就是說其他的工作站

308
00:17:39,038 --> 00:17:41,088
看到一個封包在傳送的時候呢

309
00:17:41,088 --> 00:17:44,015
他一定要期待一個ACK回來

310
00:17:44,015 --> 00:17:47,055
如果這個ACK沒有被送回來 就假設

311
00:17:47,055 --> 00:17:49,071
就這個封包 他是什麼 就是壞掉了

312
00:17:49,071 --> 00:17:53,085
就是說我們怎麼知道一個封包是成功的送給對方呢

313
00:17:53,085 --> 00:17:57,095
最簡單的做法就是那好 那我就等對方的ACK

314
00:17:57,095 --> 00:18:02,055
對方如果成功收到這個封包的話 他一定要回給我一個ACK

315
00:18:02,055 --> 00:18:05,095
好 所以我們看一下 在802.11裡面

316
00:18:05,095 --> 00:18:09,008
我們的封包的格式呢 就有這幾類

317
00:18:09,008 --> 00:18:12,001
我們簡單的看過一個

318
00:18:12,001 --> 00:18:14,051
像request to send剛剛已經介紹過了

319
00:18:14,051 --> 00:18:18,008
還有clear to send 這兩個 這兩個非常非常重要

320
00:18:18,008 --> 00:18:20,095
就是我們在送正式的封包之前

321
00:18:20,095 --> 00:18:23,008
因為正式的封包可能比較長

322
00:18:23,008 --> 00:18:25,018
我們先送一個短短的

323
00:18:25,018 --> 00:18:27,051
request to send, clear to send 做一個宣告

324
00:18:27,051 --> 00:18:31,001
說這個範圍之內的 收到clear to send

325
00:18:31,001 --> 00:18:34,025
這種封包的這個node  等下不要來鬧

326
00:18:34,025 --> 00:18:37,065
那如果封包  所以我們剛剛提到就是說

327
00:18:37,065 --> 00:18:39,021
我會有一個request to send

328
00:18:39,021 --> 00:18:43,001
會回一個clear to send 經過這個一來一回之後呢

329
00:18:43,001 --> 00:18:46,011
就做一個宣告了 我就知道哪些人等一下不會來鬧

330
00:18:46,011 --> 00:18:49,041
我就開始送我的data 那data送出去呢

331
00:18:49,041 --> 00:18:50,081
他一定要回一個ACK

332
00:18:50,081 --> 00:18:52,081
這邊就是data, ACK, data, ACK

333
00:18:52,081 --> 00:18:54,081
就這樣子 就是一來一回一來一回

334
00:18:54,081 --> 00:18:58,001
送data回ACK, 送data回ACK, 送data回ACK

335
00:18:58,001 --> 00:19:01,068
所以我們會有一個ACK的這個控制封包 就會跑出來

336
00:19:01,068 --> 00:19:04,088
那事實上我們也有提到說 還有一個叫做polling

337
00:19:04,088 --> 00:19:08,061
polling就是說 那個基地台他會去問

338
00:19:08,061 --> 00:19:10,055
你們有沒有重要的封包要送

339
00:19:10,055 --> 00:19:14,065
有沒有這個所謂的即時 需要儘早送出去的

340
00:19:14,065 --> 00:19:16,088
他會去polling 他會去詢問

341
00:19:16,088 --> 00:19:19,075
那這個徵詢呢 如果被問到的人

342
00:19:19,075 --> 00:19:22,051
就趕快送重要的封包 優先的封包

343
00:19:22,051 --> 00:19:23,091
我們有這個polling

344
00:19:23,091 --> 00:19:26,095
好那我們在802.11 在管理上面

345
00:19:26,095 --> 00:19:28,098
剛提到他有這個所謂的probe

346
00:19:28,098 --> 00:19:32,025
他會問的意思啦 然後他有所謂的beacon

347
00:19:32,025 --> 00:19:34,041
beacon就比較像求救的概念

348
00:19:34,041 --> 00:19:37,038
然後還有做authentication 做像認證

349
00:19:37,038 --> 00:19:42,008
像我們在無線網路裡面 我們一般把筆電一打開

350
00:19:42,008 --> 00:19:43,088
我們看到那個access point

351
00:19:43,088 --> 00:19:45,065
可能就好多好多個access point

352
00:19:45,065 --> 00:19:47,021
那你要跟哪一個連

353
00:19:47,021 --> 00:19:49,091
在連的時候他基本上要做認證 做authentication

354
00:19:49,091 --> 00:19:53,051
像有些要密碼 那這個都是認證的過程當中

355
00:19:53,051 --> 00:19:55,061
也都是需要用到這樣的frame

356
00:19:55,061 --> 00:20:00,021
所以我們很簡單的先做一個所謂的summarize就是說

357
00:20:00,021 --> 00:20:05,018
在802.11裡面 我們有很多種所謂的frame的type

358
00:20:05,018 --> 00:20:11,021
有各式各樣的封包 譬如說像control frame

359
00:20:11,021 --> 00:20:13,088
我們有request to send 有clear to send 有ACK有poll

360
00:20:13,088 --> 00:20:17,078
那我們有所謂的management的frame 就做管理用的

361
00:20:17,078 --> 00:20:21,041
譬如說我會做authentication 做beacon 做probe等等

362
00:20:21,041 --> 00:20:25,021
那另外甚至就是data 就是有data要送

363
00:20:25,021 --> 00:20:28,068
所以簡單的講 就是說在802.11呢

364
00:20:28,068 --> 00:20:33,051
我們封包的型態有標準的這個data的封包

365
00:20:33,051 --> 00:20:39,018
那有為了讓這個所謂的collision avoidance更流暢

366
00:20:39,018 --> 00:20:41,085
我們有所謂的control frame

367
00:20:41,085 --> 00:20:44,078
那為了這個整個管理機制呢更流暢

368
00:20:44,078 --> 00:20:47,001
我們有所謂的management的frame

369
00:20:47,001 --> 00:20:51,008
好 那以上就是我們針對這個802.11

370
00:20:51,008 --> 00:20:53,051
做一個比較基本的介紹

371
00:20:53,051 --> 00:20:55,051


