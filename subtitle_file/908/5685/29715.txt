1
00:00:08,90 --> 00:00:13,17
接下來我們來介紹這個ethernet裡面最核心的技術

2
00:00:13,18 --> 00:00:15,41
我們就所謂的ethernet的MAC protocol

3
00:00:15,41 --> 00:00:17,58
就是所謂的CSMA/CD

4
00:00:17,58 --> 00:00:20,25
那我們在介紹這個MAC protocol之前

5
00:00:20,25 --> 00:00:23,51
我們還是要先特別再整理一下

6
00:00:23,51 --> 00:00:27,25
我們回顧一下說 我們剛剛有介紹過說

7
00:00:27,25 --> 00:00:32,37
在這個ethernet的這個cable的這種網路的架構之下呢

8
00:00:32,37 --> 00:00:39,15
我們說 所送的封包呢都會廣播到網路上面

9
00:00:39,15 --> 00:00:41,58
整個網路都會收到這個廣播的內容

10
00:00:41,58 --> 00:00:47,85
也就是說 我們說任何一個station只要把封包送上來

11
00:00:47,85 --> 00:00:52,35
我們看 然後它就會往兩邊 一次送

12
00:00:52,35 --> 00:00:56,47
送到最後面呢給這個termination呢把它吃掉

13
00:00:56,48 --> 00:00:59,48
那同時這個封包的內容當然就會進到

14
00:00:59,48 --> 00:01:03,68
每一個station 像我們這邊就會收進去嘛

15
00:01:03,68 --> 00:01:08,51
也就是說任何一個封包的這個傳輸

16
00:01:08,51 --> 00:01:11,78
事實上它會在這個cable上面呢

17
00:01:11,78 --> 00:01:16,78
廣播到任何一個地方 那即使有repeater

18
00:01:16,78 --> 00:01:19,61
repeater也是把它等於說訊號

19
00:01:19,61 --> 00:01:21,98
把它恢復到原來漂亮的訊號

20
00:01:21,98 --> 00:01:23,98
然後再重新再送一次

21
00:01:23,98 --> 00:01:27,35
那有repeater呢也是一樣 讓這個網路呢

22
00:01:27,35 --> 00:01:31,38
等於說距離可以拉得更長 可是還是一樣

23
00:01:31,38 --> 00:01:35,24
repeater本身是訊號進來 它就repeat出去

24
00:01:35,25 --> 00:01:38,18
等於說它只是把訊號做還原

25
00:01:38,18 --> 00:01:41,91
然後放大出去 所以本身它並沒有處理封包的內容

26
00:01:41,91 --> 00:01:44,58
它只是處理封包的那個訊號

27
00:01:44,58 --> 00:01:47,1
所謂的這個physical layer的訊號

28
00:01:47,1 --> 00:01:50,15
好那在這種網路的結構之下

29
00:01:50,15 --> 00:01:53,81
就每一個封包 只要丟到這個cable上面呢

30
00:01:53,81 --> 00:01:57,41
它就一定會廣播 送到任何一個角落

31
00:01:57,41 --> 00:02:00,71
包含每一個網卡呢都會收到

32
00:02:00,71 --> 00:02:03,30
那到了最終端的時候呢

33
00:02:03,31 --> 00:02:05,55
我們說我們有這個terminator

34
00:02:05,55 --> 00:02:09,31
就是網段的最右邊 然後我們會有terminator

35
00:02:09,31 --> 00:02:12,41
那這個terminator呢就會把這個所謂的訊號

36
00:02:12,41 --> 00:02:16,61
就把它吸收掉 不要讓它再反彈回去

37
00:02:16,61 --> 00:02:18,31
造成這個訊號的干擾

38
00:02:18,31 --> 00:02:21,98
那在介紹這個CSMA/CD之前

39
00:02:21,98 --> 00:02:25,75
我們先介紹一個什麼叫做CSMA啦

40
00:02:25,75 --> 00:02:28,58
就所謂的carrier sense multiple access

41
00:02:28,58 --> 00:02:31,28
從這個multiple access我們就知道說

42
00:02:31,28 --> 00:02:33,18
是有很多台電腦 就multiple

43
00:02:33,18 --> 00:02:36,41
它們都要來存取這個cable

44
00:02:36,41 --> 00:02:38,55
就所謂的廣播的媒介

45
00:02:38,55 --> 00:02:42,38
那carrier sense就是說 我們所謂的載波

46
00:02:42,38 --> 00:02:44,45
這個carrier所謂的載波就是說

47
00:02:44,45 --> 00:02:47,65
我這個cable上面是不是有人正在送

48
00:02:47,65 --> 00:02:48,85
如果有人正在送

49
00:02:48,85 --> 00:02:52,88
因為我們會有電壓的這個高低的變化嘛

50
00:02:52,88 --> 00:02:55,45
如果我有電壓高低的變化

51
00:02:55,45 --> 00:02:57,51
我們就說 這個就是有carrier

52
00:02:57,51 --> 00:03:03,000
我可以sense到說 有沒有人正在送這個封包

53
00:03:03,1 --> 00:03:05,71
啊如果有人正在送 你如果再把它送出去

54
00:03:05,71 --> 00:03:08,75
那就是collision啊 所以我們的技術就是說

55
00:03:08,75 --> 00:03:10,75
我們去送之前

56
00:03:10,75 --> 00:03:16,81
要先去聽聽看所謂這個cable上面有沒有人正在送

57
00:03:16,81 --> 00:03:20,60
這個叫所謂的carrier sense就是指這個意思

58
00:03:20,61 --> 00:03:26,88
就是我們送之前先去sense有沒有carrier在上面跑

59
00:03:26,88 --> 00:03:30,51
就carrier sense 那你sense的結果當然就有兩個啊

60
00:03:30,51 --> 00:03:32,81
一個就是說 好 是idle

61
00:03:32,81 --> 00:03:34,37
就是說我們發現呢

62
00:03:34,38 --> 00:03:38,85
這個時候這個cable上面呢沒有訊號

63
00:03:38,85 --> 00:03:42,55
就代表說 現在可能沒有人在送

64
00:03:42,55 --> 00:03:47,1
或者呢有人送這個封包的這個訊號呢

65
00:03:47,1 --> 00:03:49,55
因為它要傳過來也要一點時間嘛

66
00:03:49,55 --> 00:03:52,75
可能也還沒有傳到 我這個門口這邊來

67
00:03:52,75 --> 00:03:56,35
所以當我發現到這個channel是idle的時候呢

68
00:03:56,35 --> 00:03:59,58
我就把整個封包 把它送出去

69
00:03:59,58 --> 00:04:02,41
注意到 我是transmit entire frame

70
00:04:02,41 --> 00:04:04,58
把整個封包 封包有多長

71
00:04:04,58 --> 00:04:07,55
我們講封包最長1518個bytes

72
00:04:07,55 --> 00:04:11,8
我就把1518個bytes 當然是最長你可以短一點

73
00:04:11,8 --> 00:04:15,71
就把它送上去的意思 這是我如果發現到它是idle

74
00:04:15,71 --> 00:04:18,7
但是我有可能去聽聽看的時候呢

75
00:04:18,7 --> 00:04:20,80
就發現到 它已經事實上是busy啦

76
00:04:20,81 --> 00:04:24,51
代表說現在已經有人在送 那如果有人在送

77
00:04:24,51 --> 00:04:26,15
我當然不能送啊

78
00:04:26,15 --> 00:04:29,61
如果你硬是把它送上去 你就等於說

79
00:04:29,61 --> 00:04:31,51
把別人正在送的這個訊號

80
00:04:31,51 --> 00:04:34,15
就把它打干擾掉了把它打亂掉了嘛

81
00:04:34,15 --> 00:04:36,85
那不僅僅是你的封包不會成功

82
00:04:36,85 --> 00:04:38,68
別人的封包也會失敗

83
00:04:38,68 --> 00:04:41,5
就是說我們會去聽聽看

84
00:04:41,5 --> 00:04:45,18
這個cable上面有沒有封包正在傳送

85
00:04:45,18 --> 00:04:48,10
如果沒有你就可以把它送出去

86
00:04:48,11 --> 00:04:50,35
那如果有你就不能送

87
00:04:50,35 --> 00:04:52,91
那不能送呢 你就必須等一下

88
00:04:52,91 --> 00:04:55,48
我們叫做所謂的defer 這個transmission呢

89
00:04:55,48 --> 00:04:58,35
就是你的傳輸呢 就要延後

90
00:04:58,35 --> 00:05:00,68
那延後到什麼時候呢

91
00:05:00,68 --> 00:05:02,55
通常我們可以這樣子講 譬如說

92
00:05:02,55 --> 00:05:07,45
假設呢 這個是有人正在送這個封包

93
00:05:07,45 --> 00:05:09,1
假設這個時間軸

94
00:05:09,1 --> 00:05:12,25
然後你在這個地方進來 你想要送

95
00:05:12,25 --> 00:05:14,90
那你發現說這個封包已經有人在送

96
00:05:14,91 --> 00:05:17,38
你就繼續聽嘛 因為我們可以聽

97
00:05:17,38 --> 00:05:20,48
可以聽就等於說把這個讓它這個封包呢

98
00:05:20,48 --> 00:05:22,28
像這個地方 假設它送完了

99
00:05:22,28 --> 00:05:26,48
那你就在送完之後 這個地方你就可以把封包送上去

100
00:05:26,48 --> 00:05:30,95
就是說 你進來聽 這個cable的時候呢

101
00:05:30,95 --> 00:05:35,21
就是如果是idle你就送 如果是busy你就不能送

102
00:05:35,21 --> 00:05:39,71
你可以繼續聽 聽到它那個訊號消失了

103
00:05:39,71 --> 00:05:42,21
代表說它已經送完了 結束了

104
00:05:42,21 --> 00:05:44,35
它的封包已經過去了

105
00:05:44,35 --> 00:05:47,41
你就可以送 這是所謂的CSMA

106
00:05:47,41 --> 00:05:49,51
一個非常非常簡單的方法

107
00:05:49,51 --> 00:05:51,10
這個protocol呢非常簡單

108
00:05:51,11 --> 00:05:55,78
就是你在送之前先聽聽看 如果是idle你就送

109
00:05:55,78 --> 00:05:57,85
如果是busy你就不送

110
00:05:57,85 --> 00:06:00,65
那這樣的protocol非常簡單

111
00:06:00,65 --> 00:06:02,48
可是即使這樣的簡單呢

112
00:06:02,48 --> 00:06:05,15
它也有可能發生所謂的collision

113
00:06:05,15 --> 00:06:09,70
我們用這個圖來看 就是說這個圖假設我們有ABCD

114
00:06:09,71 --> 00:06:14,11
假設有ABCD四個工作站 連在這個cable上面

115
00:06:14,11 --> 00:06:17,98
我們就是說A在最左邊 B跟C在中間

116
00:06:17,98 --> 00:06:22,85
D在最右邊 我們說 注意到在這個t0的時候

117
00:06:22,85 --> 00:06:25,65
我們假設這個B呢它開始送

118
00:06:25,65 --> 00:06:28,61
那它送的封包我們這個注意到

119
00:06:28,61 --> 00:06:32,85
這個圖呢是一個所謂的2 dimension

120
00:06:32,85 --> 00:06:35,70
往下延伸就是它的時間軸

121
00:06:35,71 --> 00:06:39,25
那我們說當B送出來的時候它會往兩邊跑嘛

122
00:06:39,25 --> 00:06:43,18
那這個就是它往左邊傳輸啦

123
00:06:43,18 --> 00:06:45,80
那這個就是它往右邊傳輸

124
00:06:45,81 --> 00:06:49,78
就是說B把封包丟出來的時候 就是黃色的

125
00:06:49,78 --> 00:06:56,51
它就回往兩邊去 阿兩邊我們這個縱軸是它的時間

126
00:06:56,51 --> 00:07:01,68
所以等於說B傳給這個A是這樣慢慢過去啦

127
00:07:01,68 --> 00:07:04,41
然後傳到右邊去呢是這樣慢慢過去啦

128
00:07:04,41 --> 00:07:08,55
那它要花時間 這個時間跟它的距離是成正比

129
00:07:08,55 --> 00:07:10,98
就是說距離越遠 這個時間就越久

130
00:07:10,98 --> 00:07:13,75
所以我們這個 在這個圖上面呢

131
00:07:13,75 --> 00:07:18,41
是有兩個向下斜線 這個斜線代表

132
00:07:18,41 --> 00:07:20,94
因為它的時間 這是經過的時間

133
00:07:20,95 --> 00:07:27,11
好那我們特別注意到 在t1的時候

134
00:07:27,11 --> 00:07:28,95
在這個t1的時候 我們說

135
00:07:28,95 --> 00:07:32,38
這個時候呢 D它剛好它想送

136
00:07:32,38 --> 00:07:35,78
可是我們注意到在t1的這個時間點

137
00:07:35,78 --> 00:07:38,85
我們如果把這個時間點把它畫過來的話

138
00:07:38,85 --> 00:07:41,87
代表說在這個t1的時間點

139
00:07:41,88 --> 00:07:48,71
那個B它剛剛送的封包呢才到達 這個B跟C之間

140
00:07:48,71 --> 00:07:50,88
就是這個時間這個距離是在這裡嘛

141
00:07:50,88 --> 00:07:53,88
等於說在t1的時間的時候呢

142
00:07:53,88 --> 00:08:00,25
B的封包現在才到了這裡 到了B跟C之間

143
00:08:00,25 --> 00:08:03,85
這個時候D 因為D在最右邊這裡嘛

144
00:08:03,85 --> 00:08:09,80
 它還沒有看到 也還沒有看到這個B的訊號

145
00:08:09,81 --> 00:08:13,5
所以它就認為這個是idle 所以呢

146
00:08:13,5 --> 00:08:16,98
D就把它送出去 好那D就把封包丟出去一樣

147
00:08:16,98 --> 00:08:19,45
我們剛剛提到 因為這是一個廣播的媒體

148
00:08:19,45 --> 00:08:24,41
所以丟出去的訊號呢它也是往左邊 往右邊

149
00:08:24,41 --> 00:08:28,8
等於是說它是往兩邊跑出去嘛

150
00:08:28,8 --> 00:08:29,70
好 那我們注意一下

151
00:08:29,71 --> 00:08:33,21
在這兩個封包 在什麼時候會交會呢

152
00:08:33,20 --> 00:08:38,44
就會碰在一起 就在這個時間點 這個時間點

153
00:08:38,44 --> 00:08:41,5
就是我們在這邊看就是

154
00:08:41,5 --> 00:08:43,81
有黃色跟紅色的格子的

155
00:08:43,81 --> 00:08:48,45
就是這兩個封包衝撞在一起的時間

156
00:08:48,45 --> 00:08:53,7
等於說B的封包 一開始呢是從

157
00:08:53,8 --> 00:08:56,81
等於是說從這邊送過來 然後D的封包呢

158
00:08:56,81 --> 00:09:00,38
從這邊送過來 然後在這個時間點

159
00:09:00,38 --> 00:09:03,65
那這個時間點 這兩個封包

160
00:09:03,65 --> 00:09:05,95
就撞在一起了 這就是collision

161
00:09:05,95 --> 00:09:07,95
好 那collision之後

162
00:09:07,95 --> 00:09:09,85
一樣 因為這個等於說

163
00:09:09,85 --> 00:09:11,95
一個從左邊來 一個從右邊來

164
00:09:11,95 --> 00:09:13,61
這兩個訊號呢一疊在一起

165
00:09:13,61 --> 00:09:16,51
這個訊號就已經是亂掉了 就是已經

166
00:09:16,51 --> 00:09:19,1
譬如說它會加成的這個效果

167
00:09:19,1 --> 00:09:20,58
或者互相抵消的效果

168
00:09:20,58 --> 00:09:23,11
本來高電位變成更高的電位

169
00:09:23,11 --> 00:09:25,11
本來低電位就更低的電位

170
00:09:25,11 --> 00:09:29,35
那這個是你沒有辦法判斷 它到底是1還是0啦

171
00:09:29,35 --> 00:09:31,17
就是這個訊號你已經無法判斷了

172
00:09:31,18 --> 00:09:33,48
所以這個訊號基本上就已經是一個錯亂的訊號

173
00:09:33,48 --> 00:09:37,88
好 那問題是說 這個錯亂的訊號會往哪裡去

174
00:09:37,88 --> 00:09:40,5
我們這個封包是這樣子

175
00:09:40,5 --> 00:09:41,48
一個從左邊一個從右邊

176
00:09:41,48 --> 00:09:44,8
當它疊在一起的時候呢就亂了

177
00:09:44,8 --> 00:09:47,95
這個亂了也是會繼續往它的兩個方向走

178
00:09:47,95 --> 00:09:50,18
一樣 繼續往兩方向走

179
00:09:50,18 --> 00:09:52,25
所以我們可以看得到

180
00:09:52,25 --> 00:09:54,71
在中間這麼大的區塊

181
00:09:54,71 --> 00:09:57,5
像這一塊 這一塊呢

182
00:09:57,5 --> 00:10:00,95
這個通通都是collision 這個封包都沒有用

183
00:10:00,95 --> 00:10:03,38
可是我們這個CSMA 我們剛提到

184
00:10:03,38 --> 00:10:07,75
我如果發現idle 我就會把整個封包丟出去

185
00:10:07,75 --> 00:10:09,95
我們剛剛提到我是丟這個

186
00:10:09,95 --> 00:10:11,65
我是丟整個封包

187
00:10:11,65 --> 00:10:16,61
所以在這裡面就是說我們雖然對B來講的話

188
00:10:16,61 --> 00:10:20,95
注意到 對B來講它有一個很重要的時間點

189
00:10:20,95 --> 00:10:23,98
第一個 B在這個時間點把封包丟出去

190
00:10:23,98 --> 00:10:27,55
然後它丟丟丟丟到這個時間點

191
00:10:27,55 --> 00:10:31,1
 它發現 誒發生collision了

192
00:10:31,1 --> 00:10:35,74
就是說對B來講的話 它在t0把封包丟出去了嘛

193
00:10:35,75 --> 00:10:38,78
然後在這個時間點

194
00:10:38,78 --> 00:10:43,45
 它發現誒怎麼這個訊號已經變調了

195
00:10:43,45 --> 00:10:47,74
因為其實是跟D的封包兩個已經撞在一起

196
00:10:47,75 --> 00:10:52,98
而且在 等於說在B跟D之間 撞擊在這個地方

197
00:10:52,98 --> 00:10:56,7
那撞擊之後還會再回來嘛

198
00:10:56,8 --> 00:10:58,28
撞擊的也會再回來 因為這個回來

199
00:10:58,28 --> 00:11:00,31
是因為D把它送出來了

200
00:11:00,31 --> 00:11:05,7
所以對B來講的話 它在t0把封包丟出去

201
00:11:05,8 --> 00:11:08,91
可是在這個時間點呢 它發現撞擊了

202
00:11:08,91 --> 00:11:12,18
 它現在才發現  但是因為我們這個CSMA

203
00:11:12,18 --> 00:11:16,8
這個protocol呢是 要把整個封包送完

204
00:11:16,8 --> 00:11:19,1
所以它還是把整個封包送到這裡

205
00:11:19,1 --> 00:11:21,1
這個地方封包送結束

206
00:11:21,1 --> 00:11:26,48
一樣對D來講 它把t1的時候呢把封包丟出去

207
00:11:26,48 --> 00:11:31,38
可是它在這個時間點發現這個衝撞啦

208
00:11:31,38 --> 00:11:33,55
 它們的時間點發現的不一樣

209
00:11:33,55 --> 00:11:35,1
因為跟它們的距離有關係

210
00:11:35,1 --> 00:11:36,58
不管怎麼樣都是說

211
00:11:36,58 --> 00:11:40,31
一開始呢它發現這個channel是idle

212
00:11:40,31 --> 00:11:42,37
所以它就把封包丟出去

213
00:11:42,38 --> 00:11:45,78
丟出去的時候呢 它繼續聽那個上面的訊號

214
00:11:45,78 --> 00:11:49,35
結果過一段時間之後呢 欸發現這個已經

215
00:11:49,35 --> 00:11:51,64
訊號都已經亂掉了

216
00:11:51,65 --> 00:11:56,15
代表說的封包已經跟別人的發生衝撞

217
00:11:56,15 --> 00:11:59,11
但是這個衝撞呢它也沒有做任何反應

218
00:11:59,11 --> 00:12:00,58
就繼續衝撞吧

219
00:12:00,58 --> 00:12:03,45
因為我們現在CSMA裡面等於說

220
00:12:03,45 --> 00:12:06,68
雖然有發生這個collision 可是我們並沒有

221
00:12:06,68 --> 00:12:11,71
把這個collision detection的機制呢引進 只負責傳送

222
00:12:11,71 --> 00:12:14,11
但它其實已經發生collision了

223
00:12:14,11 --> 00:12:16,70
但是我們沒有去做這個偵測

224
00:12:16,71 --> 00:12:19,68
所以還是最後把封包整個送完

225
00:12:19,68 --> 00:12:21,38
但這個封包事實上是沒有用啦

226
00:12:21,38 --> 00:12:23,95
也就是說CSMA的這個機制

227
00:12:23,95 --> 00:12:28,65
 它是只要發現這個cable是idle你就送出去嘛

228
00:12:28,65 --> 00:12:31,98
那結果就像這樣子你必須把整個封包送完

229
00:12:31,98 --> 00:12:35,38
但是呢 這個封包如果發生collision

230
00:12:35,38 --> 00:12:37,15
整個封包就全部沒有用

231
00:12:37,15 --> 00:12:40,50
那既然是已經發生collision 封包都沒有用了

232
00:12:40,51 --> 00:12:44,8
你還是把它送完 那就是浪費啊

233
00:12:44,8 --> 00:12:46,45
因為你還是把它送完 所以這個整個就浪費掉了

234
00:12:46,45 --> 00:12:48,60
所以最後呢我們就說引進

235
00:12:48,61 --> 00:12:51,8
叫做collision detection的機制就是說

236
00:12:51,8 --> 00:12:54,68
好我一樣 跟前面一樣就是說

237
00:12:54,68 --> 00:12:57,5
我一開始呢看看這個封包本身

238
00:12:57,5 --> 00:13:00,48
這個channel 這個cable呢有沒有人在送

239
00:13:00,48 --> 00:13:02,98
那如果沒有人在送 我就送

240
00:13:02,98 --> 00:13:06,5
但是呢我在送封包的同時

241
00:13:06,5 --> 00:13:08,78
注意到 送封包的同時呢

242
00:13:08,78 --> 00:13:11,25
我會做所謂的collision detection

243
00:13:11,25 --> 00:13:13,91
我會偵測有沒有發生衝撞

244
00:13:13,91 --> 00:13:17,78
那如果被我發現 有發生衝撞

245
00:13:17,78 --> 00:13:19,88
代表說你這個封包已經沒有用了

246
00:13:19,88 --> 00:13:22,38
我就立刻做一個事情就是說

247
00:13:22,38 --> 00:13:26,51
我就把這個傳輸的這個動作呢 立刻把它停止

248
00:13:26,51 --> 00:13:31,61
我們前面CSMA是因為它沒有引進collision detection

249
00:13:31,61 --> 00:13:34,91
所以事實上封包已經衝撞了可是你還是不知道

250
00:13:34,91 --> 00:13:38,5
所以你還是把整個封包送完 那就浪費掉

251
00:13:38,5 --> 00:13:43,11
那CSMA/CD就是說我還加上collision detection的機制

252
00:13:43,11 --> 00:13:46,28
所以我知道 因為我有加上這個偵測機制

253
00:13:46,28 --> 00:13:50,51
所以我知道這個封包有沒有發生collision

254
00:13:50,51 --> 00:13:52,18
那如果發生了collision

255
00:13:52,18 --> 00:13:56,25
我就把這個封包的傳輸 這個動作呢就把它停掉

256
00:13:56,25 --> 00:13:59,1
然後因為你後面不用送了 送了也是多餘的嘛

257
00:13:59,1 --> 00:14:03,11
那這個作法呢就是像我們下面這樣來看一下

258
00:14:03,11 --> 00:14:06,60
好那剛剛提到 一樣 對於這個

259
00:14:06,61 --> 00:14:11,28
tb來講的話它在t0把封包丟出去

260
00:14:11,28 --> 00:14:16,18
然後這個D呢 它在t1把封包丟出去

261
00:14:16,18 --> 00:14:18,71
阿這個封包丟出去的呢 都是對的

262
00:14:18,71 --> 00:14:23,35
可是這個封包呢 在這個時間點呢

263
00:14:23,35 --> 00:14:27,40
我們講這個地方 發生的collision 就撞在一起了

264
00:14:27,41 --> 00:14:30,21
那撞在一起之後呢它就往兩邊跑

265
00:14:30,21 --> 00:14:33,15
一樣往兩邊跑 所以我們講B呢

266
00:14:33,15 --> 00:14:37,58
在這個時間點 這個地方 它偵測到collision了

267
00:14:37,58 --> 00:14:41,58
因為一開始B丟出去的時候呢這個封包是很好的

268
00:14:41,58 --> 00:14:44,68
所以它就一直看一直看 這邊都是黃色的

269
00:14:44,68 --> 00:14:46,78
就代表說都是它自己的封包

270
00:14:46,78 --> 00:14:50,74
而且沒有衝撞 所以這個訊號非常的乾淨

271
00:14:50,75 --> 00:14:53,1
好 但是在這個時間點呢

272
00:14:53,1 --> 00:14:55,1
它就發現 誒這個collision了

273
00:14:55,1 --> 00:14:57,7
因為訊號已經變掉了

274
00:14:57,8 --> 00:15:00,28
所以它做了一個動作就是把它停掉

275
00:15:00,28 --> 00:15:03,8
我們講 這個collision detection

276
00:15:03,8 --> 00:15:06,65
而且abort transmission嘛

277
00:15:06,65 --> 00:15:10,28
等於說它就把這個停掉 一樣 對D來講的話

278
00:15:10,28 --> 00:15:13,58
它在這個時間點

279
00:15:13,58 --> 00:15:16,11
發現的collision 所以它也把它停掉

280
00:15:16,11 --> 00:15:20,35
所以停掉之後 後面就不再送了 所以你會發現到

281
00:15:20,35 --> 00:15:23,15
這個圖跟前面那張圖

282
00:15:23,15 --> 00:15:25,40
發現不一樣就是說 前面這張圖呢

283
00:15:25,41 --> 00:15:27,8
會有比較大的區塊

284
00:15:27,8 --> 00:15:31,85
這個等於是說這個collision的區塊呢是比較大的

285
00:15:31,85 --> 00:15:34,45
我們講這一塊 這一塊都是collision

286
00:15:34,45 --> 00:15:38,48
那我們看接下來這個圖呢 我們就發現到

287
00:15:38,48 --> 00:15:43,51
它這個collision的時間相對的就少了很多啦

288
00:15:43,51 --> 00:15:44,95
只有這一塊而已嘛

289
00:15:44,95 --> 00:15:49,8
就是因為它引進了所謂的collision detection

290
00:15:49,8 --> 00:15:53,45
就是說只要我偵測到 這個封包呢已經collision了

291
00:15:53,45 --> 00:15:58,25
那這個封包已經沒有用了 我就停止傳送

292
00:15:58,25 --> 00:16:01,45
然後讓這個封包就停掉 就不送了

293
00:16:01,45 --> 00:16:04,50
等於說在上面的雜訊

294
00:16:04,51 --> 00:16:08,28
或者殘留的這個訊號呢就讓它走過去

295
00:16:08,28 --> 00:16:10,95
那你這個封包還是失敗了嘛

296
00:16:10,95 --> 00:16:14,8
雖然你已經說因為引進了collision detection

297
00:16:14,8 --> 00:16:17,95
可以讓我們比較節省 比較不會浪費頻寬

298
00:16:17,95 --> 00:16:20,1
但是這個封包還是失敗了

299
00:16:20,1 --> 00:16:24,45
那我們等一下會介紹 好那我怎麼再次的

300
00:16:24,45 --> 00:16:27,78
再把這個封包送到這個網路上面去

301
00:16:27,78 --> 00:16:29,78


