1
00:00:08,64 --> 00:00:12,35
接下來我們來介紹exponential back-off 的algorithm

2
00:00:12,35 --> 00:00:13,78
就是說我們說

3
00:00:13,78 --> 00:00:16,75
這個ethernet的這個網卡他

4
00:00:16,75 --> 00:00:20,15
送出去的時候呢可能會造成所謂的collision

5
00:00:20,15 --> 00:00:22,31
那發生collision之後呢

6
00:00:23,15 --> 00:00:27,5
每一個station 他就會再送一個所謂的jam signal

7
00:00:27,5 --> 00:00:31,48
把這個所謂的衝撞的這個封包 等於讓他撞得更徹底

8
00:00:31,48 --> 00:00:36,28
但是這也代表說這個封包已經沒有用了 他已經毀掉了

9
00:00:36,28 --> 00:00:40,31
那毀掉之後呢 我們到底要什麼時候再來送呢

10
00:00:40,31 --> 00:00:43,71
因為畢竟第一次封包傳送失敗的意思

11
00:00:43,71 --> 00:00:46,95
那我們希望這個封包還是可以把它成功的送出去

12
00:00:46,95 --> 00:00:50,88
所以作法就是說我們會等一個時間

13
00:00:50,88 --> 00:00:54,45
阿這個時間到底等多久呢 就是我們現在要介紹

14
00:00:54,45 --> 00:00:57,78
所謂的exponential back-off 這個back-off就是相當於說

15
00:00:57,78 --> 00:01:01,98
我這次傳送呢失敗 那我等一下會再來

16
00:01:01,98 --> 00:01:05,15
那我等多久會過來再試一次的意思

17
00:01:05,84 --> 00:01:09,68
那我們說有可能因為網路的loading很重

18
00:01:09,68 --> 00:01:12,61
所以也有可能我這次傳送失敗

19
00:01:12,61 --> 00:01:15,21
那我等待一個時間以後我重新來

20
00:01:15,21 --> 00:01:17,31
那我重新再來的時候呢

21
00:01:17,31 --> 00:01:21,15
一樣他要再一次的follow CSMA/CD

22
00:01:21,15 --> 00:01:24,11
就是每次要傳送的時候都要先聽聽看

23
00:01:24,11 --> 00:01:26,98
我們講聽聽看那個carrier sense嘛

24
00:01:26,98 --> 00:01:29,8
看看這個cable上面有沒有訊號

25
00:01:29,8 --> 00:01:31,61
如果有訊號 一樣你就必須等

26
00:01:31,61 --> 00:01:35,38
等到他等於變idle的時候呢再傳送

27
00:01:35,38 --> 00:01:38,81
那如果我們一聽 就是第二次來的時候

28
00:01:38,81 --> 00:01:42,18
一聽 這個channel上面就已經是idle的話

29
00:01:42,18 --> 00:01:43,58
那我們就送上去

30
00:01:43,58 --> 00:01:47,58
完全就是follow CSMA/CD這個protocol的方式

31
00:01:47,58 --> 00:01:52,1
那雖然是第一次衝撞 那你第二次來

32
00:01:52,1 --> 00:01:55,75
第二次來的時候呢 發現這個是idle的你就送出去

33
00:01:55,75 --> 00:01:57,95
但是呢他還是可能會衝撞

34
00:01:57,95 --> 00:02:01,85
尤其這個網路的loading如果越來越重的時候呢

35
00:02:01,85 --> 00:02:04,74
這種發生衝撞的機率呢就越來越高

36
00:02:04,75 --> 00:02:08,25
也就是說如果你第一次發生衝撞我們會等一個時間嘛

37
00:02:08,25 --> 00:02:13,11
那等了時間之後再來 如果又送出去然後又發生衝撞

38
00:02:13,11 --> 00:02:16,67
這就我們叫做連續兩次都發生衝撞

39
00:02:16,68 --> 00:02:20,71
那如果說我們這個連續衝撞的次數越多的話

40
00:02:20,71 --> 00:02:22,38
我們要談的就是說

41
00:02:22,38 --> 00:02:26,45
那我退後或著等待的時間可能就要更久一點

42
00:02:26,45 --> 00:02:29,48
因為連續衝撞就代表網路呢

43
00:02:29,48 --> 00:02:33,45
他是算是loading呢可能在某一種相當重的程度

44
00:02:33,45 --> 00:02:36,000
那連續衝撞的次數越多

45
00:02:36,1 --> 00:02:38,65
就代表網路的loading呢是越來越重

46
00:02:38,65 --> 00:02:40,65
那網路的loading越來越重就代表說

47
00:02:40,65 --> 00:02:43,31
有更多的station呢想要送封包出去

48
00:02:43,31 --> 00:02:47,71
那我們一直在等待的時間呢可能就會越等越久 越等越久

49
00:02:47,71 --> 00:02:51,35
最主要是說要避開大家同時送的這樣的機率啦

50
00:02:51,35 --> 00:02:56,85
他的做法就是說 每次連續衝撞多一次 我們等待的時間

51
00:02:56,85 --> 00:03:00,1
可能就double 就是等於說要

52
00:03:00,1 --> 00:03:02,81
等待那個時間可能就要再double

53
00:03:02,81 --> 00:03:05,5
所以變成說這個就是

54
00:03:05,5 --> 00:03:08,65
我們叫做所謂的exponential back-off的意思

55
00:03:08,65 --> 00:03:12,91
就是指說 我每一次呢衝撞多一次

56
00:03:12,91 --> 00:03:17,18
那我們這個back-off的時間呢 就要再多一倍

57
00:03:17,18 --> 00:03:20,28
所以等於意思就是說我們看一下

58
00:03:20,28 --> 00:03:24,97
下面這樣的說法就是說 那在ethernet裡面的標準裡面

59
00:03:24,98 --> 00:03:27,98
他是這樣子設計的 我們看一下

60
00:03:27,98 --> 00:03:34,5
我們說一開始呢 第一次delay

61
00:03:34,5 --> 00:03:36,51
就是我們一旦發生衝撞呢 我們剛剛提到說

62
00:03:36,51 --> 00:03:39,81
那我就要等一個時間嘛 阿這個時間到底等多久呢

63
00:03:39,81 --> 00:03:44,88
如果發生衝撞的這個station他們大家等的時間都一樣的話

64
00:03:44,88 --> 00:03:48,88
那其實下一次呢我們可以預測他也是一樣又衝撞

65
00:03:48,88 --> 00:03:50,81
因為大家等的時間都一樣嘛

66
00:03:50,81 --> 00:03:53,84
所以這個等的時間呢 必須是一個random

67
00:03:53,85 --> 00:03:56,51
他是一個類似一個亂數 random number generation

68
00:03:56,51 --> 00:03:59,5
就是大家等的時間要錯開來的意思

69
00:03:59,5 --> 00:04:00,51
但是到底要等多久呢

70
00:04:00,51 --> 00:04:04,5
我們說如果第一次衝撞的話

71
00:04:04,5 --> 00:04:06,21
我們等的時間有兩個可以選

72
00:04:06,21 --> 00:04:09,90
一個就是0 就是不等 直接就送出去

73
00:04:09,91 --> 00:04:13,55
欸不是 直接就來執行CSMA/CD啦

74
00:04:13,55 --> 00:04:16,5
我們再次強調 就每次不管你等多少時間

75
00:04:16,5 --> 00:04:21,5
時間等到了你還是要從CSMA/CD開始來

76
00:04:21,5 --> 00:04:24,51
再次的使用CSMA/CD來傳送這個封包

77
00:04:24,95 --> 00:04:28,68
好 我們說第一次delay呢 有兩個可以選擇

78
00:04:28,68 --> 00:04:32,15
一個就是0 一個就是51.2µs

79
00:04:32,15 --> 00:04:36,80
那我們說這個51.2µs就是所謂的collision window嘛

80
00:04:36,81 --> 00:04:39,35
就是一個round-trip time的時間

81
00:04:39,35 --> 00:04:40,55
就是一個collision window

82
00:04:40,55 --> 00:04:42,48
好 那第一次collision呢

83
00:04:42,48 --> 00:04:47,48
我們就在0跟51.2µs這兩個數字之間呢

84
00:04:47,48 --> 00:04:52,21
我們用亂數去挑 你可能挑到0 可能挑到51.2

85
00:04:52,21 --> 00:04:54,75
阿如果挑到51.2µs 就代表說

86
00:04:54,75 --> 00:04:59,75
你可能要等51.2µs之後呢 你再來試一次

87
00:04:59,75 --> 00:05:02,25
那我們強調 你再來試一次呢

88
00:05:02,25 --> 00:05:06,1
一樣要跑CSMA/CD的protocol 就是還是要去聽聽看

89
00:05:06,1 --> 00:05:11,1
到底現在我們講那個cable上面是busy還是idle

90
00:05:11,1 --> 00:05:13,41
那如果說我們說

91
00:05:13,41 --> 00:05:18,28
好啦不管你是挑到0或挑到51.2反正時間來了

92
00:05:18,28 --> 00:05:20,68
時間到了你就再試一次

93
00:05:20,68 --> 00:05:22,1
好那試一次呢

94
00:05:22,1 --> 00:05:26,1
你又把假設剛剛好又可以把封包丟出去 你就丟出去

95
00:05:26,1 --> 00:05:30,70
那丟出去呢假設萬一又衝撞 我們說這就是第二次衝撞

96
00:05:30,71 --> 00:05:32,25
就是同樣一個封包

97
00:05:32,25 --> 00:05:36,97
在傳送的過程當中已經發生了第二次的collision

98
00:05:36,98 --> 00:05:39,11
那如果發生第二次的collision呢

99
00:05:39,11 --> 00:05:42,11
我們這個back-off的時間呢 我們看一下

100
00:05:42,11 --> 00:05:47,48
就變成 我們可以選的這個範圍就變成更大一點

101
00:05:47,48 --> 00:05:49,45
我們剛剛提到 有一個叫做double

102
00:05:49,45 --> 00:05:54,65
就本來是第一次衝撞呢選的是0或51.2µs

103
00:05:54,65 --> 00:05:57,41
那第二次衝撞 連續第二次衝撞

104
00:05:57,41 --> 00:06:01,98
我們就是0, 51.2 變成102.4, 153.6

105
00:06:01,98 --> 00:06:08,41
事實上這個數字就是k乘上51.2 而k = 0,1,2,3

106
00:06:08,41 --> 00:06:12,28
因為我們的單位就是一個collision window嘛

107
00:06:12,28 --> 00:06:16,38
51.2我們說在ethernet裡面是有特別意義的數字

108
00:06:16,38 --> 00:06:21,65
他代表一個ethernet最大的網路 一個訊號來回的時間

109
00:06:21,65 --> 00:06:23,48
我們叫做collision window

110
00:06:23,48 --> 00:06:26,98
也就是說事實上相當於 我們第一次衝撞的話

111
00:06:26,98 --> 00:06:30,55
我們等的就是0或1 我們講0或1就是

112
00:06:30,55 --> 00:06:34,45
乘上這個k啦 乘上這個51.2µs

113
00:06:34,45 --> 00:06:38,25
也就是第一次衝撞的話 k=0或1

114
00:06:38,25 --> 00:06:42,10
那如果連續第二次衝撞 k=0,1,2,3

115
00:06:42,11 --> 00:06:47,25
在這個四個數字裡面 0,1,2,3我們取亂數

116
00:06:47,25 --> 00:06:49,80
所以第二次參加衝撞

117
00:06:49,81 --> 00:06:52,35
因為我們發生衝撞的時候 可能是兩個station

118
00:06:52,35 --> 00:06:56,25
事實上可能有更多的station 因為到底是幾個不一定

119
00:06:56,25 --> 00:06:59,97
因為有可能兩個同時送 他就會衝撞 但是兩個以上的

120
00:06:59,98 --> 00:07:02,51
三個四個五個都有可能同時衝撞

121
00:07:02,51 --> 00:07:05,27
反正參加衝撞的這種station呢

122
00:07:05,28 --> 00:07:08,15
他們就如果是都是第二次的話

123
00:07:08,15 --> 00:07:11,41
他們就在這個k=0,1,2,3這邊

124
00:07:11,41 --> 00:07:12,98
就挑一個亂數

125
00:07:12,98 --> 00:07:17,5
可能有人挑到0 有人挑到1 有人挑到2 有人挑到3

126
00:07:17,5 --> 00:07:19,38
那就各自不同的delay

127
00:07:19,38 --> 00:07:23,8
那反正每一個人的delay到了他就再重來

128
00:07:23,8 --> 00:07:27,25
啊重來就是follow 我們講的CSMA/CD的protocol

129
00:07:27,25 --> 00:07:30,1
所以有時候有的人是0有的人是3

130
00:07:30,1 --> 00:07:33,87
那這個0的人他比較早來 那送成功了他就錯開了嘛

131
00:07:33,88 --> 00:07:37,48
我們本來的目的就是希望大家即使重來的時候呢

132
00:07:37,48 --> 00:07:42,1
那個重來的時間點也要把它錯開 那一旦把它錯開

133
00:07:42,1 --> 00:07:45,1
就降低了一個再一次衝撞的機率啦

134
00:07:45,1 --> 00:07:50,41
但是也有可能是說 我們一直在衝撞 結果呢

135
00:07:50,41 --> 00:07:53,81
下一次時間到的時候 發現有人先送了

136
00:07:53,81 --> 00:07:58,8
就有一些沒有參加衝撞的station 他也有可能在

137
00:07:58,8 --> 00:08:02,55
大家都退後的過程當中 因為大家都在等待嘛 他反而先送了

138
00:08:02,55 --> 00:08:06,58
這個是CSMA/CD 這個所謂的exponential back-off algorithm

139
00:08:06,58 --> 00:08:08,38
他有一個這樣的所謂的side effect

140
00:08:08,38 --> 00:08:13,15
就是說先到的不一定能夠先送出去啦

141
00:08:13,15 --> 00:08:16,1
就是我們可能好幾個station先到

142
00:08:16,1 --> 00:08:18,1
代表他們想要先送

143
00:08:18,1 --> 00:08:21,1
可是我們都在那邊撞來撞去 我們都在退後

144
00:08:21,1 --> 00:08:23,25
結果一個比較晚到的station

145
00:08:23,25 --> 00:08:25,61
他想送的時候發現這個channel idle

146
00:08:25,61 --> 00:08:26,90
他一送他就成功了

147
00:08:26,91 --> 00:08:30,1
因為前面到了他們都在那邊撞得稀巴爛

148
00:08:30,1 --> 00:08:32,68
到後面等待更久 這是有可能的

149
00:08:32,68 --> 00:08:37,74
好我們再回到這邊說 好 那如果說第二次傳輸呢

150
00:08:37,75 --> 00:08:40,95
不管你這個亂數怎麼選0,1,2,3

151
00:08:40,95 --> 00:08:43,55
但是呢他再次送出去的時候呢

152
00:08:43,54 --> 00:08:47,15
又發生collision 我們這個叫做連續三次的collision

153
00:08:47,15 --> 00:08:50,11
那如果發生了連續三次的collision的話

154
00:08:50,11 --> 00:08:55,7
那這個一樣 我們這個還是一樣要這個back-off

155
00:08:55,8 --> 00:08:58,21
那back-off的亂數呢就變成0,1,2,3,4,5,6,7

156
00:08:58,21 --> 00:09:01,84
就變成說 剛剛所謂的exponential就是指這裡

157
00:09:01,85 --> 00:09:06,58
因為我第一次衝撞我可以挑的有兩個亂數嘛 兩個裡面挑

158
00:09:06,58 --> 00:09:10,91
那第二次衝撞呢變成四個 第三次衝撞變成八個

159
00:09:10,91 --> 00:09:12,78
所以簡單的講就是說

160
00:09:12,78 --> 00:09:19,38
如果第三次衝撞的話 我們變成等於說是0到7啦

161
00:09:19,38 --> 00:09:22,75
這個地方0到7 那如果再往下的話呢

162
00:09:22,75 --> 00:09:25,58
所以我們用一個比較general的演算法來看

163
00:09:25,58 --> 00:09:32,64
就是如果你連續譬如說n次衝撞的話 連續n次啦

164
00:09:32,65 --> 00:09:37,31
那n就是 n=1就代表一次 n=2就代表第二次嘛

165
00:09:37,31 --> 00:09:42,15
那連續衝撞n次的話 那我們再退後的亂數呢

166
00:09:42,15 --> 00:09:50,35
這個就變成k乘51.2µs  可是這個k值就是2的n次方減一

167
00:09:50,35 --> 00:09:54,1
這個是很重要的一個數字 2的n次方減一

168
00:09:54,1 --> 00:09:55,50
所以我們可以就這樣子講

169
00:09:55,51 --> 00:09:59,15
就是說 好那你如果第一次衝撞你就挑0,1嘛

170
00:09:59,15 --> 00:10:04,1
那連續第二次衝撞就是0,1,2,3 這裡面挑一個

171
00:10:04,1 --> 00:10:07,18
那如果連續三次呢 就是0,1,2,3,4,5,6,7

172
00:10:07,18 --> 00:10:11,8
那如果連續四次的話呢就是0,1,2,3,4,5,6,7到15

173
00:10:11,8 --> 00:10:13,65
就是2的n次方-1這樣子

174
00:10:13,65 --> 00:10:16,58
那這樣一直衝 每次衝每次衝撞 連續的

175
00:10:16,58 --> 00:10:19,78
那最多最多呢 最多最多ethernet

176
00:10:19,78 --> 00:10:21,40
他的標準裡面最多十六次

177
00:10:21,41 --> 00:10:24,15
也就是說我這個封包如果送出去呢

178
00:10:24,15 --> 00:10:26,61
想要送 第一次衝撞我delay

179
00:10:26,61 --> 00:10:30,21
那delay完之後呢再來 再送出去又collision

180
00:10:30,21 --> 00:10:33,48
我就再等 再collision 再等 再collision 再等

181
00:10:33,48 --> 00:10:36,31
連續十六次都發生collision

182
00:10:36,31 --> 00:10:41,35
那這個網路幾乎是已經算是不太可能送成功

183
00:10:41,35 --> 00:10:42,78
因為他loading實在是太重

184
00:10:42,78 --> 00:10:45,45
這個時候我就會放棄

185
00:10:45,45 --> 00:10:47,91
就是說ethernet裡面他的網卡呢

186
00:10:47,91 --> 00:10:50,91
是會盡力地把這個封包送出去

187
00:10:50,91 --> 00:10:55,91
但是這個盡力 就是連續衝撞16次 他就放棄

188
00:10:55,91 --> 00:10:57,45
最多最多16次

189
00:10:57,45 --> 00:11:04,40
但是如果說我們講 16次那我代表說我要delay的時間變成2的16次方-1

190
00:11:04,41 --> 00:11:09,85
哇那這個時間很長啊 60000多個這個單位乘上51.2µs

191
00:11:09,85 --> 00:11:10,58
這個太長了

192
00:11:10,58 --> 00:11:14,35
所以我們這個等待的時間 我們講2的n次方-1

193
00:11:14,35 --> 00:11:17,55
這個n他有一個上限的值 就是10

194
00:11:17,55 --> 00:11:25,74
10的意思就是說 0到1023啦 就是我們說在delay呢在挑亂數的時候

195
00:11:25,75 --> 00:11:29,85
最多是0到1023之間挑一個

196
00:11:29,85 --> 00:11:31,85
就是說我如果連續衝撞10次

197
00:11:31,85 --> 00:11:34,45
好那我就挑0到1023

198
00:11:34,45 --> 00:11:39,88
那我如果衝撞第11次 還是0到1023

199
00:11:39,88 --> 00:11:41,88
裡面挑一個數字 亂數

200
00:11:41,88 --> 00:11:48,45
第12次呢也是0到1023 第13次也是0到1023 第14次15次都一樣

201
00:11:48,45 --> 00:11:52,7
到了第16次 又collision 我就放棄 我就不送了

202
00:11:52,8 --> 00:11:54,68
變成說 我們每次發生collision

203
00:11:54,68 --> 00:12:00,38
就會用double的這個範圍呢來挑那個random的時間

204
00:12:00,38 --> 00:12:01,88
每次double 每次double

205
00:12:01,88 --> 00:12:06,91
那每次double 我們在這個結果就是一個我們叫做exponential

206
00:12:06,91 --> 00:12:12,38
他就是一個指數的函數 因為我們每次都是double的話他就是一個指數函數

207
00:12:12,38 --> 00:12:15,78
好所以我們再做一次這樣的summary

208
00:12:15,78 --> 00:12:19,78
就是CSMA/CD protocol本身他的主要的特色

209
00:12:19,78 --> 00:12:22,15
我們再講 再等於是做一個重點整理

210
00:12:22,15 --> 00:12:25,48
第一個 在傳輸之前 我們說

211
00:12:25,48 --> 00:12:27,95
before transmission呢 我們會做carrier sense

212
00:12:27,95 --> 00:12:33,91
再送之前要聽聽看 這個cable呢到底是idle還是busy

213
00:12:33,91 --> 00:12:37,68
好 再假設是這個idle我們就送出去嘛

214
00:12:37,68 --> 00:12:43,28
那在傳送的過程當中 我們還是要繼續的聽

215
00:12:44,8 --> 00:12:47,18
我們講 我們叫做carrier sense while transmission

216
00:12:47,18 --> 00:12:52,28
就是說即使我們可以把封包送出去 可在傳送的過程當中呢

217
00:12:52,28 --> 00:12:55,8
還是要繼續的聽 為什麼要繼續的聽呢

218
00:12:55,8 --> 00:12:59,38
因為我們要偵測到底我們的封包有沒有發生所謂的collision

219
00:12:59,38 --> 00:13:02,78
那collision就是說兩個或兩個以上的station

220
00:13:02,78 --> 00:13:06,15
如果同時傳送的話 他們的訊號就會疊在一起

221
00:13:06,15 --> 00:13:08,48
那這個就會造成封包的錯誤

222
00:13:08,48 --> 00:13:13,15
好 那如果我們發生了collision 我就會把這個封包停掉

223
00:13:13,15 --> 00:13:15,98
就不送 而且甚至我會送一個jam signal

224
00:13:15,98 --> 00:13:19,91
讓他撞得更嚴重一點 然後同時就把封包就停掉

225
00:13:19,91 --> 00:13:23,68
那停掉的話這個封包就算是傳送失敗

226
00:13:23,68 --> 00:13:26,50
那我們要什麼時候再回來呢

227
00:13:26,51 --> 00:13:28,58
那我們說再回來就是所謂的back-off

228
00:13:28,58 --> 00:13:33,55
就是我會再一次的回來嘗試把這個封包再送一次

229
00:13:33,55 --> 00:13:36,94
那這個back-off本身 他的delay多久呢

230
00:13:36,95 --> 00:13:40,25
到底要等多久再回來？我們說這是一個random delay

231
00:13:40,25 --> 00:13:43,55
他是一個亂數 那這個random delay呢

232
00:13:43,55 --> 00:13:46,84
他是有剛剛提到那個 exponential back-off algorithm

233
00:13:46,85 --> 00:13:53,98
他是每次第一次衝撞 我delay呢就是0,1挑一個數字 乘上51.2µs

234
00:13:53,98 --> 00:13:59,98
那如果再第二次衝撞 我就0,1,2,3挑一個亂數 乘上51.2µs

235
00:13:59,98 --> 00:14:03,98
那第三次就0,1,2,3,4,5,6,7 就是exponential

236
00:14:03,98 --> 00:14:05,91
這樣的挑選那個亂數

237
00:14:05,91 --> 00:14:08,48
好那我們剛剛提到說第一個

238
00:14:08,48 --> 00:14:12,51
在傳送之前要聽聽看有沒有carrier嘛

239
00:14:12,51 --> 00:14:16,5
那如果是idle你就送 但如果是busy的話

240
00:14:16,5 --> 00:14:19,68
我們說如果這個channel sense是busy 代表現在有人正在送

241
00:14:19,68 --> 00:14:24,8
那有人正在送 你就不能送啊 你一送就是撞在一起了

242
00:14:24,8 --> 00:14:27,88
所以如果現在發現已經有人在送 就所謂的busy

243
00:14:27,88 --> 00:14:34,5
那我們就繼續聽 我們就去聽 聽到等到他變成idle的時候再送

244
00:14:34,5 --> 00:14:37,28
所以說如果channel是busy 我們就會稍微延後

245
00:14:37,28 --> 00:14:41,31
等到這個channel變成idle之後才送

246
00:14:41,31 --> 00:14:44,45
那我們也提到說什麼叫做collision window

247
00:14:44,45 --> 00:14:47,94
就是我們要偵測我們自己丟出去的封包

248
00:14:47,95 --> 00:14:49,88
到底有沒有發生collision

249
00:14:49,88 --> 00:14:54,55
那我們要偵測多久 至少你要偵測呢 一個round-trip time

250
00:14:54,55 --> 00:14:59,11
因為說 我們說發生衝撞最長的時間

251
00:14:59,11 --> 00:15:04,11
需要偵測的時間 最長就是一個訊號來回的時間

252
00:15:04,11 --> 00:15:07,7
就是因為發生衝撞的這個兩個station呢

253
00:15:07,8 --> 00:15:10,71
他們在網路的最兩端啦 最遠的兩端

254
00:15:10,71 --> 00:15:14,51
那這個訊號的來回 我們叫做一個所謂的collision window

255
00:15:14,51 --> 00:15:17,8
就是所謂的round-trip time 一個slot time

256
00:15:17,8 --> 00:15:20,75
好 那在這個ethernet的標準裡面呢

257
00:15:20,75 --> 00:15:25,5
這個slot time呢他是設定為51.2µs

258
00:15:25,5 --> 00:15:28,91
所以51.2是一個特別有意義的數字

259
00:15:28,91 --> 00:15:34,75
那我們再提到說 那我們到底在發生collision的時候怎麼處理呢

260
00:15:34,75 --> 00:15:39,58
我們說collision的訊號是由這個physical layer所送出去

261
00:15:39,58 --> 00:15:43,48
那他會送出一個jam 我們說如果發生了collision

262
00:15:43,48 --> 00:15:47,5
偵測到collision的話 我們會再送出一個jam signal

263
00:15:47,5 --> 00:15:51,31
這個jam signal的目的 我們說叫做collision enforcement

264
00:15:51,88 --> 00:15:55,48
就是強迫他撞得更嚴重一點

265
00:15:55,48 --> 00:15:59,31
那撞了之後呢 我們就開始所謂的back-off

266
00:15:59,31 --> 00:16:02,84
因為我們等一下會再來嘗試把封包送出去

267
00:16:02,85 --> 00:16:05,58
那這個嘗試的這個時間等待呢

268
00:16:05,58 --> 00:16:11,1
我們叫做所謂的binary exponential back-off的algorithm

269
00:16:11,1 --> 00:16:14,78
那我們剛剛就是提到說 每次衝撞呢

270
00:16:14,78 --> 00:16:18,71
我們假設n是連續衝撞的次數

271
00:16:18,71 --> 00:16:21,15
那我們剛剛也提到 n要小於等於16

272
00:16:21,15 --> 00:16:23,74
就是說連續衝撞超過16次

273
00:16:23,75 --> 00:16:27,18
我們基本上就不送了 這個封包我們就不送了

274
00:16:27,18 --> 00:16:30,98
因為這個時候代表網路呢 是非常非常的壅擠

275
00:16:30,98 --> 00:16:34,7
你想送其實也 應該也送不出去了啦

276
00:16:34,8 --> 00:16:36,28
所以n超過16呢就不送

277
00:16:36,28 --> 00:16:40,95
那我們剛剛也提到說 我們在等待的這個random number呢

278
00:16:40,95 --> 00:16:43,71
是我們講2的n次方-1嘛

279
00:16:43,71 --> 00:16:49,95
阿那個k呢 我們就會從minimum n跟10來挑一個數字

280
00:16:49,95 --> 00:16:53,88
ok 也就是說 如果連續衝撞的次數呢 小於10

281
00:16:53,88 --> 00:16:58,11
小於10的話 那我們就是2的n次方-1

282
00:16:58,11 --> 00:17:03,31
0到2的n次方-1來挑那個亂數 但是如果n大於10了

283
00:17:03,31 --> 00:17:06,58
剛提到連續衝撞已經11,12,13,14,15了

284
00:17:06,58 --> 00:17:09,90
但是我們在挑那個random number的時候

285
00:17:09,90 --> 00:17:15,54
k呢還是用10嘛 最多我們挑的那個亂數的這個範圍

286
00:17:15,55 --> 00:17:24,38
就是0到1023 就是這個k值呢 我們取的是10跟n的這個minimum

287
00:17:24,38 --> 00:17:28,55
那這個也叫做truncation啦 就是我們把那個

288
00:17:28,55 --> 00:17:33,85
k把這個n大於10的 都把它切掉的意思

289
00:17:33,85 --> 00:17:37,31
就是n如果大於10 n=11,12,13,14,15

290
00:17:37,31 --> 00:17:41,54
我們都把他用10來處理 所以這個叫所謂的truncation

291
00:17:41,55 --> 00:17:44,65
好 那我們挑的這個random number的delay

292
00:17:44,65 --> 00:17:51,18
我們叫做r 這個r呢就是在介於0跟2的k次方之間

293
00:17:51,18 --> 00:17:54,65
那我們剛剛提到就是說我們每次發生collision

294
00:17:54,65 --> 00:17:59,11
那我們再random delay 啊這個delay的時間

295
00:17:59,11 --> 00:18:04,78
就是0到2的k次方 這樣子來挑一個數字的意思

296
00:18:07,5 --> 00:18:10,95
好那我們剛也提到說 在ethernet裡面呢

297
00:18:10,95 --> 00:18:16,51
我們的一個slow time 一個slow time就是51.2µs

298
00:18:16,51 --> 00:18:21,34
我們剛剛也提到說 這非常非常重要的 非常有意義的數字

299
00:18:21,35 --> 00:18:27,5
在ethernet裡面 一個slow time 就是一個訊號來回的時間 是51.2µs

300
00:18:27,5 --> 00:18:31,8
那最後我們提一下 說我們剛剛提到前面這個方法

301
00:18:31,8 --> 00:18:35,85
叫做所謂的binary exponential back-off的algorithm

302
00:18:35,85 --> 00:18:41,18
就是說我們如果發生衝撞的話呢 我們會等待一段時間再來嘗試

303
00:18:41,18 --> 00:18:48,1
而且連續衝撞的次數如果越多 我們等待的時間就會可能就越久

304
00:18:48,1 --> 00:18:51,58
因為這個亂數啦 就是那個可能會撞得越嚴重

305
00:18:51,58 --> 00:18:55,15
可能就會等待的越久 那這樣的一個方法

306
00:18:55,15 --> 00:18:58,98
我們叫做所謂的binary exponential back-off的algorithm

307
00:18:58,98 --> 00:19:03,14
那這樣的algorithm呢 他有一個所謂的缺點就是說

308
00:19:03,15 --> 00:19:08,61
他會出現一個現象叫作 last-in-first-out的這樣的effect

309
00:19:08,61 --> 00:19:12,38
last-in-first-out我們在資料結構裡面很清楚就是說

310
00:19:12,38 --> 00:19:16,58
最後進來的first out 就是反而先送出去

311
00:19:16,58 --> 00:19:20,58
這是我們剛提到就是說 我可能有一堆的這個工作站

312
00:19:20,58 --> 00:19:25,4
那他們都想送封包 那他們都比較早進來想要送

313
00:19:25,5 --> 00:19:27,8
結果又collision 所以就退後嘛

314
00:19:27,8 --> 00:19:30,41
那他們在退後 在等待的過程當中

315
00:19:30,41 --> 00:19:33,28
反而有另外一個station呢他比較晚到

316
00:19:33,28 --> 00:19:39,15
可是她一聽這個channel呢是idle的 他就送出去了

317
00:19:39,15 --> 00:19:43,58
剛好他就送成功了 因為剛剛發生衝撞的那一群

318
00:19:43,58 --> 00:19:48,8
他們都在back-off 結果我比較後到

319
00:19:48,8 --> 00:19:51,41
我反而先送 所以他會有一個這個現象 就是說

320
00:19:51,41 --> 00:19:55,21
先到的不見得先送 那後到的可能會先送

321
00:19:55,21 --> 00:19:58,4
所以他有所謂的last-in-first-out的這樣的效果

322
00:19:58,5 --> 00:20:01,75
這樣的效果當然 就我們講 以公平性來講不是很公平

323
00:20:01,75 --> 00:20:05,88
但是這是沒有辦法 因為這個演算法就是這樣子設計

324
00:20:05,88 --> 00:20:07,88
 
