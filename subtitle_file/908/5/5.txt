1
00:00:10,210 --> 00:00:10,250
好，所以我們說

2
00:00:10,250 --> 00:00:16,480
針對hybrid link上面這個怎麼樣標籤所謂tagging的原則

3
00:00:16,480 --> 00:00:20,110
這個原理就是說針對每一個VLAN

4
00:00:20,110 --> 00:00:24,410
在hybrid link上面針對每一個或者某一個VLAN

5
00:00:24,410 --> 00:00:27,650
它的所有的這個VLAN的封包

6
00:00:27,650 --> 00:00:31,210
都要用相同的方式來處理

7
00:00:31,210 --> 00:00:35,610
就剛才提到要嘛它全部都是沒有貼標籤

8
00:00:35,610 --> 00:00:37,450
我們叫做implicitly tagging

9
00:00:37,450 --> 00:00:42,280
或者它就全部都要貼標籤而且是相同的標籤

10
00:00:42,280 --> 00:00:45,210
就是說針對每一個VLAN

11
00:00:45,210 --> 00:00:47,680
那它的所有的封包

12
00:00:47,680 --> 00:00:50,810
第一個就是說全部都不貼標籤

13
00:00:50,810 --> 00:00:53,550
或者呢全部都要貼標籤

14
00:00:53,550 --> 00:00:59,310
這是在hybrid link上面它的所謂的封包貼標籤的這個原則

15
00:00:59,310 --> 00:01:02,780
好，也就是說  剛剛提到的那句話

16
00:01:02,780 --> 00:01:05,510
針對一個hybrid link上面

17
00:01:05,510 --> 00:01:08,650
它的封包可能是可以混搭

18
00:01:08,650 --> 00:01:12,650
就有些封包會貼標籤、有些封包不會貼標籤

19
00:01:12,650 --> 00:01:18,750
好，但是貼標籤跟不貼標籤的封包它們必須屬於不同的VLAN

20
00:01:18,750 --> 00:01:21,910
這個是這樣子來做一個結論

21
00:01:21,910 --> 00:01:23,780
好，那我們剛剛也提到說

22
00:01:23,780 --> 00:01:26,250
以剛才的例子來講的話

23
00:01:26,250 --> 00:01:29,450
依剛剛那樣的網路的架構的例子來講的話

24
00:01:29,450 --> 00:01:32,680
我們說所有的VLAN A跟B呢

25
00:01:32,680 --> 00:01:37,350
都需要在hybrid link上面貼標籤

26
00:01:37,350 --> 00:01:39,250
那針對VLAN C的

27
00:01:39,250 --> 00:01:43,810
那它這個hybrid link上面就通通都不貼標籤

28
00:01:43,810 --> 00:01:45,950
因為它都不認識這個VLAN

29
00:01:46,680 --> 00:01:48,950
好，那接下來我們來談一下說

30
00:01:48,950 --> 00:01:53,280
那這個VLAN跟spanning tree的這個關係是什麼

31
00:01:53,280 --> 00:01:56,550
我們在另外的單元裡面有特別的介紹

32
00:01:56,550 --> 00:02:00,110
所謂的IEEE 802.1D建這個spanning tree

33
00:02:00,110 --> 00:02:02,850
那我們說spanning tree的目的呢

34
00:02:02,850 --> 00:02:07,850
我們說是為了我們叫eliminate這個loops

35
00:02:07,850 --> 00:02:10,380
在一個所謂的bridge LAN上面

36
00:02:10,380 --> 00:02:14,250
我們用bridge或者switch把很多網路把它接起來

37
00:02:14,250 --> 00:02:15,850
它是一個比較大的網路

38
00:02:15,850 --> 00:02:16,950
promote也比較好

39
00:02:16,950 --> 00:02:21,550
可是呢我們為了提高這個網路的所謂的可靠性

40
00:02:21,550 --> 00:02:26,110
我們在連接的時候會故意把它連接成有一些迴路

41
00:02:26,110 --> 00:02:29,180
那也是避免說那萬一有一些

42
00:02:29,180 --> 00:02:33,280
如果沒有迴路的話我們就承擔了一個風險

43
00:02:33,280 --> 00:02:36,210
就是link壞掉或者設備壞掉

44
00:02:36,210 --> 00:02:39,750
然後網路就會被隔離因為斷掉了嘛

45
00:02:39,750 --> 00:02:41,150
所以有迴路的話

46
00:02:41,150 --> 00:02:43,510
就是說萬一有一些設備壞掉

47
00:02:43,510 --> 00:02:45,710
我至少其他還可以連在一起

48
00:02:45,710 --> 00:02:48,110
那網路至少還是連結在一起的

49
00:02:48,110 --> 00:02:51,180
那可是迴路本身它又會造成

50
00:02:51,180 --> 00:02:53,150
我們兩個問題 一個就是說

51
00:02:53,150 --> 00:02:56,280
如果你有迴路的話  我們封包在送的時候

52
00:02:56,280 --> 00:02:59,750
因為有迴路嘛  所以可能會有多條路徑

53
00:02:59,750 --> 00:03:02,210
那封包可能會重複接收

54
00:03:02,210 --> 00:03:06,450
還有我們在做所謂的address learning的時候呢也會發生錯誤

55
00:03:06,450 --> 00:03:12,050
所以說我們為什麼需要802.1D的那個spanning tree的algorithm

56
00:03:12,050 --> 00:03:17,010
跑完之後呢就是把那個loop暫時把它所謂的eliminate

57
00:03:17,010 --> 00:03:18,180
就是我們的spanning tree

58
00:03:18,180 --> 00:03:24,450
就是要把這個 loop 把它先暫時排除掉

59
00:03:24,450 --> 00:03:28,610
讓它在一個沒有loop的這種環境之下

60
00:03:28,610 --> 00:03:31,380
可以開始做所謂的address learning

61
00:03:31,380 --> 00:03:35,010
開始學習然後開始做所謂的forwarding

62
00:03:35,010 --> 00:03:38,950
就是說我們會把spanning tree先找出來

63
00:03:38,950 --> 00:03:40,510
然後才開始運作

64
00:03:40,510 --> 00:03:44,580
包括說學習拉或者轉送封包拉

65
00:03:44,580 --> 00:03:50,150
或者要過濾封包  通通都是先要把spanning tree建出來

66
00:03:50,150 --> 00:03:53,180
好，因為spanning tree要先建起來

67
00:03:53,180 --> 00:03:56,650
那spanning tree本身它的特性就是沒有loop

68
00:03:56,650 --> 00:04:00,110
也就是說任何兩點之間只有唯一的路徑

69
00:04:00,110 --> 00:04:01,880
那這個唯一的路徑

70
00:04:01,880 --> 00:04:06,050
其實我們說它也提供了所謂的routing path

71
00:04:06,050 --> 00:04:10,750
Routing path就是說在有spanning tree的結構之下

72
00:04:10,750 --> 00:04:16,150
任何兩點之間  它們的封包一定是走這個spanning tree

73
00:04:16,150 --> 00:04:19,510
就是沿著spanning tree來傳送的意思

74
00:04:19,510 --> 00:04:23,510
所以spanning tree本身它就提供了所謂的routing

75
00:04:23,510 --> 00:04:25,510
所以routing本身沒有太複雜

76
00:04:25,510 --> 00:04:26,750
就是走spanning tree

77
00:04:26,750 --> 00:04:31,150
雖然我們說走spanning tree不見得是最短的路徑

78
00:04:31,150 --> 00:04:33,210
就是那個路徑不見得最好

79
00:04:33,210 --> 00:04:34,680
但是它最簡單

80
00:04:34,680 --> 00:04:35,980
就是走spanning tree

81
00:04:35,980 --> 00:04:38,380
那我們也說這個spanning tree本身

82
00:04:38,380 --> 00:04:44,450
它會動態的建構  包含是說萬一你有link斷掉

83
00:04:44,450 --> 00:04:47,750
你有bridge或者是說switch壞掉沒有關係

84
00:04:47,750 --> 00:04:51,910
它會動態的再去找到新的spanning tree

85
00:04:51,910 --> 00:04:54,710
或者spanning tree本身會再去做一些調整

86
00:04:54,710 --> 00:04:56,810
就是說它spanning tree本身

87
00:04:56,810 --> 00:05:00,450
它是可以根據我網路的狀態  做動態的調整

88
00:05:00,450 --> 00:05:03,150
所以我一直都會有一個spanning tree

89
00:05:03,150 --> 00:05:05,680
那既然一直都會有一個spanning tree

90
00:05:05,680 --> 00:05:10,380
那我的封包傳送呢  這個路徑的問題呢就解決掉

91
00:05:10,380 --> 00:05:12,180
因為就走spanning tree就可以

92
00:05:12,180 --> 00:05:17,210
那接下來我們就要談說 那我們的VLAN呢

93
00:05:17,210 --> 00:05:20,480
VLAN本身跟spanning tree是有什麼關係呢

94
00:05:20,480 --> 00:05:23,010
我們在之前的例子我們也看到說

95
00:05:23,010 --> 00:05:25,850
譬如說我們有VLAN A，綠色的

96
00:05:25,850 --> 00:05:29,750
VLAN B 它是紅色的，那VLAN C是橘色的

97
00:05:29,750 --> 00:05:31,280
那我不同的VLAN

98
00:05:31,280 --> 00:05:39,110
它們這些VLAN的封包在傳送的時候跟spanning tree有什麼關係

99
00:05:39,110 --> 00:05:47,610
我們說，好，所有的VLAN它們都是沿著spanning tree來建構的

100
00:05:47,610 --> 00:05:50,280
就是說我們等一下看這一個例子

101
00:05:50,280 --> 00:05:55,650
就是說不管哪一個VLAN、不管它的member在哪裡

102
00:05:55,650 --> 00:05:59,680
它們這些VLAN在傳輸的這個路徑呢

103
00:05:59,680 --> 00:06:02,280
都是沿著spanning tree的這個意思

104
00:06:02,280 --> 00:06:07,980
就是說每一個VLAN事實上它的路徑

105
00:06:07,980 --> 00:06:11,480
就是這個VLAN的一個subset、一個子集合

106
00:06:11,480 --> 00:06:15,610
就是我們的spanning tree是把所有的node 所有的交換機都連起來

107
00:06:15,610 --> 00:06:18,050
所以spanning tree我們為什麼叫做spanning

108
00:06:18,050 --> 00:06:19,650
就是它是一個擴張

109
00:06:19,650 --> 00:06:23,910
擴張到所有的交換機 所有的node通通連起來

110
00:06:23,910 --> 00:06:26,750
可是我們的VLAN的member沒有那麼大

111
00:06:26,750 --> 00:06:29,150
我們的VLAN member可能就是說只有兩個

112
00:06:29,150 --> 00:06:34,150
可能三個、可能四個，就是若干個這個電腦本身要形成一個VLAN

113
00:06:34,150 --> 00:06:38,750
所以當我把這些的VLAN的member串起來的時候

114
00:06:38,750 --> 00:06:41,950
它不一定要用到整個spanning tree

115
00:06:41,950 --> 00:06:44,380
它應該只用到一個我們講一個subset

116
00:06:44,380 --> 00:06:49,180
一個部分的spanning tree  所以我們說每一個VLAN

117
00:06:49,180 --> 00:06:55,310
它的路徑所謂的routing path  都是spanning tree的一個子集合

118
00:06:55,310 --> 00:06:57,950
那另外一個特色就是說

119
00:06:57,950 --> 00:07:02,510
那不同的VLAN因為它們的路徑可能會不一樣

120
00:07:02,510 --> 00:07:06,050
但是呢特別注意到  不管它們路徑一不一樣

121
00:07:06,050 --> 00:07:08,810
都是原來spanning tree的一部份

122
00:07:08,810 --> 00:07:11,880
好，那我是A是spanning tree的一部份

123
00:07:11,880 --> 00:07:16,310
B，VLAN B，我的路徑也是spanning tree的一部份

124
00:07:16,310 --> 00:07:18,380
那我們可能有一些重疊

125
00:07:18,380 --> 00:07:22,410
可能有一些是，甚至有機會是完全不重疊也可以的

126
00:07:22,410 --> 00:07:27,850
部分重疊，或者是完全重疊，或者完全不重疊這都可以

127
00:07:27,850 --> 00:07:34,250
就是說不同的VLAN它們都是在這個spanning tree的一個subset

128
00:07:34,250 --> 00:07:36,910
它們的路徑都是spanning tree的一個子集合

129
00:07:36,910 --> 00:07:39,710
那不同VLAN之間它們的路徑

130
00:07:39,710 --> 00:07:48,150
可能有些會重疊甚至我們也有可能是完全分開、完全不重疊

131
00:07:48,150 --> 00:07:49,950
還有就是說剛剛提到

132
00:07:49,950 --> 00:07:55,310
因為我們的這個VLAN的這個所謂的topology它是dynamic

133
00:07:55,310 --> 00:07:58,410
有一個特性就是這個VLAN本身的成員

134
00:07:58,410 --> 00:08:02,550
它是可以被動態的加入或退出的

135
00:08:02,550 --> 00:08:04,850
就是我們在網管的角度來看

136
00:08:04,850 --> 00:08:09,780
就是我今天有設了一個VLAN  就是說五個電腦屬於這個VLAN

137
00:08:09,780 --> 00:08:13,010
那我等一下要做動態調整的時候我很簡單

138
00:08:13,010 --> 00:08:17,610
我只要再進到這個系統裡面去  譬如說用網管的技術去做設定

139
00:08:17,610 --> 00:08:21,980
所以我可以隨時再把新的電腦加到這個VLAN

140
00:08:21,980 --> 00:08:27,510
也可以隨時把已經在VLAN的某一些電腦把它剔除

141
00:08:27,510 --> 00:08:33,310
也就是說這個VLAN的membership  它的成員是可以動態做調整的

142
00:08:33,310 --> 00:08:39,410
好，那既然成員本身它們動態做調整  那它的路徑就會動態做調整

143
00:08:39,450 --> 00:08:45,480
不過沒有關係  就是說雖然我們說這個topology本身是dynamic

144
00:08:45,480 --> 00:08:49,810
它的拓墣是動態的  但是不管怎麼動態

145
00:08:49,810 --> 00:08:54,780
它一定都是這個spanning tree的一個子集合

146
00:08:54,780 --> 00:08:57,810
因為它一定先架在這個spanning tree上面

147
00:08:57,810 --> 00:09:04,480
那接下來的時候我們再來介紹說 那在這種VLAN的架構之下

148
00:09:04,480 --> 00:09:10,310
那我們的這個bridge  就是我們的這個交換機或者所謂的這個橋接器

149
00:09:10,310 --> 00:09:14,980
Bridge或switch呢  我怎麼來處裡一個封包

150
00:09:14,980 --> 00:09:22,950
就封包進來的時候怎麼處理呢 我們說針對每一個VLAN

151
00:09:22,950 --> 00:09:24,780
針對每一個VLAN

152
00:09:24,780 --> 00:09:30,310
這個bridge本身或者switch它要maintain兩個資料結構

153
00:09:30,310 --> 00:09:35,280
第一個就是我們之前有稍微介紹過  叫做所謂的member set

154
00:09:35,280 --> 00:09:39,310
Member set就是說針對每一個VLAN

155
00:09:39,310 --> 00:09:41,850
我們要維持說維護一個資料結構

156
00:09:41,850 --> 00:09:47,550
好，這個VLAN本身有哪一些port是屬於這一個VLAN

157
00:09:47,550 --> 00:09:50,580
另外一個叫做untagged set

158
00:09:50,580 --> 00:09:54,210
就是說那這些member裡面

159
00:09:54,210 --> 00:09:56,880
我們說這個member set裡面都是port

160
00:09:56,880 --> 00:10:01,980
就是哪些port 針對這些port有哪一些port呢

161
00:10:01,980 --> 00:10:06,910
你的封包從這個port送出去的時候是叫做untagged

162
00:10:06,910 --> 00:10:09,910
就是不能貼標籤 我們之前也提過

163
00:10:09,910 --> 00:10:13,750
有些port像剛剛提到的trunk port

164
00:10:13,750 --> 00:10:17,280
Trunk port本身就一定要貼標籤

165
00:10:17,280 --> 00:10:21,650
那access link 我們講trunk link本身是一定要貼標籤

166
00:10:21,650 --> 00:10:24,980
那access link是一定不貼標籤

167
00:10:24,980 --> 00:10:30,180
所以當我一個交換機裡面可能會有很多VLAN設定

168
00:10:30,180 --> 00:10:33,680
那針對每一個VLAN我們都會維護

169
00:10:33,680 --> 00:10:37,210
就是這個VLAN到底有哪些port屬於這個VLAN

170
00:10:37,210 --> 00:10:39,610
好，那這些Port裡面

171
00:10:39,610 --> 00:10:44,350
有哪些port它出去的時候呢 是不貼標籤的

172
00:10:44,350 --> 00:10:47,850
我們只要記這個untagged就可以了

173
00:10:47,850 --> 00:10:50,710
因為如果你不是untagged set就是要tagged

174
00:10:50,710 --> 00:10:51,750
就是要貼標籤

175
00:10:51,750 --> 00:10:56,480
所以我們說一個bridge本身它怎麼處理封包呢

176
00:10:56,480 --> 00:10:58,350
就是封包進來的時候呢

177
00:10:58,350 --> 00:11:03,380
我們就先判斷說封包是屬於哪一個VLAN

178
00:11:03,380 --> 00:11:05,480
我們講第一步 我們再來看

179
00:11:05,480 --> 00:11:07,510
好，那屬於這一個VLAN的話

180
00:11:07,510 --> 00:11:10,810
就是說那這一個VLAN呢到底有哪些port

181
00:11:10,810 --> 00:11:14,150
它的member是誰  我們再來看

182
00:11:14,150 --> 00:11:16,050
如果要從這些port出去呢

183
00:11:16,050 --> 00:11:21,010
我們來看說、來看說它需不需要被貼標籤

184
00:11:21,010 --> 00:11:25,650
或者不被貼標籤 就是說我們有這樣的資料結構

185
00:11:25,650 --> 00:11:30,750
我們就可以根據這樣的資料結構來處理這個封包

