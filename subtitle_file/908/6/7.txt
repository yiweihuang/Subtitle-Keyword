1
00:00:09,210 --> 00:00:15,80
好，我們說為了避免說這個封包一樣被重複地接收

2
00:00:15,80 --> 00:00:20,210
就是說我們在  當我們說這個receiving window size

3
00:00:20,210 --> 00:00:22,980
等於sending window size的時候

4
00:00:22,980 --> 00:00:25,410
我們的條件要設嚴格一點

5
00:00:25,410 --> 00:00:28,150
就是希望我們的sending window size

6
00:00:28,150 --> 00:00:34,310
要小於maximum sequence number加一除以二

7
00:00:34,310 --> 00:00:36,250
就是等於說要小於它的一半

8
00:00:36,250 --> 00:00:39,380
我們剛剛是差一拉剛剛差一

9
00:00:39,380 --> 00:00:41,10
就是說我們的maximum是8嘛

10
00:00:41,10 --> 00:00:43,580
然後我們的window size設為7

11
00:00:43,580 --> 00:00:47,180
就8跟7這樣是還不夠安全的

12
00:00:47,180 --> 00:00:51,550
那為了避免說這個封包不要被重複接收

13
00:00:51,550 --> 00:00:53,809
我們要讓這個條件更嚴格

14
00:00:53,810 --> 00:00:55,450
就是假設我們的maximum是8

15
00:00:55,450 --> 00:00:57,680
那我們就要小於一半

16
00:00:57,680 --> 00:01:01,850
變成說我們這個sending window size變成要小於一半

17
00:01:01,850 --> 00:01:05,680
譬如說8加一除以2就是4.5嘛

18
00:01:05,680 --> 00:01:08,650
那小於4.5就是4  就只能最多是一半

19
00:01:08,650 --> 00:01:11,50
譬如說我們在看一個例子來看

20
00:01:11,50 --> 00:01:12,250
我們這個例子裡面

21
00:01:12,250 --> 00:01:16,250
我們就假設我們一樣跟剛才相同

22
00:01:16,250 --> 00:01:19,780
我們的這個sequence number假設還是有8個

23
00:01:19,780 --> 00:01:24,650
就是0到7  但是呢我們這個時候

24
00:01:24,650 --> 00:01:28,680
把window size把它稍微變小一點

25
00:01:28,680 --> 00:01:36,680
我們說變成4  這個4呢剛好滿足說8加一除以二是4.5嘛

26
00:01:36,680 --> 00:01:39,180
那我們4呢剛好小於這個

27
00:01:39,180 --> 00:01:41,950
剛剛講maximum sequence number加一除以二

28
00:01:41,950 --> 00:01:43,310
這個時候是4.5

29
00:01:43,310 --> 00:01:47,780
所以我們這個時候就讓我們這個兩個window size都等於4

30
00:01:47,780 --> 00:01:51,980
好，我們再來看  那以這樣的條件呢我們來看看一樣的例子

31
00:01:51,980 --> 00:01:55,10
既然這個window size這個時候是4嘛

32
00:01:55,10 --> 00:02:01,50
也就是最多我可以送四個封包不要等ACK  最多四個 好 我們看

33
00:02:01,50 --> 00:02:03,149
Sender首先它送了0、1、2、3

34
00:02:03,150 --> 00:02:05,10
好，這沒有問題

35
00:02:05,10 --> 00:02:08,50
那receiver呢它也收到0、1、2、3

36
00:02:08,50 --> 00:02:11,650
一樣那receiver就回了acknowledgement

37
00:02:11,650 --> 00:02:13,780
回了0、1、2、3  一切都正常

38
00:02:13,780 --> 00:02:17,810
但是呢這個ACK還是一樣全部掉了

39
00:02:17,810 --> 00:02:20,380
好，我們假設這個ACK全部掉了

40
00:02:20,380 --> 00:02:24,579
好，這個時候sender就會開始送timeout囉

41
00:02:24,580 --> 00:02:26,980
Timeout會重送0、1、2、3

42
00:02:26,980 --> 00:02:28,850
0、1、2、3

43
00:02:28,850 --> 00:02:35,150
但是重點在於說這個0、1、2、3會不會被收、還是會被丟

44
00:02:35,150 --> 00:02:37,580
我們說重點在receiver

45
00:02:37,580 --> 00:02:40,250
剛剛提到receiver做了什麼事

46
00:02:40,250 --> 00:02:41,480
因為在這個地方

47
00:02:41,480 --> 00:02:46,709
一樣receiver收到0、1、2、3 都正確收到

48
00:02:46,710 --> 00:02:49,550
所以它的視窗已經滑出去了

49
00:02:49,550 --> 00:02:51,310
那一滑滑到哪裡呢

50
00:02:51,310 --> 00:02:54,150
因為這個時候window size只有4嘛

51
00:02:54,150 --> 00:02:57,710
所以0、1、2、3它一滑過去就是4、5、6、7

52
00:02:57,710 --> 00:03:01,250
在這個地方 好 那我們說

53
00:03:01,250 --> 00:03:04,10
Sender重送的是0、1、2、3

54
00:03:04,10 --> 00:03:08,209
可是我的receiver的視窗已經變成4、5、6、7了

55
00:03:08,210 --> 00:03:13,710
所以這個0、1、2、3就沒有掉在4、5、6、7裡面

56
00:03:13,710 --> 00:03:18,410
所以0、1、2、3通通會被丟掉  通通會被丟掉

57
00:03:18,410 --> 00:03:21,650
那這個被丟掉不是很浪費嗎

58
00:03:21,650 --> 00:03:23,910
為什麼要通通被丟掉呢

59
00:03:23,910 --> 00:03:26,810
因為我們說對receiver來講的話

60
00:03:26,810 --> 00:03:30,80
Receiver根本0、1、2、3通通已經收過了嘛

61
00:03:30,80 --> 00:03:34,510
0、1、2、3都已經正常  正確全部都收過了

62
00:03:34,510 --> 00:03:38,209
所以這個重送的東西我通通不要  通通不要

63
00:03:38,210 --> 00:03:41,750
所以我們通通把它丟掉那是正確的

64
00:03:41,750 --> 00:03:45,250
就是這所有的frame通通被丟掉這是正常的

65
00:03:45,250 --> 00:03:47,980
我們就用一個動畫的例子來看

66
00:03:47,980 --> 00:03:50,549
在這個例子裡面我們還是特別注意到

67
00:03:50,550 --> 00:03:55,150
我們的maximum sequence number還是等於8

68
00:03:55,150 --> 00:03:57,150
在這個地方還是等於8

69
00:03:57,150 --> 00:03:59,710
就是0、1、2、3、4、5、6、7的意思

70
00:03:59,710 --> 00:04:05,580
好，然後我們這個receiving跟sending的window size呢都等於4

71
00:04:05,580 --> 00:04:08,980
所以我們注意到這個size等於4

72
00:04:08,980 --> 00:04:10,709
這個size也是等於4

73
00:04:10,710 --> 00:04:13,150
就是變成0、1、2、3

74
00:04:13,150 --> 00:04:13,610
0、1、2、3

75
00:04:13,610 --> 00:04:16,810
這個呢我們現在把window size呢減為4

76
00:04:16,810 --> 00:04:21,450
好，那現在呢我們說這個圖的狀態是說

77
00:04:21,450 --> 00:04:24,780
這個Sender呢已經送了0、1、2、3出來

78
00:04:24,780 --> 00:04:27,349
就是說0、1、2、3已經送出來了

79
00:04:27,350 --> 00:04:31,380
但是呢receiver呢還沒有收到這4個封包

80
00:04:31,380 --> 00:04:32,610
我們假設它還沒有收到

81
00:04:32,610 --> 00:04:36,580
接下來封包當然就陸陸續續的Receiver收到

82
00:04:36,580 --> 00:04:40,650
好，我們來看首先收到了封包編號2

83
00:04:40,650 --> 00:04:44,310
這個時候我們講receiver這個視窗還是不能動

84
00:04:44,310 --> 00:04:46,850
我們一直強調這個視窗要滑動

85
00:04:46,850 --> 00:04:50,480
一定要最左邊的這個sequence number收到它才能滑

86
00:04:50,480 --> 00:04:54,580
現在收到2不能動  收到接下來看一下

87
00:04:54,580 --> 00:04:58,450
收到3  編號3這個也不能動

88
00:04:58,450 --> 00:05:01,580
再來看收到編號1的還是不能動

89
00:05:01,580 --> 00:05:03,810
這個時候0、1、2、3都到了

90
00:05:03,810 --> 00:05:05,980
但是呢都沒有按照順序

91
00:05:05,980 --> 00:05:08,310
所以呢還是放在buffer裡面

92
00:05:08,310 --> 00:05:13,350
好，現在最關鍵的  我們假設這個編號0的最後才到

93
00:05:13,350 --> 00:05:15,680
好，我們看一下  它一旦到了之後呢

94
00:05:15,680 --> 00:05:21,510
好，就是連續的  變成說因為0就跟前面的7接在一起

95
00:05:21,510 --> 00:05:23,210
這個時候視窗就滑動了

96
00:05:23,210 --> 00:05:28,180
因為我們連續等於說收到的就0、1、2、3

97
00:05:28,180 --> 00:05:30,580
有4個嘛，所以我們滑動四個位置

98
00:05:30,580 --> 00:05:31,810
視窗也滑過去了

99
00:05:31,810 --> 00:05:37,480
好，這個時候就是receiver它收到了四個封包

100
00:05:37,480 --> 00:05:39,650
然後回了四個ACK回去了

101
00:05:39,650 --> 00:05:41,950
我們的視窗已經滑到這裡來了

102
00:05:41,950 --> 00:05:46,409
我們說這個時候假設那個ACK通通都掉了

103
00:05:46,410 --> 00:05:52,80
掉了之後結果就是一樣  sender接下來它會timeout

104
00:05:52,80 --> 00:05:55,109
然後他會重送這四個封包

105
00:05:55,110 --> 00:05:56,150
編號0、1、2、3

106
00:05:56,150 --> 00:05:57,710
好  我們看一下  來

107
00:05:57,710 --> 00:06:02,180
timeout重送 timeout重送 timeout重送 timeout重送

108
00:06:02,180 --> 00:06:05,680
但是我們注意到這四個封包通通不會被收

109
00:06:05,680 --> 00:06:07,680
因為這四個封包0、1、2、3

110
00:06:07,680 --> 00:06:12,510
都不在receiver的window  4、5、6、7裡面

111
00:06:12,510 --> 00:06:17,180
也就是說這個時候這個重送的封包呢通通不會被接受

112
00:06:17,180 --> 00:06:21,50
所以我就解掉了這個所謂的重複接收的問題

113
00:06:21,50 --> 00:06:23,910
那我們接下來還有一個延伸的問題

114
00:06:23,910 --> 00:06:27,50
就是說那這個時候

115
00:06:27,50 --> 00:06:30,110
sender本身ACK不是全掉了嗎

116
00:06:30,110 --> 00:06:34,50
那等一下它會不會timeout又重送

117
00:06:34,50 --> 00:06:36,110
那這個就變成無解拉

118
00:06:36,110 --> 00:06:39,980
那我們說事實上沒有這個問題

119
00:06:39,980 --> 00:06:41,680
事實上是什麼問題呢

120
00:06:41,680 --> 00:06:47,910
就是說 好 即使這種所謂的封包重複進來

121
00:06:47,910 --> 00:06:51,650
我們還是讓receiver回ACK

122
00:06:51,650 --> 00:06:55,549
就是說像這個封包收到之後呢  其實我們會回ACK給它

123
00:06:55,550 --> 00:07:01,10
這個ACK回什麼呢  就看我們怎麼去實作呀

124
00:07:01,10 --> 00:07:03,480
如果我們用所謂的cumulative

125
00:07:03,480 --> 00:07:06,680
Cumulative就是說我回一個ACK告訴它

126
00:07:06,680 --> 00:07:10,480
像這個case你應該回cumulative ACK是什麼

127
00:07:10,480 --> 00:07:15,780
我們就回4呀  因為4就代表說我們在等4嘛

128
00:07:15,780 --> 00:07:18,479
那4以前就收到嘛  我就回4阿

129
00:07:18,480 --> 00:07:22,450
再來一個這個我們回ACK 回什麼

130
00:07:22,450 --> 00:07:26,479
我還是回4呀  再來一個我還是回4呀

131
00:07:26,480 --> 00:07:30,380
我都回4嘛  因為我在等4的意思

132
00:07:30,380 --> 00:07:32,480
我們說你來一個封包我就回一個ACK

133
00:07:32,480 --> 00:07:33,610
來一個封包我就回一個ACK

134
00:07:33,610 --> 00:07:35,750
但是如果ACK每次回你都是回4

135
00:07:35,750 --> 00:07:40,850
好，我們說  這麼多ACK我回給這個sender

136
00:07:40,850 --> 00:07:45,810
這麼多ACK它只要收到一個  只要收到一個ACK

137
00:07:45,810 --> 00:07:48,750
它就知道說 okay 我收到ACK 4

138
00:07:48,750 --> 00:07:51,150
代表說4以前都收到了

139
00:07:51,150 --> 00:07:55,150
所以只要收到這個這麼多ACK裡面

140
00:07:55,150 --> 00:08:00,750
這個sender只要收到一個就代表4以前通通收到了嘛

141
00:08:00,750 --> 00:08:02,480
就是3拉 包含3

142
00:08:02,480 --> 00:08:05,410
那這個時候  這個window

143
00:08:05,410 --> 00:08:09,180
它就移到這裡來了  它就滑動了嘛

144
00:08:09,180 --> 00:08:12,680
那一滑動等一下在送的封包就是4、5、6、7

145
00:08:12,680 --> 00:08:15,450
4、5、6、7不是就剛好落到這個sender

146
00:08:15,450 --> 00:08:16,849
receiver的範圍之內嘛

147
00:08:16,850 --> 00:08:22,680
就是說我們這個機制呢就可以更流暢地在跑了

148
00:08:22,680 --> 00:08:24,480
就是說雖然剛剛提到

149
00:08:24,480 --> 00:08:28,810
這些收到的呢通通都是我們講這些都是重複的

150
00:08:28,810 --> 00:08:30,850
通通會被丟掉  沒有關係

151
00:08:30,850 --> 00:08:33,350
雖然這個封包是重複被丟掉的

152
00:08:33,350 --> 00:08:35,780
但是我的ACK 我們這些ACK

153
00:08:35,780 --> 00:08:40,949
會讓sender知道說它的封包其實是已經被正確收到了

154
00:08:40,950 --> 00:08:42,810
那等一下這個視窗一移動

155
00:08:42,809 --> 00:08:46,410
就跟這個sender跟receiver就保持同步了

156
00:08:46,410 --> 00:08:49,949
那就可以繼續送 繼續收 繼續送 繼續收

157
00:08:49,950 --> 00:08:53,480
好，也就是說如果呢

158
00:08:53,480 --> 00:08:57,150
我們講SWS要等於這個RWS的話

159
00:08:57,150 --> 00:09:02,550
我們最好就是要讓它滿足這樣的條件

160
00:09:02,550 --> 00:09:07,750
只要滿足這個條件  這個protocol就可以非常流暢的在傳輸

161
00:09:07,750 --> 00:09:10,180
好，那最後我們看一下

162
00:09:10,180 --> 00:09:13,680
就是說這個sliding window protocol本身它就提供了

163
00:09:13,680 --> 00:09:15,680
三個很重要的特色

164
00:09:15,680 --> 00:09:21,709
第一個我們說  它提供了所謂的reliable transmission可靠傳輸

165
00:09:21,710 --> 00:09:24,10
那為什麼它可靠呢

166
00:09:24,10 --> 00:09:28,380
因為我們一定要讓這個receiver回一個ACK

167
00:09:28,380 --> 00:09:31,310
就是送一個封包一定要確認一個回應

168
00:09:31,310 --> 00:09:34,750
這個封包才算是成功的送完

169
00:09:34,750 --> 00:09:39,450
沒有收到ACK的我們就會timeout我就會retransmission

170
00:09:39,450 --> 00:09:45,680
那同時呢Sliding window本身我們講它preserve the order

171
00:09:45,680 --> 00:09:47,609
就是它的順序呢也會對

172
00:09:47,610 --> 00:09:51,10
雖然網路傳輸的時候順序可能會不對

173
00:09:51,10 --> 00:09:52,810
好，沒有關係

174
00:09:52,810 --> 00:09:56,250
我們把每一個封包給它一個sequence number

175
00:09:56,250 --> 00:10:01,480
那我們說這個順序不對的封包我們把它buffer起來

176
00:10:01,480 --> 00:10:08,380
先把它存起來 等到順序對的時候然後再給這個所謂的receiver

177
00:10:08,380 --> 00:10:13,310
再給上層  就是雖然封包到達的時間可能沒有按照順序

178
00:10:13,310 --> 00:10:17,180
但是沒有關係因為我們有buffer、我們把它buffer起來

179
00:10:17,180 --> 00:10:21,209
等到最左邊的  按照順序的封包到了之後

180
00:10:21,210 --> 00:10:23,850
再一併再丟給上層

181
00:10:23,850 --> 00:10:26,710
所以說對上層的protocol來講的話

182
00:10:26,710 --> 00:10:30,50
它這個sliding window這個protocol呢

183
00:10:30,50 --> 00:10:35,479
是可以提供依照順序的這個傳輸的服務拉

184
00:10:35,480 --> 00:10:37,450
好，最後一個特性我們說

185
00:10:37,450 --> 00:10:41,50
這個其實sliding window protocol

186
00:10:41,50 --> 00:10:45,780
本身它可以做所謂的flow control  流量控制

187
00:10:45,780 --> 00:10:47,250
流量控制就在於說

188
00:10:47,250 --> 00:10:50,550
如果sender送得太快

189
00:10:50,550 --> 00:10:54,280
然後把receiver的buffer很快就把它塞滿

190
00:10:54,280 --> 00:10:57,150
那這樣的話對receiver來講它也是一個負擔

191
00:10:57,150 --> 00:10:59,350
因為流量送得太快了

192
00:10:59,350 --> 00:11:03,910
Flow control就是說receiver本身我們說

193
00:11:03,910 --> 00:11:07,480
它可以我們叫做throttle這種sender

194
00:11:07,480 --> 00:11:10,580
它可以把sender呢的這個傳送的速度

195
00:11:10,580 --> 00:11:13,150
稍微用把它掐緊一點的意思

196
00:11:13,150 --> 00:11:16,110
相當於這個脖子把它掐住脖子說

197
00:11:16,110 --> 00:11:21,980
你sender到底可以送多快是receiver來決定的

198
00:11:21,980 --> 00:11:25,250
那決定本身根據什麼呢  根據就是RWS

199
00:11:25,250 --> 00:11:31,680
所以我們來想這個RWS到底扮演什麼重要的角色

200
00:11:31,680 --> 00:11:35,979
我們剛剛提到sender本身有一個這個sending window size

201
00:11:35,980 --> 00:11:38,850
Receiver本身有一個receiving window size

202
00:11:38,850 --> 00:11:43,780
那receiver本身如果把這個window size控制那代表什麼意思

203
00:11:43,780 --> 00:11:49,750
我們有提到說譬如說這個值假如它等於1是什麼意思

204
00:11:49,750 --> 00:11:53,180
等於1就代表說我只有一個buffer

205
00:11:53,180 --> 00:11:56,349
我只收按照順序進來的封包

206
00:11:56,350 --> 00:11:59,280
沒有按照順序的  我們講out-of-order我通通都不要

207
00:11:59,280 --> 00:12:02,79
那這個結果就是說你的封包

208
00:12:02,80 --> 00:12:03,910
萬一有out-of-order就會被丟掉

209
00:12:03,910 --> 00:12:06,709
被丟掉的結果等一下就是timeout 重送

210
00:12:06,710 --> 00:12:08,280
那就是把速率降下來

211
00:12:08,280 --> 00:12:12,680
就是說我們講為什麼叫做flow control  流量的控制

212
00:12:12,680 --> 00:12:16,910
就是說控制誰的流量就是控制sender

213
00:12:16,910 --> 00:12:20,650
你可以要讓sender不要送太多  不要送太快

214
00:12:20,650 --> 00:12:24,209
你就去控制這個receiver就去設定

215
00:12:24,210 --> 00:12:27,950
這個所謂的receiving window size的值

216
00:12:27,950 --> 00:12:33,80
你讓它等於1  這個整個網路速度呢可能就會開始慢慢掉下來

217
00:12:33,80 --> 00:12:37,250
那你把它設得大一點就可以送得快一點的意思

218
00:12:37,250 --> 00:12:43,950
也就是事實上這個整個流量是可以被receiver掌握的意思

219
00:12:43,950 --> 00:12:49,750
它可以控制它  也就是它可以盡量不要讓sender把這個receiver

220
00:12:49,750 --> 00:12:52,10
我們叫做overrun  overrunning

221
00:12:52,10 --> 00:12:56,950
不要把receiver呢這個能夠處理的能量把它塞爆掉

222
00:12:56,950 --> 00:13:02,780
因為我們講receiver本身  它也不是只有跟這個sender收資料

223
00:13:02,780 --> 00:13:05,150
通常我們講receiver假如說是一個server的話

224
00:13:05,150 --> 00:13:09,10
它可能它資料來自很多其他的node

225
00:13:09,10 --> 00:13:11,480
同時跟很多人在做通訊的

226
00:13:11,480 --> 00:13:17,110
所以它不希望某一個node送得太多或者送得太快進來

227
00:13:17,110 --> 00:13:18,210
讓它來不及處理

228
00:13:18,210 --> 00:13:23,180
我們講資料收到還要交給上一層拉、上一層可能是其它的protocol

229
00:13:23,180 --> 00:13:25,479
那它要處理資料量也要花時間

230
00:13:25,480 --> 00:13:30,780
所以說如果我們想要控制sender不要送太快或者不要送太多

231
00:13:30,780 --> 00:13:32,910
我只要把這個window size

232
00:13:32,910 --> 00:13:36,980
怎麼講receiving window size把它稍微做調控、把它變小

233
00:13:36,980 --> 00:13:40,280
等一下那個sender它就速度會降下去

234
00:13:40,280 --> 00:13:42,79
它是有這樣的效果

235
00:13:42,80 --> 00:13:47,210
好，最後我們針對這一章的內容作一個很快的結論

236
00:13:47,210 --> 00:13:51,680
我們說為了提供這個所謂的可靠的傳輸

237
00:13:51,680 --> 00:13:54,750
我們引進了兩個很重要的元素

238
00:13:54,750 --> 00:13:56,580
一個就是利用acknowledgement

239
00:13:56,580 --> 00:13:59,50
另外就是利用所謂的timeout

240
00:13:59,50 --> 00:14:01,250
我們利用這個acknowledgement跟timeout呢

241
00:14:01,250 --> 00:14:04,680
就可以達到所謂的reliable transmission

242
00:14:04,680 --> 00:14:06,750
就是送一個封包、等一個ACK

243
00:14:06,750 --> 00:14:12,50
然後呢如果ACK沒有收到我們就用timeout的機制讓它變成

244
00:14:12,50 --> 00:14:15,109
用timeout的機制讓它產生所謂的retransmission

245
00:14:15,110 --> 00:14:18,280
所以我們用了acknowledgement跟timeout這兩個機制

246
00:14:18,280 --> 00:14:23,79
那我們說第一個最有名的protocol就叫做stop-and-wait

247
00:14:23,80 --> 00:14:26,210
Stop-and-wait就是送一個封包就stop

248
00:14:26,210 --> 00:14:28,80
然後wait這個acknowledgement

249
00:14:28,80 --> 00:14:30,650
它是一個reliable、它是非常可靠

250
00:14:30,650 --> 00:14:34,550
但是throughput不夠好  不夠好的原因是說

251
00:14:34,550 --> 00:14:39,380
因為同一個時間最多只有一個封包在外面傳送

252
00:14:39,380 --> 00:14:42,650
送一個封包就要等ACK  ACK沒有回來不能送第二個

253
00:14:42,650 --> 00:14:45,810
但是呢除了throughput不夠好之外

254
00:14:45,810 --> 00:14:48,150
我們說它還可以造成另外一個問題

255
00:14:48,150 --> 00:14:50,180
我們叫做duplicated frame

256
00:14:50,180 --> 00:14:53,250
就是我們可能會重複收到封包

257
00:14:53,250 --> 00:14:55,610
為什麼會重複收到封包呢，因為delay

258
00:14:55,610 --> 00:14:59,950
我們講ACK  ACK可能lost掉  ACK可能delay

259
00:14:59,950 --> 00:15:05,50
那個ACK本身lost或delay都可能造成這個重複接收的問題

260
00:15:05,50 --> 00:15:06,410
好，那我們說

261
00:15:06,410 --> 00:15:10,880
那第二個最有名最經典的這個reliable的protocol

262
00:15:10,880 --> 00:15:14,680
就叫做sliding window protocol、滑動視窗

263
00:15:14,680 --> 00:15:17,880
視窗適時的滑動可以讓我們

264
00:15:17,880 --> 00:15:19,780
譬如說做到什麼

265
00:15:19,780 --> 00:15:23,680
第一個所謂的multiple outstanding frame

266
00:15:23,680 --> 00:15:27,750
就是希望可以同時多個封包同時在外面傳送

267
00:15:27,750 --> 00:15:30,680
然後盡量讓這個所謂的pipe

268
00:15:30,680 --> 00:15:33,280
Sender跟receiver中間的那個管線

269
00:15:33,280 --> 00:15:38,250
盡量讓它塞滿這個資料  然後呢每一個封包

270
00:15:38,250 --> 00:15:41,980
我們就會用一個sequence number來給它編號

271
00:15:41,980 --> 00:15:43,710
代表這個封包的順序

272
00:15:43,710 --> 00:15:48,780
那sender本身它要記得它有一個叫做sending window size

273
00:15:48,780 --> 00:15:54,209
那我們為了要讓這個送的可以連續送的更多一點

274
00:15:54,210 --> 00:15:57,580
我們希望這個window size的設計上盡量等於

275
00:15:57,580 --> 00:16:02,550
譬如說delay乘上bandwidth  就是前面這個pipe要把它塞滿

276
00:16:02,550 --> 00:16:03,880
就差不多這個數字

277
00:16:03,880 --> 00:16:08,10
然後我們會maintain所謂的last acknowledgement received

278
00:16:08,10 --> 00:16:10,250
還有maintain last frame sent

279
00:16:10,250 --> 00:16:12,350
最近送的這個frame的sequence number

280
00:16:12,350 --> 00:16:13,480
好，我們說

281
00:16:13,480 --> 00:16:15,950
好，相對地這個receiver本身

282
00:16:15,950 --> 00:16:18,450
它也有一個叫做receiving window size

283
00:16:18,450 --> 00:16:21,850
它可以等於1或者等於SWS

284
00:16:21,850 --> 00:16:24,410
事實上當然其它的值也是可以拉

285
00:16:24,410 --> 00:16:25,980
我們講這兩個是比較典型

286
00:16:25,980 --> 00:16:30,350
好，一樣，Receiver本身它有一個largest acceptable frame

287
00:16:30,350 --> 00:16:33,780
就是說我可以接受的sequence number最大是多少

288
00:16:33,780 --> 00:16:39,910
還有一個就是我最近收到的這個封包的sequence number是什麼

289
00:16:39,910 --> 00:16:42,850
Last frame received最近按照順序收到的

290
00:16:42,850 --> 00:16:47,50
那個沒有按照順序收到的  就是提早到的那個不算

291
00:16:47,50 --> 00:16:48,310
好，那我們說

292
00:16:48,310 --> 00:16:53,250
好，Sender跟receiver兩個都各有一個window size

293
00:16:53,250 --> 00:16:54,550
然後各有兩個參數

294
00:16:54,550 --> 00:16:58,849
那它唯一要做的事情就是要確認它們的關係

295
00:16:58,850 --> 00:17:03,550
這個關係、然後receiver呢要確定的是這樣的關係

296
00:17:03,550 --> 00:17:08,349
那我們說如果說我們的封包送出去之後

297
00:17:08,349 --> 00:17:15,109
如果剛剛提到如果有按照順序收到ACK的話我們就滑動視窗

298
00:17:15,109 --> 00:17:19,409
包括LAR往右移然後視窗往右移

299
00:17:19,410 --> 00:17:22,410
然後就產生新的空間出來可以再送封包

300
00:17:22,410 --> 00:17:24,150
好，我們再看一下

301
00:17:24,150 --> 00:17:25,780
對receiver來講的話呢

302
00:17:25,780 --> 00:17:29,450
像這個例子就是說我們已經收到了

303
00:17:29,450 --> 00:17:33,880
我們已經有七個window size有這個4到10

304
00:17:33,880 --> 00:17:37,280
那如果呢我可以按照順序收到封包

305
00:17:37,280 --> 00:17:43,50
譬如說4進來  一樣我們就開始滑動這個視窗 把視窗往右移

306
00:17:43,50 --> 00:17:46,850
這樣我就可以再收新的封包進來

307
00:17:46,850 --> 00:17:49,510
所以我們知道這個sliding window裡面

308
00:17:49,510 --> 00:17:52,310
很關鍵一定要學會的就是說

309
00:17:52,310 --> 00:17:56,679
到底視窗什麼時候會滑動  什麼時候會滑動

310
00:17:56,680 --> 00:18:00,110
我們說對於sender來講的話

311
00:18:00,110 --> 00:18:05,709
視窗要滑動很簡單  就是最左邊的這個封包的ACK要送到

312
00:18:05,710 --> 00:18:09,410
對於receiver來講  你視窗要移動，一樣

313
00:18:09,410 --> 00:18:15,380
就是最左邊的這個封包一定要收到  收到了最左邊的

314
00:18:15,380 --> 00:18:20,250
就是window視窗的最左邊、最小的收進來你就可以滑動

315
00:18:20,250 --> 00:18:24,150
這個最小的沒有收進來其他通通都不能滑動

316
00:18:24,150 --> 00:18:25,980
只能暫時維持那個狀態

317
00:18:25,980 --> 00:18:27,650
好，我們說

318
00:18:27,650 --> 00:18:35,680
那SWS跟RWS的值  可以是不一樣的 可以是不一樣

319
00:18:35,680 --> 00:18:39,110
我們講這個是完全看receiver的設計  你可以相同也可以不相同

320
00:18:39,110 --> 00:18:44,179
那我們說如果它相同的時候呢  我們一定要有一個關係

321
00:18:44,180 --> 00:18:48,980
好，就是我的window size  sender的window size

322
00:18:48,980 --> 00:18:52,610
應該要小於maximum sequence number加一除以二

323
00:18:52,610 --> 00:18:59,80
這樣的話才會確保這個封包不會被重複接收

324
00:18:59,80 --> 00:19:01,850
那我們也有例子來跟各位介紹說

325
00:19:01,850 --> 00:19:05,280
如果你沒有保持這樣的關係的話

326
00:19:05,280 --> 00:19:10,610
你的確會可能造成封包會被所謂的重複接受

327
00:19:10,610 --> 00:19:13,949
所謂的duplicate的這種、這種frame會出現

328
00:19:13,950 --> 00:19:16,610
好，那我們說還有一個特別注意到

329
00:19:16,610 --> 00:19:19,350
就是這個acknowledgement的mechanism

330
00:19:19,350 --> 00:19:21,80
就是說我們收到封包之後

331
00:19:21,80 --> 00:19:23,710
到底要怎麼回acknowledgement呢

332
00:19:23,710 --> 00:19:28,850
是一個封包回一個還是說回正的封包還是說我們講回負的

333
00:19:28,850 --> 00:19:32,350
我們叫negative，都可以  我們說它是一個option

334
00:19:32,350 --> 00:19:38,50
Option的意思就是說這個完全看我們receiver怎麼去實作

335
00:19:38,50 --> 00:19:42,10
那你receiver怎麼實作當然會影響到整個效能

336
00:19:42,10 --> 00:19:47,379
但是呢對整個protocol  protocol的運作是沒有影響

337
00:19:47,380 --> 00:19:50,750
Protocol還是會運作，當然影響的是效能

338
00:19:50,750 --> 00:19:53,80
譬如說我們如果用NAK

339
00:19:53,80 --> 00:19:54,780
我們叫negative acknowledgement

340
00:19:54,780 --> 00:19:57,950
代表說如果你收到封包是錯的你就回一個NAK

341
00:19:57,950 --> 00:20:01,510
這樣可以讓sender提早知道說它的封包是錯的

342
00:20:01,510 --> 00:20:05,250
至少不用等到timeout  對這個效能的提升有幫助

343
00:20:05,250 --> 00:20:08,910
那我們說  我們也可以用叫做cumulative acknowledgement

344
00:20:08,910 --> 00:20:13,280
就是我回的這個acknowledgement它是有累積的意義的

345
00:20:13,280 --> 00:20:15,480
變成我等於7就是代表說

346
00:20:15,480 --> 00:20:19,410
7以前的，6、5、4、3、2、1通通都收到了

347
00:20:19,410 --> 00:20:22,610
所以這個cumulative acknowledgement

348
00:20:22,610 --> 00:20:24,280
是一個非常非常常用的方法

349
00:20:24,280 --> 00:20:27,280
等於說我可以把ACK本身

350
00:20:27,280 --> 00:20:32,250
可以用一個數字代表之前的全部都收到

351
00:20:32,250 --> 00:20:36,210
所謂這種、這種累積型的是非常重要的一個機制

352
00:20:36,210 --> 00:20:39,680
好，我們最後說Sliding window protocol本身

353
00:20:39,680 --> 00:20:42,10
其中三個非常非常重要的功能

354
00:20:42,10 --> 00:20:46,480
第一個它做到了reliable transmission、可靠的傳輸

355
00:20:46,480 --> 00:20:50,750
而且它可以保證這個傳輸的這個order

356
00:20:50,750 --> 00:20:52,850
順序呢也可以保證

357
00:20:52,850 --> 00:20:57,949
就是說我們送給上一層的它會按照這個真正的順序

358
00:20:57,950 --> 00:21:02,650
雖然封包在傳輸的過程當中可能會亂序

359
00:21:02,650 --> 00:21:05,310
但是因為有buffer把它buffer起來

360
00:21:05,310 --> 00:21:07,110
所以這個真正的給上層的

361
00:21:07,110 --> 00:21:11,209
這個所謂的protocol的時候呢是可以按照順序的

362
00:21:11,210 --> 00:21:12,880
好，那最後就是說

363
00:21:12,880 --> 00:21:16,510
這個可以還可以做到所謂的flow control

364
00:21:16,510 --> 00:21:24,580
就是receiver本身它可以因為這個決定不同的RWS的值

365
00:21:24,580 --> 00:21:30,379
這個值不一樣  就會控制這個流量或者這個流速

366
00:21:30,380 --> 00:21:32,650
我們這個flow或者這個rate本身

367
00:21:32,650 --> 00:21:36,580
可以用這個RWS來做一個適度的控管

368
00:21:36,580 --> 00:21:42,750
所以也就是說  Sliding window protocol是一個非常非常好的protocol

369
00:21:42,750 --> 00:21:46,350
不過我們在這個章裡面  我們介紹的是說

370
00:21:46,350 --> 00:21:51,409
在所謂的一個區域網路或者一個link上面傳輸

371
00:21:51,410 --> 00:21:55,350
那我們說如果把這個方法把它用到整個Internet

372
00:21:55,350 --> 00:21:58,780
我們在以後的TCP

373
00:21:58,780 --> 00:22:02,580
也會再介紹它的另外一種reliable transmission

374
00:22:02,580 --> 00:22:05,610
TCP本身也是會做reliable transmission

375
00:22:05,610 --> 00:22:08,179
不過TCP呢跟我們這個sliding window

376
00:22:08,180 --> 00:22:10,810
觀念一樣但是細節的做法不一樣

377
00:22:10,810 --> 00:22:14,179
包含說TCP呢它的sequence number

378
00:22:14,180 --> 00:22:17,680
不是每一個封包、而是每一個byte

379
00:22:17,680 --> 00:22:19,880
每一個byte都有一個sequence number

380
00:22:19,880 --> 00:22:23,880
然後我們注意到  其實真的通訊的時候它是雙向的

381
00:22:23,880 --> 00:22:28,780
也就是說其實data是兩邊都在送  那ACK呢兩邊都在回

382
00:22:28,780 --> 00:22:31,750
所以它是雙向傳送、雙向回ACK

383
00:22:31,750 --> 00:22:34,710
它的複雜度會比我們這邊介紹的

384
00:22:34,710 --> 00:22:38,280
左邊送ACK、送封包然後再回ACK

385
00:22:38,280 --> 00:22:41,180
這比較像單向傳輸然後再ACK

386
00:22:41,180 --> 00:22:46,150
真正的communication是兩邊同時送data、同時回ACK

387
00:22:46,150 --> 00:22:48,250
所以這個複雜度會更高

388
00:22:48,250 --> 00:22:53,210
那這個更細節的部分我們在TCP的時候再來做介紹

389
00:22:53,210 --> 00:22:55,680
那我們這一章就跟各位介紹到這裡

