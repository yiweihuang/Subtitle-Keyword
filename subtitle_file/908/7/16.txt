1
00:00:08,980 --> 00:00:13,80
好  最後呢我們來針對這個internet working這一章

2
00:00:13,80 --> 00:00:14,650
做一個所謂的summary

3
00:00:14,650 --> 00:00:18,310
我們做一個最後的整理  我們說在這章裡面呢

4
00:00:18,310 --> 00:00:20,150
我們介紹了說

5
00:00:20,150 --> 00:00:23,680
怎麼樣來建構一個所謂的scalable

6
00:00:23,680 --> 00:00:25,750
還有heterogeneous的network

7
00:00:25,750 --> 00:00:30,9
就是說我們可以經由這個router的引進呢

8
00:00:30,10 --> 00:00:34,580
來建構一個比較大規模  而且是所謂的異質的網路

9
00:00:34,580 --> 00:00:36,410
就是我們這個網路的規模很大

10
00:00:36,410 --> 00:00:38,650
因為我們可以用router把它連接起來

11
00:00:38,650 --> 00:00:41,310
而且呢我們這個連接的網路

12
00:00:41,310 --> 00:00:43,350
可以是所謂的異質性

13
00:00:43,350 --> 00:00:45,810
就是可以是不同型態的網路

14
00:00:45,810 --> 00:00:49,710
不管是有線的  Ethernet  無線的  wifi

15
00:00:49,710 --> 00:00:52,110
甚至所謂的3G的網路

16
00:00:52,110 --> 00:00:54,510
各式各樣的網路都可以把它連起來

17
00:00:54,510 --> 00:00:58,379
好  那在這麼大的網路裡面

18
00:00:58,380 --> 00:01:01,680
每一個node或者每一個router它們要溝通嘛

19
00:01:01,680 --> 00:01:05,980
那因此呢我們說現在的標準就是所謂的IP

20
00:01:05,980 --> 00:01:07,910
就是internet的protocol

21
00:01:07,910 --> 00:01:10,280
讓所有的node  所有的router

22
00:01:10,280 --> 00:01:11,910
都有run這樣的protocol

23
00:01:11,910 --> 00:01:14,479
讓大家有一個類似統一的標準

24
00:01:14,480 --> 00:01:18,910
這樣的話整個internet上面的這些設備呢就可以溝通

25
00:01:18,910 --> 00:01:22,950
好  但是呢我們說IP本身提供的服務呢

26
00:01:22,950 --> 00:01:24,750
是一個connectionless的model

27
00:01:24,750 --> 00:01:29,950
就是說我們在送這個IP封包的時候 是不用建連線的

28
00:01:29,950 --> 00:01:32,710
就是把封包準備好就把它丟出去了

29
00:01:32,710 --> 00:01:36,850
那這個internet上面所提供的服務

30
00:01:36,850 --> 00:01:40,880
我們說它是一個unreliable service  不可靠

31
00:01:40,880 --> 00:01:45,50
不可靠是因為說它會盡力幫我們送

32
00:01:45,50 --> 00:01:48,750
可是不保證這個封包呢一定可以送到目的地

33
00:01:48,750 --> 00:01:52,880
那理由是因為說  因為網路裡面有各種狀況

34
00:01:52,880 --> 00:01:56,610
包括干擾  擁擠  然後所謂的overflow

35
00:01:56,610 --> 00:01:57,610
這個buffer滿掉

36
00:01:57,610 --> 00:02:00,80
所以我們說封包可能會lost

37
00:02:00,80 --> 00:02:03,750
然後封包可能會out of order

38
00:02:03,750 --> 00:02:05,550
這個順序也有可能會亂掉

39
00:02:05,550 --> 00:02:08,979
甚至可能會發生我們叫duplicate copy

40
00:02:08,979 --> 00:02:13,549
我送一個封包對方收到兩個封包或者重複收到這個封包

41
00:02:13,550 --> 00:02:17,210
那甚至說這個封包在網路上面呢

42
00:02:17,210 --> 00:02:21,750
可能會經歷一個非常長時間的delay

43
00:02:21,750 --> 00:02:23,580
因為他上面繞圈子嘛

44
00:02:23,580 --> 00:02:26,610
那最後呢很久很久以後才到

45
00:02:26,610 --> 00:02:29,180
這個都會引發一些所謂的困擾

46
00:02:29,180 --> 00:02:31,750
就是說IP這個internet呢

47
00:02:31,750 --> 00:02:35,310
基本上是提供所謂的unreliable service

48
00:02:35,310 --> 00:02:36,510
不可靠的服務

49
00:02:36,510 --> 00:02:40,49
好  那我們也介紹了說Router怎麼運作

50
00:02:40,50 --> 00:02:42,150
我們說router本身收到一個封包

51
00:02:42,150 --> 00:02:46,980
就把它的那個destination的IP把它拿出來

52
00:02:46,980 --> 00:02:49,109
然後去查一個routing table

53
00:02:49,110 --> 00:02:52,380
查這個表就知道說這個封包應該往哪裡去

54
00:02:52,380 --> 00:02:55,750
我們說如果這個  這個IP本身

55
00:02:55,750 --> 00:02:59,80
是跟這個router所直接相連的網路

56
00:02:59,80 --> 00:03:00,250
我們就要直接送給它

57
00:03:00,250 --> 00:03:02,450
那不然的話是間接的話

58
00:03:02,450 --> 00:03:04,579
我們就要送給另外一個router

59
00:03:04,580 --> 00:03:07,710
那我們說這個routing table怎麼來呢

60
00:03:07,710 --> 00:03:11,110
Routing table本身就是靠routing protocol

61
00:03:11,110 --> 00:03:13,580
來建造這個routing table

62
00:03:13,580 --> 00:03:17,610
那這個routing protocol有哪一些呢

63
00:03:17,610 --> 00:03:21,710
我們就說有所謂的distance vector  有link state

64
00:03:21,710 --> 00:03:23,980
有這兩種方式來建造

65
00:03:23,980 --> 00:03:25,649
那對於router來講的話

66
00:03:25,650 --> 00:03:28,380
它最重要或者最關鍵的技術呢

67
00:03:28,380 --> 00:03:31,280
就在於所謂的routing table的lookup

68
00:03:31,280 --> 00:03:34,580
因為每一個封包進來都要去查表

69
00:03:34,580 --> 00:03:38,380
所以查表的速度就非常非常的重要

70
00:03:38,380 --> 00:03:43,380
那我們說這個router呢越靠近這個網路的核心

71
00:03:43,380 --> 00:03:47,510
因為越核心它的封包的流量就越多

72
00:03:47,510 --> 00:03:54,679
那封包的流量越多數量越多它查表的這個要求就越嚴格嘛

73
00:03:54,680 --> 00:03:55,780
因為速度要更快

74
00:03:55,780 --> 00:03:59,50
所以我們說這個routing table的lookup

75
00:03:59,50 --> 00:04:01,80
是一個很關鍵的技術

76
00:04:01,80 --> 00:04:02,710
就是說你有沒有辦法設計一個

77
00:04:02,710 --> 00:04:05,910
非常非常快速的查表方式

78
00:04:05,910 --> 00:04:10,609
那我們也介紹了什麼叫做IP subnetting

79
00:04:10,610 --> 00:04:15,310
就是說因為我們在IP address的分類裡面

80
00:04:15,310 --> 00:04:18,110
有分為所謂的class A  class B  class C

81
00:04:18,110 --> 00:04:21,10
那class A呢是一個非常大的網路

82
00:04:21,10 --> 00:04:25,849
那class B是比較中型的網路  Class C是一個小型的網路

83
00:04:25,850 --> 00:04:28,480
但是如果只分A  B  C

84
00:04:28,480 --> 00:04:32,880
那我們在分配這個address給一個class A可能太大了

85
00:04:32,880 --> 00:04:34,650
給一個class B也可能太大

86
00:04:34,650 --> 00:04:37,650
那給一個class C又不夠等等

87
00:04:37,650 --> 00:04:42,909
所以我們就說我們把class A跟B  這樣它的host

88
00:04:42,910 --> 00:04:46,210
因為我們知道IP位址裡面有所謂的network的number

89
00:04:46,210 --> 00:04:50,210
跟host的number  我們把這個host number

90
00:04:50,210 --> 00:04:54,349
因為它很大  所以再切割一下

91
00:04:54,350 --> 00:04:56,110
所謂的subnetting的觀念

92
00:04:56,110 --> 00:05:00,650
等於說把這個網路再切成子網路

93
00:05:00,650 --> 00:05:03,810
好  那我們怎麼知道這個子網路到底是多大呢

94
00:05:03,810 --> 00:05:07,410
所以引進了所謂的subnet mask的觀念

95
00:05:07,410 --> 00:05:09,780
就是我們用這個所謂的遮罩

96
00:05:09,780 --> 00:05:14,549
來代表說這個子網路的這個大小是多少

97
00:05:14,550 --> 00:05:18,180
這個遮罩本身我們說就是用一些1

98
00:05:18,180 --> 00:05:22,50
來代表這個bit你要不要考慮  要不要去算

99
00:05:22,50 --> 00:05:25,280
像我們這個說255.255.255.0

100
00:05:25,280 --> 00:05:27,710
這個255就是8個1嘛

101
00:05:27,710 --> 00:05:30,710
所以3個255就是24個1

102
00:05:30,710 --> 00:05:32,310
也就是說這個子網路呢

103
00:05:32,310 --> 00:05:35,180
它這個subnet的mask就是24個bits

104
00:05:35,180 --> 00:05:37,810
那它的後面的  後面就是它的

105
00:05:37,810 --> 00:05:40,310
我們講它的這個子網路的規模

106
00:05:40,310 --> 00:05:43,580
後面子網路的規模因為只剩下一個byte

107
00:05:43,580 --> 00:05:46,950
它就是256這個意思

108
00:05:46,950 --> 00:05:48,310
好  我們說

109
00:05:48,310 --> 00:05:52,280
雖然把一個這個網路  class A或class B

110
00:05:52,280 --> 00:05:55,750
因為所謂的子網路的觀念的引進

111
00:05:55,750 --> 00:05:57,880
我們可以分配的更細膩

112
00:05:57,880 --> 00:06:00,909
就是說我可能本來要分配給一個B的

113
00:06:00,910 --> 00:06:02,380
這個效率可能不夠好

114
00:06:02,380 --> 00:06:07,610
因為給一個class B就是給它六萬多個IP 六萬多個IP

115
00:06:07,610 --> 00:06:10,480
那這個單位可能沒有那麼多IP的需求

116
00:06:10,480 --> 00:06:14,150
或者沒有那麼多電腦  那我們給它一個class B就浪費嘛

117
00:06:14,150 --> 00:06:16,609
我們就給它一些所謂的子網路

118
00:06:16,610 --> 00:06:19,250
那讓它這個使用的更精準一點

119
00:06:19,250 --> 00:06:22,980
可是呢我們給它更多的這種所謂的子網路

120
00:06:22,980 --> 00:06:27,380
那相對那個routing table  就要有更多的entry

121
00:06:27,380 --> 00:06:29,750
因為每一個網路都要有一個對應的entry

122
00:06:29,750 --> 00:06:33,650
那我們就說我們引進的叫做classless

123
00:06:33,650 --> 00:06:38,780
Classless routing就是我們把這個class A  B  C

124
00:06:38,780 --> 00:06:42,380
這種所謂的很嚴格的這個規格

125
00:06:42,380 --> 00:06:44,909
就是A是多大  B是多大  C是多大

126
00:06:44,910 --> 00:06:47,980
我們就把它打破  叫做classless

127
00:06:47,980 --> 00:06:50,250
那它的routing的方式呢

128
00:06:50,250 --> 00:06:53,710
我們叫做classless inter-domain routing

129
00:06:53,710 --> 00:06:55,450
叫做CIDR  C  I  D  R

130
00:06:55,450 --> 00:06:56,510
好  那我們說

131
00:06:56,510 --> 00:06:58,610
在這個CIDR的架構之下呢

132
00:06:58,610 --> 00:07:02,80
我們很多route呢是把它累積起來

133
00:07:02,80 --> 00:07:04,650
我們可以把一些  一些這個

134
00:07:04,650 --> 00:07:09,750
所謂的route把它merge變成一個entry

135
00:07:09,750 --> 00:07:13,180
那這樣來減少整個routing table的size

136
00:07:13,180 --> 00:07:18,880
譬如說介紹了所謂的prefix還有prefix length

137
00:07:18,880 --> 00:07:25,710
像這個例子  譬如說192.4.16/21

138
00:07:25,710 --> 00:07:30,479
那前面這個192.4.16就是prefix

139
00:07:30,480 --> 00:07:32,980
那一條斜線後面這個21呢

140
00:07:32,980 --> 00:07:35,480
我們說這叫做prefix length

141
00:07:35,480 --> 00:07:37,780
那prefix length代表是說

142
00:07:37,780 --> 00:07:40,210
好  那這樣的一個entry

143
00:07:40,210 --> 00:07:44,10
它就是代表8個class C的網路

144
00:07:44,10 --> 00:07:46,680
等於說我們如果有8個連續

145
00:07:46,680 --> 00:07:48,280
我們特別強調當然要連續

146
00:07:48,280 --> 00:07:51,109
8個連續的class C的網路

147
00:07:51,110 --> 00:07:56,910
當然是從192.4.16開始  那8個

148
00:07:56,910 --> 00:08:02,680
它就可以用一個這樣的這個所謂的prefix來表達它

149
00:08:02,680 --> 00:08:05,480
那我們說這個你注意要是說

150
00:08:05,480 --> 00:08:06,580
放在這個router裡面

151
00:08:06,580 --> 00:08:10,580
我們的routing table size就會減少

152
00:08:10,580 --> 00:08:12,80
從8個就變成1個

153
00:08:12,80 --> 00:08:14,810
好  那如果說我們再舉個例子

154
00:08:14,810 --> 00:08:19,380
我們說如果是192.4.16  如果是/22

155
00:08:19,380 --> 00:08:25,150
我們說這個slash後面這個所謂的prefix的長度是22的話

156
00:08:25,150 --> 00:08:28,250
它就代表4個class C的網路

157
00:08:28,250 --> 00:08:30,510
連在一起的4個class C網路

158
00:08:30,510 --> 00:08:35,280
也就是說本來應該是4個entry  4項這個route

159
00:08:35,280 --> 00:08:39,10
就變成1項  那就看我們在分配的時候呢

160
00:08:39,10 --> 00:08:42,909
這個class C  它的連  連在一起的狀況

161
00:08:42,909 --> 00:08:44,79
當然可以有更多

162
00:08:44,80 --> 00:08:48,410
如果我們  譬如說我們如果用slash我們講20的話

163
00:08:48,410 --> 00:08:52,10
它就代表呢是16個  16個

164
00:08:52,10 --> 00:08:55,280
那所以這個可以根據我們實際的分配的狀況

165
00:08:55,280 --> 00:09:00,150
等於說我們目的是要減少這個routing table的size

166
00:09:00,150 --> 00:09:05,610
讓多個網路的這個路徑把它合在一起

167
00:09:05,610 --> 00:09:07,550
變成一個  變成一個

168
00:09:07,550 --> 00:09:11,479
這樣可以大量的減少這個routing table的這個size

169
00:09:11,480 --> 00:09:13,150
好  那我們也說

170
00:09:13,150 --> 00:09:16,480
一個IP  一個  對不起  一個主機

171
00:09:16,480 --> 00:09:19,680
它的網卡的位址分兩個

172
00:09:19,680 --> 00:09:21,949
一個是網卡的MAC

173
00:09:21,950 --> 00:09:23,450
那網卡的MAC address呢

174
00:09:23,450 --> 00:09:27,410
在這個網卡生產的時候呢就已經燒錄在裡面了

175
00:09:27,410 --> 00:09:30,510
那但是它的IP位址是可以設定的

176
00:09:30,510 --> 00:09:32,150
所以說我們一般一個電腦

177
00:09:32,150 --> 00:09:35,709
它需要有什麼樣的IP  位址相關的資料

178
00:09:35,710 --> 00:09:36,810
第一個它要有IP位址

179
00:09:36,810 --> 00:09:39,579
然後它還要有它的subnet mask

180
00:09:39,580 --> 00:09:41,850
因為我們剛剛提到  有介紹subnet的觀念嘛

181
00:09:41,850 --> 00:09:44,880
所以通常會有一個  這個電腦的IP位址

182
00:09:44,880 --> 00:09:46,950
它的subnet的mask

183
00:09:46,950 --> 00:09:49,610
還有它的domain-name server  Domain-name

184
00:09:49,610 --> 00:09:51,710
最後就是它的default router

185
00:09:51,710 --> 00:09:55,110
因為我們在送封包的時候

186
00:09:55,110 --> 00:09:58,880
會先檢查說那你要通訊的對象是不是呢

187
00:09:58,880 --> 00:10:02,750
跟你在同一個網路上面  同一個網路

188
00:10:02,750 --> 00:10:03,950
就是說不用經過router

189
00:10:03,950 --> 00:10:06,780
那如果是在同一個網路你就直接送給它

190
00:10:06,780 --> 00:10:10,980
如果不在同一個網路上面你就必須經過router

191
00:10:10,980 --> 00:10:13,410
所以我們說每一個host呢裡面

192
00:10:13,410 --> 00:10:15,680
都要有這個default router

193
00:10:15,680 --> 00:10:20,849
代表是說當你想通訊的對象跟你不在同一個網路上面

194
00:10:20,850 --> 00:10:23,50
那你就必須丟給這個router

195
00:10:23,50 --> 00:10:25,880
所以我們說一個  一個host

196
00:10:25,880 --> 00:10:31,80
一個電腦本身它在IP相關的這個設定呢至少有四個

197
00:10:31,80 --> 00:10:34,480
它的IP位址  它的子網路的遮罩

198
00:10:34,480 --> 00:10:36,280
就是IP subnet的mask

199
00:10:36,280 --> 00:10:39,280
它的domain-name server  它的default router

200
00:10:39,280 --> 00:10:41,50
那這四個要設定

201
00:10:41,50 --> 00:10:45,310
一般如果沒有一些經驗或者相關的know how的話

202
00:10:45,310 --> 00:10:49,109
也不容易設定  所以呢有發展一個叫做

203
00:10:49,110 --> 00:10:51,110
那我可不可以自動幫我設定

204
00:10:51,110 --> 00:10:53,180
就是我一開機之後呢

205
00:10:53,180 --> 00:10:55,150
我去跟一個什麼server溝通

206
00:10:55,150 --> 00:10:58,10
然後我就自動取得這個四個東西進來

207
00:10:58,10 --> 00:10:59,910
那我就不用自己設定嘛

208
00:10:59,910 --> 00:11:04,10
那我們說這個方式呢就叫做DHCP

209
00:11:04,10 --> 00:11:07,350
叫dynamic host configuration protocol

210
00:11:07,350 --> 00:11:11,80
就是我們一開機我們就去找一個叫做DHCP server

211
00:11:11,80 --> 00:11:14,910
那找到它  它就給我像我現在的IP

212
00:11:14,910 --> 00:11:16,550
那我的subnet mask

213
00:11:16,550 --> 00:11:18,349
然後我的domain-name server

214
00:11:18,350 --> 00:11:21,10
像是我的Default router  它就全部告訴我了

215
00:11:21,10 --> 00:11:25,350
那這樣可以大幅的減少這個IP設定的這個困難度

216
00:11:25,350 --> 00:11:29,180
好  那我們說在internet protocol裡面呢

217
00:11:29,180 --> 00:11:34,349
有一個非常重要的這個所謂的輔助的protocol呢

218
00:11:34,350 --> 00:11:38,310
叫做ICMP我們叫internet control message protocol

219
00:11:38,310 --> 00:11:40,479
我們說這個protocol幹嘛呢

220
00:11:40,480 --> 00:11:44,410
因為我們說IP本身的服務是unreliable

221
00:11:44,410 --> 00:11:46,480
就是可能因為封包會掉

222
00:11:46,480 --> 00:11:52,10
不管是譬如說因為網路斷掉或者最後的那個目的地

223
00:11:52,10 --> 00:11:55,580
那個沒有開機或者說我們封包被切割

224
00:11:55,580 --> 00:11:57,950
最後組合的時候失敗了

225
00:11:57,950 --> 00:11:59,780
或者封包在網路上面繞

226
00:11:59,780 --> 00:12:02,110
繞半天繞不出去呢

227
00:12:02,110 --> 00:12:03,580
結果被router把它丟掉

228
00:12:03,580 --> 00:12:08,980
就是IP的網路呢是不可靠  封包可能會掉

229
00:12:08,980 --> 00:12:13,80
好  那這個ICMP呢就  就是說

230
00:12:13,80 --> 00:12:15,180
當你的封包出了問題的時候

231
00:12:15,180 --> 00:12:21,449
我們透過ICMP把這個狀態或者原因反應給source

232
00:12:21,450 --> 00:12:24,510
也就是說雖然是不可靠  你的封包就掉了

233
00:12:24,510 --> 00:12:27,950
但是我至少網路告訴你說  你的封包為什麼掉了

234
00:12:27,950 --> 00:12:30,210
但是我不幫你重送  掉了就掉了

235
00:12:30,210 --> 00:12:32,610
這個封包就沒有了  但是我告訴你

236
00:12:32,610 --> 00:12:36,650
你的封包為什麼掉了  那你可能知道這個原因

237
00:12:36,650 --> 00:12:40,910
可能可以做一些所謂的相對的處置  好  這叫做ICMP

238
00:12:40,910 --> 00:12:42,650
好  那我們這章最後面呢

239
00:12:42,650 --> 00:12:45,510
就介紹了兩個非常經典

240
00:12:45,510 --> 00:12:48,50
這種所謂的routing protocol的這個方式

241
00:12:48,50 --> 00:12:49,380
我們說第一個呢

242
00:12:49,380 --> 00:12:51,780
就所謂的distance vector

243
00:12:51,780 --> 00:12:54,550
那我們說distance vector本身

244
00:12:54,550 --> 00:12:55,750
它的特色

245
00:12:55,750 --> 00:12:59,580
就第一個它是把整個routing table

246
00:12:59,580 --> 00:13:02,350
送給直接相鄰的neighbor

247
00:13:02,350 --> 00:13:06,580
是把routing table送給相鄰的neighbor

248
00:13:06,580 --> 00:13:09,950
然後呢  這個distance vector的特性就是說

249
00:13:09,950 --> 00:13:13,750
對於好消息傳得比較快

250
00:13:13,750 --> 00:13:16,450
Good news  就是譬如說網路變快了

251
00:13:16,450 --> 00:13:19,980
或者原來斷線的現在變成恢復了

252
00:13:19,980 --> 00:13:23,810
好消息傳得快  那壞消息呢傳得慢

253
00:13:23,810 --> 00:13:27,780
這是它的特色  那我們說distance vector呢

254
00:13:27,780 --> 00:13:29,949
在某些特殊的狀況之下

255
00:13:29,950 --> 00:13:33,950
可能會出現所謂的count-to-infinity的這種problem

256
00:13:33,950 --> 00:13:38,350
就是說它這個會  這個所謂的路徑的cost

257
00:13:38,350 --> 00:13:40,450
會一直增加  一直增加

258
00:13:40,450 --> 00:13:42,580
就不穩定  我們叫做unstable

259
00:13:42,580 --> 00:13:44,450
就是怎麼沒有辦法收斂

260
00:13:44,450 --> 00:13:47,350
這個cost越來越多  越來越多

261
00:13:47,350 --> 00:13:48,880
我們叫做count-to-infinity的問題

262
00:13:48,880 --> 00:13:50,550
解這個問題呢

263
00:13:50,550 --> 00:13:52,410
我們說有一個split-horizon

264
00:13:52,410 --> 00:13:57,380
就是說如果我這個link或這個route呢

265
00:13:57,380 --> 00:13:59,680
是從隔壁的這個router學到的

266
00:13:59,680 --> 00:14:03,349
是它告訴我說我到哪個地方有一條路

267
00:14:03,350 --> 00:14:07,80
這個路本身是從隔壁的router學來的

268
00:14:07,80 --> 00:14:09,580
那我再告訴這個隔壁的時候呢

269
00:14:09,580 --> 00:14:12,650
我就不把這個路告訴它  因為我告訴它

270
00:14:12,650 --> 00:14:15,510
有點是多餘的  因為這個路是它跟我講

271
00:14:15,510 --> 00:14:18,80
這個路是隔壁跟我講的

272
00:14:18,80 --> 00:14:20,550
那我就不用跟它講說這條路了嘛

273
00:14:20,550 --> 00:14:22,50
因為這條路是它給我的

274
00:14:22,50 --> 00:14:27,849
我們就split horizon就是說從隔壁的router學來的路徑

275
00:14:27,850 --> 00:14:30,110
你就不用再告訴隔壁

276
00:14:30,110 --> 00:14:33,410
不回應  不回復這樣的路徑

277
00:14:33,410 --> 00:14:38,880
那我們說還有一個更強的這種protocol就是

278
00:14:38,880 --> 00:14:41,780
所謂的split horizon with所謂的poison reverse

279
00:14:41,780 --> 00:14:43,949
就是說我回應它

280
00:14:43,950 --> 00:14:48,280
但是回應它  告訴它說這條路經過我是無限大

281
00:14:48,280 --> 00:14:50,79
就根本不要走我這條路的意思

282
00:14:50,80 --> 00:14:52,150
就是說假設A

283
00:14:52,150 --> 00:14:55,780
假設左邊是A  右邊是B

284
00:14:55,780 --> 00:14:58,350
就B告訴A說有一條路

285
00:14:58,350 --> 00:15:00,580
那等一下A再告訴B的時候

286
00:15:00,580 --> 00:15:05,750
就跟它說經過它到B  就是走別的路的話

287
00:15:05,750 --> 00:15:07,280
這個是無限大

288
00:15:07,280 --> 00:15:12,949
就不要  不要指望說透過A可以到別的地方

289
00:15:12,950 --> 00:15:14,910
因為這個路根本就是B找出來的

290
00:15:14,910 --> 00:15:17,709
路是B找出來的  B告訴A的

291
00:15:17,710 --> 00:15:20,580
所以A在告訴B的時候就跟它說

292
00:15:20,580 --> 00:15:23,650
這條路呢基本上不要經過我

293
00:15:23,650 --> 00:15:26,209
因為是你找出來的  所以就用無限大

294
00:15:26,210 --> 00:15:29,350
我們叫做所謂的split horizon with poison reverse

295
00:15:29,350 --> 00:15:33,980
這樣是更強烈的把這個關係表達的更清楚

296
00:15:33,980 --> 00:15:38,850
那我們說這種distance vector在我們實際的internet上面

297
00:15:38,850 --> 00:15:40,750
有一個非常有名的protocol

298
00:15:40,750 --> 00:15:44,310
就叫做routing information protocol  RIP

299
00:15:44,310 --> 00:15:49,280
RIP本身就是最經典的distance vector

300
00:15:49,280 --> 00:15:51,810
它就是用distance vector的這個方法

301
00:15:51,810 --> 00:15:55,880
來跟大家  跟其他的router交換

302
00:15:55,880 --> 00:15:57,980
就是它把自己的routing table

303
00:15:57,980 --> 00:16:00,380
全部routing table的

304
00:16:00,380 --> 00:16:03,280
整個routing table告訴我的neighbor

305
00:16:03,280 --> 00:16:04,750
那neighbor再告訴neighbor

306
00:16:04,750 --> 00:16:07,650
那這樣子就是不斷的一步一步的擴散出去

307
00:16:07,650 --> 00:16:12,209
好  那我們說最後呢我們有介紹什麼叫做link state

308
00:16:12,210 --> 00:16:16,980
那link state呢跟distance vector它的作法剛好倒過來

309
00:16:16,980 --> 00:16:24,850
Link state本身是把直接相鄰的這個連線告訴所有的router

310
00:16:24,850 --> 00:16:27,580
我們一直在強調就是說

311
00:16:27,580 --> 00:16:32,550
distance vector是把自己的routing table告訴你的neighbor

312
00:16:32,550 --> 00:16:38,180
link state是把自己跟neighbor的連線告訴所有的其他router

313
00:16:38,180 --> 00:16:40,609
那因為要告訴所有其他router

314
00:16:40,610 --> 00:16:44,510
而且這種告訴  這種其他router呢必須要可靠

315
00:16:44,510 --> 00:16:50,210
因為其他router呢要靠這個資料來建構整個網路的拓墣

316
00:16:50,210 --> 00:16:53,810
所以我們說它要做到reliable的broadcasting

317
00:16:53,810 --> 00:16:57,109
要做很可靠的這個flooding  傳播

318
00:16:57,110 --> 00:16:59,550
然後每一個router呢收到這些

319
00:16:59,550 --> 00:17:04,280
每一個router收到其他router的LSP

320
00:17:08,210 --> 00:17:12,810
當然這裡講整個網路是指用這個protocol的

321
00:17:12,810 --> 00:17:16,149
我們講AS  AS叫做autonomous的system

322
00:17:16,150 --> 00:17:19,50
就是一個所謂的管理區或者行政區

323
00:17:19,50 --> 00:17:20,450
譬如說一個大學

324
00:17:20,450 --> 00:17:23,80
就是說這個大學裡面這些router

325
00:17:23,79 --> 00:17:25,649
都受這個大學的我們講計中來管理嘛

326
00:17:25,650 --> 00:17:28,810
那在這個可控管的範圍之內

327
00:17:28,810 --> 00:17:32,810
那我們就會讓這個router呢有這個拓墣

328
00:17:32,810 --> 00:17:34,580
然後呢根據這個拓墣呢

329
00:17:34,580 --> 00:17:36,350
我們就用一個演算法

330
00:17:36,350 --> 00:17:39,250
我們說最經典就是dijkstra的algorithm

331
00:17:39,250 --> 00:17:46,50
它去算從這個router到其他所有router的這個最短路徑

332
00:17:46,50 --> 00:17:48,379
那根據這個最短路徑呢

333
00:17:48,380 --> 00:17:50,450
就可以造出那個routing table來

334
00:17:50,450 --> 00:17:51,350
好  那我們說

335
00:17:51,350 --> 00:17:53,610
這個用link state的方法

336
00:17:53,610 --> 00:17:57,949
最經典的這個routing protocol呢就是OSPF

337
00:17:57,950 --> 00:18:00,410
就是open shortest path first

338
00:18:00,410 --> 00:18:05,350
它就是用link stage的方法來建造它的routing protocol

339
00:18:05,350 --> 00:18:09,980
好  那以上呢就是我們對這一章的整個摘要的這個說明

