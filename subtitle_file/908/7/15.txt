1
00:00:08,880 --> 00:00:14,650
好，那接下來我們來介紹另外一種routing protocol的這種方式

2
00:00:14,650 --> 00:00:15,950
叫做所謂的link state

3
00:00:15,950 --> 00:00:19,509
那link state本身跟distance vector呢不一樣

4
00:00:19,510 --> 00:00:21,10
在哪個地方不一樣

5
00:00:21,10 --> 00:00:22,610
我們來介紹一下

6
00:00:22,610 --> 00:00:26,50
我們說所謂的link state的routing呢

7
00:00:26,50 --> 00:00:27,980
它最大的特色在於說

8
00:00:27,980 --> 00:00:32,810
第一個它是把它neighbor

9
00:00:32,810 --> 00:00:34,450
它的neighbor的link

10
00:00:34,450 --> 00:00:37,350
就是它的跟這個neighbor連接的狀況呢

11
00:00:37,350 --> 00:00:39,650
告訴所有的node

12
00:00:39,650 --> 00:00:42,550
所以這個跟distance vector不一樣

13
00:00:42,550 --> 00:00:43,779
所以我們特別再強調一下

14
00:00:43,780 --> 00:00:48,980
Distance vector本身是把routing table告訴neighbor

15
00:00:48,980 --> 00:00:53,50
把自己的routing table  全部的routing table

16
00:00:53,50 --> 00:00:57,650
告訴你的neighbor  這是distance vector

17
00:00:57,650 --> 00:00:58,350
那link state呢

18
00:00:58,350 --> 00:00:59,910
我們說剛好倒過來

19
00:00:59,910 --> 00:01:04,479
它把它跟neighbor的連線  neighbor的連線

20
00:01:04,480 --> 00:01:08,510
這個link告訴所有的node

21
00:01:08,510 --> 00:01:12,280
一個是把routing table告訴neighbor

22
00:01:12,280 --> 00:01:15,710
然後neighbor當然再把它的routing table告訴neighbor

23
00:01:15,710 --> 00:01:20,50
這個等於說distance vector它只告訴neighbor

24
00:01:20,50 --> 00:01:23,310
可是它把整個routing table告訴neighbor

25
00:01:23,310 --> 00:01:26,80
那link state呢我們說倒過來

26
00:01:26,80 --> 00:01:30,10
它把它跟neighbor的link  跟neighbor的link

27
00:01:30,10 --> 00:01:32,80
告訴所有的router

28
00:01:32,80 --> 00:01:36,550
所以它必須把這個它跟neighbor的link的狀態

29
00:01:36,550 --> 00:01:39,9
送給所有的router

30
00:01:39,10 --> 00:01:41,450
我們等一下會講它怎麼送給所有的router

31
00:01:41,450 --> 00:01:44,380
所以我們說這個link state呢

32
00:01:44,380 --> 00:01:46,50
它最大的特色就是說

33
00:01:46,50 --> 00:01:51,350
它會把跟它直接相連的這個link的狀態

34
00:01:51,350 --> 00:01:55,380
譬如說速度有多少  cost是多少等等

35
00:01:55,380 --> 00:01:58,80
告訴所有的node

36
00:01:58,80 --> 00:02:00,50
這是它最大的特色

37
00:02:00,50 --> 00:02:04,910
好  那它怎麼把它跟所謂的neighbor的link呢

38
00:02:04,910 --> 00:02:06,280
告訴所有的node呢

39
00:02:06,280 --> 00:02:11,250
所以它必須去準備一個我們叫做link state的packet  LSP

40
00:02:11,250 --> 00:02:14,750
等於說它要把跟它的neighbor的連線狀態

41
00:02:14,750 --> 00:02:18,410
通通把它打包成一個所謂的packet

42
00:02:18,410 --> 00:02:21,10
因為我要告訴所有的node嘛

43
00:02:21,10 --> 00:02:24,109
所以我會送封包給所有的其他的router

44
00:02:24,110 --> 00:02:27,580
那我這個封包呢  就叫做link state packet

45
00:02:27,580 --> 00:02:28,780
裡面有什麼呢

46
00:02:28,780 --> 00:02:30,650
第一個就是說ID

47
00:02:30,650 --> 00:02:32,510
ID就是router的ID

48
00:02:32,510 --> 00:02:37,79
那這個link state的ID是哪一個router送出來的

49
00:02:37,80 --> 00:02:42,410
因為每一個router都要把它跟周邊的這個連線狀態呢

50
00:02:42,410 --> 00:02:44,680
送給所有的router嘛  所以你可以想像得到

51
00:02:44,680 --> 00:02:47,450
每一個router都會丟出LSP

52
00:02:47,450 --> 00:02:50,850
每一個router都會送給所有人

53
00:02:50,850 --> 00:02:55,280
所以它會有一陣子的這個LSP在網路上面這樣子送

54
00:02:55,280 --> 00:03:00,980
所以每一個router都把它的LSP送給所有的router

55
00:03:00,980 --> 00:03:07,250
也就是說任何一個router都會收到其他router送來的LSP

56
00:03:07,250 --> 00:03:09,80
簡單的講

57
00:03:09,80 --> 00:03:12,850
譬如說我們網路上面有10個router  10個router

58
00:03:12,850 --> 00:03:18,549
那任何一個router都會收到9個  9個LSP

59
00:03:18,550 --> 00:03:19,910
來自不同的router

60
00:03:19,910 --> 00:03:23,880
好  所以第一個我們要知道說那這個LSP是誰送的

61
00:03:23,880 --> 00:03:25,380
因為每個router都會送

62
00:03:25,380 --> 00:03:27,79
所以裡面就有一個ID

63
00:03:27,80 --> 00:03:30,950
來記錄著說這個LSP是哪個router送的

64
00:03:30,950 --> 00:03:34,179
好  LSP裡面最重要是要記錄說

65
00:03:34,180 --> 00:03:39,750
那跟這個router直接相鄰的這個neighbor它們的link

66
00:03:39,750 --> 00:03:41,50
它們的cost

67
00:03:41,50 --> 00:03:44,110
譬如說cost是1阿  是2阿  是3阿

68
00:03:44,110 --> 00:03:47,480
不過因為我們這個牽涉到所謂的cost function

69
00:03:47,480 --> 00:03:48,880
就Cost到底怎麼算

70
00:03:48,880 --> 00:03:52,579
到底是距離呢  速度呢  還是延遲等等

71
00:03:52,580 --> 00:03:53,750
這個cost function

72
00:03:53,750 --> 00:03:55,950
我們這邊就先不仔細談

73
00:03:55,950 --> 00:03:58,480
就說我們反正就有一個cost function

74
00:03:58,480 --> 00:04:02,310
可以算出它跟neighbor的link呢它的cost是多少

75
00:04:02,310 --> 00:04:03,580
那把這個cost呢

76
00:04:03,580 --> 00:04:06,250
就把它放到這個  這個封包裡面去

77
00:04:06,250 --> 00:04:06,980
LSP裡面

78
00:04:06,980 --> 00:04:09,980
好  還有一個很重要就叫sequence number

79
00:04:09,980 --> 00:04:13,350
因為  因為這種LSP呢

80
00:04:13,350 --> 00:04:16,550
一個router丟出去  它會不定時的丟

81
00:04:16,550 --> 00:04:18,350
所以譬如說

82
00:04:18,350 --> 00:04:19,980
原來我丟出去我告訴說

83
00:04:19,980 --> 00:04:22,50
我這個周邊的link的cost是多少

84
00:04:22,50 --> 00:04:24,650
那可能過了兩秒鐘

85
00:04:24,650 --> 00:04:26,710
這個cost有變化了

86
00:04:26,710 --> 00:04:30,150
譬如說link突然斷掉  或者link突然好  突然壅擠

87
00:04:30,150 --> 00:04:33,450
那它就會再送出LSP

88
00:04:33,450 --> 00:04:37,310
只要說我們這link的狀態有任何變化

89
00:04:37,310 --> 00:04:40,910
不管cost變好還是cost變差

90
00:04:40,910 --> 00:04:44,280
我們都要趕快通知  也就是說一個router

91
00:04:44,280 --> 00:04:47,880
它會把它的LSP送給其他的router

92
00:04:47,880 --> 00:04:51,310
而且呢可能會送很多個LSP

93
00:04:51,310 --> 00:04:54,50
就是譬如說cost有變化我就送一次

94
00:04:54,50 --> 00:04:55,810
那有變化再送一次嘛

95
00:04:55,810 --> 00:04:58,380
三秒鐘之後又有變化我再送一次

96
00:04:58,380 --> 00:05:02,110
那我們這個送出去的這個LSP

97
00:05:02,110 --> 00:05:04,310
它要送給所有的router

98
00:05:04,310 --> 00:05:06,950
所以這個router要知道說

99
00:05:06,950 --> 00:05:11,280
那這是第幾個從某一個router來的第幾個

100
00:05:11,280 --> 00:05:14,479
因為每一個router有點說它會送一系列的

101
00:05:14,480 --> 00:05:18,880
每一個router呢都可能送出一系列的LSP

102
00:05:18,880 --> 00:05:21,580
所以我們上面給它一個編號  Sequence number

103
00:05:21,580 --> 00:05:24,280
那就是按照0  1  2  3

104
00:05:24,280 --> 00:05:25,280
這樣一直增加

105
00:05:25,280 --> 00:05:27,150
好  這樣我們才知道說

106
00:05:27,150 --> 00:05:29,750
當一個router收到一個LSP的時候

107
00:05:29,750 --> 00:05:30,550
我們知道說

108
00:05:30,550 --> 00:05:32,780
這個LSP是從哪一個router來的

109
00:05:32,780 --> 00:05:35,780
而且是從這個router送出的第幾個

110
00:05:35,780 --> 00:05:37,250
因為我們給它編號了嘛

111
00:05:37,250 --> 00:05:40,610
好  另外還有我們為了避免說這個LSP

112
00:05:40,610 --> 00:05:43,510
在網路上面譬如說送得太久

113
00:05:43,510 --> 00:05:46,50
那我們也把它設定一個叫time-to-live

114
00:05:46,50 --> 00:05:49,510
Time-to-live  就是說經過每一個router轉送

115
00:05:49,510 --> 00:05:52,580
因為我們等一下說  它會做廣播嘛

116
00:05:52,580 --> 00:05:55,10
廣播給所有的router

117
00:05:55,10 --> 00:05:59,810
好  那每經過一個router幫它做廣播的話那它就減1

118
00:05:59,810 --> 00:06:03,210
那等到這個  這個值被減到0的話

119
00:06:03,210 --> 00:06:07,380
這個封包呢就會被router把它  把它discard掉

120
00:06:07,380 --> 00:06:13,150
避免這個LSP在網路上面被不斷的再廣播的意思

121
00:06:13,150 --> 00:06:16,10
好  那我們再來就來說

122
00:06:16,10 --> 00:06:19,310
那我們怎麼做到所謂的reliable flooding

123
00:06:19,310 --> 00:06:22,110
因為每一個router呢

124
00:06:22,110 --> 00:06:26,610
它必須把它的這個LSP呢

125
00:06:26,610 --> 00:06:30,350
我們說它必須把它送給所有的router嘛

126
00:06:30,350 --> 00:06:31,980
那送給所有的router

127
00:06:31,980 --> 00:06:34,880
就相當於是flooding  相當於是廣播

128
00:06:35,810 --> 00:06:39,280
而且它必須做到所謂的reliable  要可靠的

129
00:06:39,280 --> 00:06:42,479
因為如果有一個  一個router

130
00:06:42,480 --> 00:06:46,210
剛剛提到我這個網路裡面  如果有10個router

131
00:06:46,210 --> 00:06:50,979
那每一個router應該要收到其他9個router的LSP

132
00:06:50,980 --> 00:06:53,410
因為我收到這些之後

133
00:06:53,410 --> 00:06:56,450
我才知道這個網路的拓墣是怎麼樣

134
00:06:56,450 --> 00:06:58,780
因為我們必須知道網路的拓墣

135
00:06:58,780 --> 00:07:01,650
我才能算出我們講的shortest path

136
00:07:01,650 --> 00:07:06,609
我要做那個路徑嘛  那如果說有一個router的LSP

137
00:07:06,610 --> 00:07:11,650
在這個傳送的過程當中掉了  因為LSP也是一個封包嘛

138
00:07:11,650 --> 00:07:14,49
封包可能也因為譬如說干擾

139
00:07:14,50 --> 00:07:16,150
就錯誤掉了  被drop掉了

140
00:07:16,150 --> 00:07:19,810
那個就很麻煩  因為變成說我們有收到

141
00:07:19,810 --> 00:07:21,680
我如果沒有收到的話

142
00:07:21,680 --> 00:07:25,610
我就沒辦法建構出很完整的這個所謂的拓墣

143
00:07:25,610 --> 00:07:29,450
那在這個distance  在link stage的這種演算法裡面

144
00:07:29,450 --> 00:07:35,710
就是每一個router它因為會收集到其他所有router

145
00:07:35,710 --> 00:07:38,510
寄來的這個連線的架構嘛

146
00:07:38,510 --> 00:07:39,909
譬如說它跟那些router相連

147
00:07:39,910 --> 00:07:42,510
所以我們如果說有一個router可以收到

148
00:07:42,510 --> 00:07:46,180
所有其他router寄來的這個LSP的話

149
00:07:46,180 --> 00:07:49,780
我們就可以畫出整個網路的拓墣

150
00:07:49,780 --> 00:07:53,380
那有網路的拓墣能夠把它建構出來之後

151
00:07:53,380 --> 00:07:55,10
我們再用一個演算法

152
00:07:55,10 --> 00:08:00,310
就可以找到我要到任何一個router的最好的路徑的意思

153
00:08:00,310 --> 00:08:05,550
好  所以我們說  這個reliable是很重要

154
00:08:05,550 --> 00:08:09,210
就是說這個LSP呢  在送給所有其他router的時候呢

155
00:08:09,210 --> 00:08:11,349
必須是非常可靠  因為不能掉

156
00:08:11,350 --> 00:08:16,50
好  所以我們就是說每一個  每一個node

157
00:08:16,310 --> 00:08:17,410
因為我們剛剛提到

158
00:08:17,410 --> 00:08:20,680
它的LSP送來的時候也會有變化嘛

159
00:08:20,680 --> 00:08:23,210
會有編號  1號  2號  3號

160
00:08:23,210 --> 00:08:27,510
因為我們說一個router它周邊的這個link只要有變化

161
00:08:27,510 --> 00:08:30,450
它就會送出新的LSP

162
00:08:30,450 --> 00:08:34,110
那新的LSP上面有一個編號  sequence number

163
00:08:34,110 --> 00:08:38,110
就用最新的  所以我們就每一個node本身它就會說

164
00:08:38,110 --> 00:08:42,980
從每一個router來的LSP  我們只要記錄

165
00:08:42,980 --> 00:08:45,580
我們叫做most recent這種LSP

166
00:08:45,580 --> 00:08:49,650
就是你可能收到1  2  3  編號1  2  3

167
00:08:49,650 --> 00:08:51,10
那你只要記3就好

168
00:08:51,10 --> 00:08:54,550
因為3才是最新的網路狀態嘛

169
00:08:54,550 --> 00:08:55,780
那個1  2就可以不用了

170
00:08:55,780 --> 00:08:57,680
如果你看到3  編號3的話

171
00:08:57,680 --> 00:09:00,109
那編號1跟2的就可以不要

172
00:09:00,110 --> 00:09:02,610
因為我們要的是最新的網路狀態

173
00:09:02,610 --> 00:09:05,880
好  那我們收到這樣的時候

174
00:09:05,880 --> 00:09:08,380
我們就只存最新的

175
00:09:08,380 --> 00:09:12,150
就是那個sequence number最大的那個LSP

176
00:09:12,150 --> 00:09:17,650
然後我們就把這個LSP呢  就把它廣播出去  廣播出去

177
00:09:17,650 --> 00:09:21,310
除了收到的那個link  就是說這個LSP

178
00:09:21,310 --> 00:09:23,79
如果從這個  從這邊進來

179
00:09:23,80 --> 00:09:24,810
我們就從其他port丟出去的意思

180
00:09:24,810 --> 00:09:27,280
不要再送回去了  送回去沒有意義嘛

181
00:09:27,280 --> 00:09:30,650
因為它從這邊來  從左邊來我們就把它送到右邊去

182
00:09:30,650 --> 00:09:32,449
但是不要再送回去的意思

183
00:09:32,450 --> 00:09:35,410
好  因為這種LSP本身

184
00:09:35,410 --> 00:09:39,110
它通常會是我們講periodically

185
00:09:39,110 --> 00:09:43,510
因為它會週期性的或者是說定時或不定時的

186
00:09:43,510 --> 00:09:45,910
我們都會把它送出去  新的嘛

187
00:09:45,910 --> 00:09:47,880
好  每次送的時候呢

188
00:09:47,880 --> 00:09:50,550
我們說我們會增加它的sequence number

189
00:09:50,550 --> 00:09:53,849
那如果說這個router

190
00:09:53,850 --> 00:09:56,210
我們講它重開機  reboot

191
00:09:56,210 --> 00:10:00,180
因為router也有可能因為某種原因我們把它重開機

192
00:10:00,180 --> 00:10:03,150
那重開機的話  Sequence number就把它設成0

193
00:10:03,150 --> 00:10:06,180
就從0開始  那每次收到的時候

194
00:10:06,180 --> 00:10:10,849
我們就把TTL減1  那如果當TTL被減到0

195
00:10:10,850 --> 00:10:14,950
我們就把它丟掉  我們用一個這個動畫呢來看一下

196
00:10:14,950 --> 00:10:18,10
就是說  好  我們現在假設

197
00:10:18,10 --> 00:10:20,80
在這個例子裡面呢

198
00:10:20,80 --> 00:10:23,410
一樣  我們假設現在A呢  node A

199
00:10:23,410 --> 00:10:26,880
它產生了一個所謂的LSP

200
00:10:26,880 --> 00:10:28,780
就link state protocol

201
00:10:28,780 --> 00:10:32,510
那從A開始它就廣播送給它的周邊的

202
00:10:32,510 --> 00:10:35,250
就是它就把LSP送給它的neighbor

203
00:10:35,250 --> 00:10:36,880
當然上面有編號

204
00:10:36,880 --> 00:10:39,780
我們這邊沒有show它的編號  它有一個編號

205
00:10:39,780 --> 00:10:40,949
那我們接下來注意看

206
00:10:40,950 --> 00:10:44,750
收到這個封包的有  有4個嘛

207
00:10:44,750 --> 00:10:51,810
我們說收到這個封包的有這個F  E還有B還有C

208
00:10:51,810 --> 00:10:57,709
然後接下來呢  其中這個三個因為E已經是末端了

209
00:10:57,710 --> 00:11:05,750
E就不會再轉送  但是B  C  F它會再把這個LSP呢再往前送

210
00:11:05,750 --> 00:11:07,910
但是不往回送  所以我們看一下

211
00:11:07,910 --> 00:11:11,680
接下來我們就會看到說B  C跟F呢

212
00:11:11,680 --> 00:11:16,280
它們會把這個封包呢再往前送  再往前送

213
00:11:16,280 --> 00:11:18,250
好  那我們特別注意到

214
00:11:18,250 --> 00:11:20,980
這個時候B送給C的時候

215
00:11:20,980 --> 00:11:22,580
C就發現說

216
00:11:22,580 --> 00:11:25,280
因為我們有  有sequence number  有編號

217
00:11:25,280 --> 00:11:29,380
所以C呢當它看到從B來的封包的時候

218
00:11:29,380 --> 00:11:32,450
就這個地方  這個藍色的  藍色的這個

219
00:11:32,450 --> 00:11:37,150
那C就知道說因為它的sequence number之前已經出現過了

220
00:11:37,150 --> 00:11:39,610
所以它就把它丟棄的意思

221
00:11:39,610 --> 00:11:44,980
那同時當然C已經把這個封包把它複製丟給D了嘛

222
00:11:44,980 --> 00:11:46,650
所以現在已經到這裡

223
00:11:46,650 --> 00:11:49,709
好  那這個時候我們再來接下來看

224
00:11:49,710 --> 00:11:50,980
就是D跟G

225
00:11:50,980 --> 00:11:53,110
那D跟G對它們來講

226
00:11:53,110 --> 00:11:56,450
它們都剛剛好收到這個新的LSP

227
00:11:56,450 --> 00:12:01,480
所以對它們來講 它應該 像D來講應該是往這邊送嘛

228
00:12:01,480 --> 00:12:03,550
那G就往這邊送

229
00:12:03,550 --> 00:12:06,810
因為這個link它目前都還沒有送過

230
00:12:06,810 --> 00:12:10,949
對以廣播的立場就是這個link我還沒有送過

231
00:12:10,950 --> 00:12:13,680
我當然要在上面送一下  所以它就會

232
00:12:13,680 --> 00:12:17,709
我們說D跟G呢就互相對送一個

233
00:12:17,710 --> 00:12:20,450
那對送一個剛好都會被砍掉

234
00:12:20,450 --> 00:12:24,910
因為我們上面有編號  所以對D來講

235
00:12:24,910 --> 00:12:27,780
它剛剛已經從C收到這個封包

236
00:12:27,780 --> 00:12:29,910
編號這個sequence number的

237
00:12:29,910 --> 00:12:32,709
那現在G送來的  它就發現這是重複的

238
00:12:32,710 --> 00:12:36,310
它就把它丟掉  那相對於G來講也是

239
00:12:36,310 --> 00:12:40,280
剛剛G已經從F了收到了一個嘛

240
00:12:40,280 --> 00:12:44,709
那現在呢從D來的這個上面有sequence number

241
00:12:44,710 --> 00:12:46,110
也是重複  它就把它丟掉

242
00:12:46,110 --> 00:12:47,410
那這個時候呢

243
00:12:47,410 --> 00:12:51,250
我們說這個廣播就結束了

244
00:12:51,250 --> 00:12:54,380
我們看  任何一個node都收到這個封包

245
00:12:54,380 --> 00:12:56,550
而且它也把它forward出去

246
00:12:56,550 --> 00:13:00,109
那該被砍掉的都被砍掉了

247
00:13:00,110 --> 00:13:02,380
那也沒有一個link還沒有送過

248
00:13:02,380 --> 00:13:03,610
所以你看每個link都送過了

249
00:13:03,610 --> 00:13:08,110
那這樣的話  就做到了所謂的reliable的flooding

250
00:13:08,110 --> 00:13:13,410
就是說A的這個LSP  就透過這樣廣播的機制

251
00:13:13,410 --> 00:13:16,209
就可以送給所有其他的router

252
00:13:16,210 --> 00:13:21,910
這個是我們說link state本身它要做到所謂的reliable的這個意思

253
00:13:21,910 --> 00:13:26,410
好  那我們說在真正的我們網路上面呢

254
00:13:26,410 --> 00:13:29,110
哪一個protocol是用link state呢

255
00:13:29,110 --> 00:13:35,150
有一個非常有名的protocol就叫做open shortest path first

256
00:13:35,150 --> 00:13:37,79
我們簡稱OSPF

257
00:13:37,80 --> 00:13:42,380
OSPF本身你看這個名稱它就叫所謂的shortest path first

258
00:13:42,380 --> 00:13:44,280
就是它要找最短路徑

259
00:13:44,280 --> 00:13:47,50
那它的做法就是用link state

260
00:13:47,50 --> 00:13:49,310
也就是說每一個router本身呢

261
00:13:49,310 --> 00:13:53,79
它因為跟其他的router

262
00:13:53,80 --> 00:13:57,280
都會收到其它的router的這個剛剛講的LSP嘛

263
00:13:57,280 --> 00:13:59,650
就link state的這個packet

264
00:13:59,650 --> 00:14:02,780
那它會根據這個所收到的這個packet

265
00:14:02,780 --> 00:14:06,650
最後就把整個網路的拓墣把它建構出來

266
00:14:06,650 --> 00:14:08,610
就像我們這個例子裡面

267
00:14:08,610 --> 00:14:11,410
我們說這個C  這個node

268
00:14:11,410 --> 00:14:16,910
它會收到B的  它會收到A的  它會收到其它的router

269
00:14:16,910 --> 00:14:17,550
通通會進來

270
00:14:17,550 --> 00:14:19,310
然後router進來的時候

271
00:14:19,310 --> 00:14:24,380
會把它跟誰連還有cost通通記在上面

272
00:14:24,380 --> 00:14:26,710
那我們現在假設cost就是1

273
00:14:26,710 --> 00:14:29,180
就是每一個link上面cost就是1的話

274
00:14:29,180 --> 00:14:33,880
那所以C本身呢它就會建構出這個網路的拓墣

275
00:14:33,880 --> 00:14:36,580
也就是這個網路的拓墣  這個整個拓墣

276
00:14:36,580 --> 00:14:39,50
這個C呢它是知道的

277
00:14:39,50 --> 00:14:42,979
那C知道這個拓墣之後它就要去算說

278
00:14:42,980 --> 00:14:45,580
好  它到每一個router

279
00:14:45,580 --> 00:14:48,750
注意到  到每一個router的最短路徑

280
00:14:48,750 --> 00:14:52,410
把它找出來  那找最短路徑

281
00:14:52,410 --> 00:14:54,980
這個在我們所謂的演算法裡面

282
00:14:54,980 --> 00:14:56,750
有一個非常有名的algorithm

283
00:14:56,750 --> 00:14:59,350
就叫做dijkstra’s algorithm

284
00:14:59,350 --> 00:15:04,750
dijkstra的algorithm就是專門用來找一點到其他點的最短路徑

285
00:15:04,750 --> 00:15:07,280
就是最短的這個  這個path

286
00:15:07,280 --> 00:15:08,949
好  那我們就說

287
00:15:08,950 --> 00:15:11,950
譬如說最後呢C找出來就是說

288
00:15:11,950 --> 00:15:13,910
C到B的最短路徑就是這一條

289
00:15:13,910 --> 00:15:17,280
那C到D就是這裡  那C到A就是這裡

290
00:15:17,280 --> 00:15:20,280
那我們講C到F呢就是這裡

291
00:15:20,280 --> 00:15:24,380
那C到E就是走這裡  那C到G呢就走這裡

292
00:15:24,380 --> 00:15:27,780
所以這個紅色的呢  就是它找出來

293
00:15:27,780 --> 00:15:32,680
它到所有node的最短路徑  那就根據這個最短路徑呢

294
00:15:32,680 --> 00:15:35,680
把那個routing table把它建起來

295
00:15:35,680 --> 00:15:40,910
就是說根據最短路徑呢來造每一個人的routing table

296
00:15:40,910 --> 00:15:44,980
譬如說依這個例子來講的話  它的routing table也很簡單

297
00:15:44,980 --> 00:15:49,880
就是說C對  對C來講的話  它就說  到B就是走B

298
00:15:49,880 --> 00:15:53,350
到D就是走D  到A就是走A

299
00:15:53,350 --> 00:15:56,650
那到E我們講到E就是走A嘛

300
00:15:56,650 --> 00:16:00,480
因為它經過A  那到F呢也是走A  到G就走D

301
00:16:00,480 --> 00:16:04,350
因為它是走這一條  所以對C來講的話

302
00:16:04,350 --> 00:16:09,380
它先收集這個所有的LSP

303
00:16:09,380 --> 00:16:12,80
然後建出整個網路的拓墣

304
00:16:12,80 --> 00:16:14,350
然後再用一個algorithm

305
00:16:14,350 --> 00:16:17,310
我們說最簡單的就是dijkstra’s algorithm

306
00:16:17,310 --> 00:16:20,380
找出說它到其他node的最短路徑

307
00:16:20,380 --> 00:16:22,350
然後利用這個最短路徑呢

308
00:16:22,350 --> 00:16:24,550
就可以造出它的routing table來

309
00:16:24,550 --> 00:16:25,979
也就是說  很簡單

310
00:16:25,980 --> 00:16:28,650
就是我們如果用了OSPF的話

311
00:16:28,650 --> 00:16:33,209
每一個router都會造出自己的所謂的routing table

312
00:16:33,210 --> 00:16:35,550
那每一個node都做這樣的事情

313
00:16:35,550 --> 00:16:38,250
那這樣的話我們就會把這個routing table

314
00:16:38,250 --> 00:16:39,250
通通把它建起來

