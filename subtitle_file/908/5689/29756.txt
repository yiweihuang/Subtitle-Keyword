1
00:00:08,980 --> 00:00:11,750
好，我們說這個stop-and-wait 這個protocol

2
00:00:11,750 --> 00:00:13,610
有四個不同的情境

3
00:00:13,610 --> 00:00:15,180
那我們說前面兩個

4
00:00:15,180 --> 00:00:17,280
包含第一個是說非常正常

5
00:00:17,280 --> 00:00:18,950
一個封包送出去

6
00:00:18,950 --> 00:00:22,80
也在timeout之前能夠及時收到ACK

7
00:00:22,80 --> 00:00:23,209
那第二個就是說

8
00:00:23,210 --> 00:00:26,50
封包送的過程當中被損毀掉

9
00:00:26,50 --> 00:00:29,80
那接下來我們來介紹第三跟第四個case

10
00:00:29,80 --> 00:00:30,909
那第三個case是說

11
00:00:30,910 --> 00:00:34,480
我們封包是成功的送到receiver

12
00:00:34,480 --> 00:00:36,250
就是封包是正確收到的

13
00:00:36,250 --> 00:00:39,610
好，那receiver收到之後它就回一個ACK

14
00:00:39,610 --> 00:00:41,150
那問題出在這個ACK

15
00:00:41,150 --> 00:00:43,379
這個ACK我們第三個狀況是說

16
00:00:43,380 --> 00:00:46,180
我們這個ACK本身它lost掉

17
00:00:46,180 --> 00:00:48,180
就是ACK本身損毀掉

18
00:00:48,180 --> 00:00:50,280
那我們來看看會發生什麼問題

19
00:00:50,280 --> 00:00:52,280
我們看一下，看左邊的動畫

20
00:00:52,280 --> 00:00:57,580
我們說sender呢把這個封包丟出來給receiver

21
00:00:57,580 --> 00:00:59,449
而這個封包也正確的收到

22
00:00:59,450 --> 00:01:01,350
然後receiver當然就回一個ACK

23
00:01:01,350 --> 00:01:04,410
不過這個ACK本身毀掉了

24
00:01:04,410 --> 00:01:08,380
這個ACK本身受到一些所謂的interference

25
00:01:08,380 --> 00:01:10,610
受到干擾所以這個ACK本身壞掉了

26
00:01:10,610 --> 00:01:12,810
那ACK壞掉之後我們剛也提到

27
00:01:12,810 --> 00:01:17,780
那這個sender因為ACK壞掉它就沒有收到這個ACK

28
00:01:17,780 --> 00:01:20,680
然後就要等這個所謂的timer timeout

29
00:01:20,680 --> 00:01:23,250
所以timer timeout之後

30
00:01:23,250 --> 00:01:27,980
接下來就會我們講retransmit再送一次

31
00:01:27,980 --> 00:01:31,210
那對方收到之後呢再回一個ACK這樣子

32
00:01:31,210 --> 00:01:35,710
所以像左邊這個圖顯示的就是說

33
00:01:35,710 --> 00:01:37,610
如果我們的ACK壞掉的話

34
00:01:37,610 --> 00:01:40,610
一定會誘發這個所謂的timeout

35
00:01:40,610 --> 00:01:43,550
然後會做retransmission 重送一次

36
00:01:43,550 --> 00:01:45,950
好，這個時候這一次如果正常

37
00:01:45,950 --> 00:01:48,280
然後對方回一個ACK也正常

38
00:01:48,280 --> 00:01:50,550
那這個封包也算傳送結束

39
00:01:50,550 --> 00:01:52,610
不過這個地方我們注意到

40
00:01:52,610 --> 00:01:55,880
我們出現了一個非常非常的麻煩的事情

41
00:01:55,880 --> 00:02:01,50
就是這個時候receiver收到了同樣的這個frame

42
00:02:01,50 --> 00:02:03,210
同樣的封包收到兩次

43
00:02:03,210 --> 00:02:04,279
就是我們注意到

44
00:02:04,280 --> 00:02:06,980
這個地方 這個封包是正確收到的

45
00:02:06,980 --> 00:02:08,880
這個地方也是正確收到的

46
00:02:08,880 --> 00:02:13,480
那我們說這兩個封包是一樣的封包

47
00:02:13,480 --> 00:02:15,910
可是receiver呢收到兩次

48
00:02:15,910 --> 00:02:19,549
問題是它根本沒辦法分辨這兩個是不一樣的

49
00:02:19,550 --> 00:02:21,550
所以它就把兩個封包通通收起來了

50
00:02:21,550 --> 00:02:25,310
那這種狀況我們一般叫做所謂的duplicated frame

51
00:02:25,310 --> 00:02:29,210
就是說這個封包呢receiver它收到兩次

52
00:02:29,210 --> 00:02:31,180
當然也有可能兩次以上

53
00:02:31,180 --> 00:02:34,80
譬如說萬一這個第二次的ACK

54
00:02:34,80 --> 00:02:35,850
假設這邊也是壞掉的

55
00:02:35,850 --> 00:02:39,10
那它就會送第三次甚至第四次

56
00:02:39,10 --> 00:02:43,609
那所以這個就是stop-and-wait它所碰到一個困難

57
00:02:43,610 --> 00:02:49,50
就是說它有可能造成receiver重複收同一個frame

58
00:02:49,50 --> 00:02:53,680
就同一個封包它可能會重複的收到兩次、三次以上

59
00:02:53,680 --> 00:02:55,880
那這個是一個很大的麻煩

60
00:02:55,880 --> 00:02:57,79
所以我們等一下會介紹

61
00:02:57,80 --> 00:03:00,750
另外所謂的sliding window的方法來克服這個問題

62
00:03:00,750 --> 00:03:05,480
好，那接下來我們來介紹第四個所謂的情境

63
00:03:05,480 --> 00:03:07,480
第四個情境呢又稍微複雜一點

64
00:03:07,480 --> 00:03:09,649
我們說第四個情境是什麼呢

65
00:03:09,650 --> 00:03:14,380
就是說我們的timer太早所謂的timeout

66
00:03:14,380 --> 00:03:17,310
我們說一般的timer的設定都是說

67
00:03:17,310 --> 00:03:19,910
因為我們送一個封包給對方嘛

68
00:03:19,910 --> 00:03:21,650
我們會等對方的一個ACK

69
00:03:21,650 --> 00:03:25,610
那這個來回的時間一般我們叫做RTT

70
00:03:25,610 --> 00:03:26,850
就是round-trip time

71
00:03:26,850 --> 00:03:29,79
那我們的timer一定要比這個round-trip time

72
00:03:29,80 --> 00:03:31,450
再多一點要長一點

73
00:03:31,450 --> 00:03:34,310
這樣的話使得說我們希望這個ACK回來

74
00:03:34,310 --> 00:03:36,450
在這個timeout之前就回來

75
00:03:36,450 --> 00:03:38,910
那可是現在問題就是說

76
00:03:38,910 --> 00:03:41,410
因為我們在網路上面傳送的時候

77
00:03:41,410 --> 00:03:42,750
有時候中間

78
00:03:42,750 --> 00:03:47,10
我們中間可能經過像交換機或者甚至有些是經過router

79
00:03:47,10 --> 00:03:49,10
這邊假設經過交換機

80
00:03:49,10 --> 00:03:53,310
那可能會被queue在裡面所以它可能會delay

81
00:03:53,310 --> 00:03:55,750
我們說如果像這個地方

82
00:03:55,750 --> 00:03:58,610
如果ACK被delay了

83
00:03:58,610 --> 00:04:02,980
就是說我們正常是我送一個frame過去我等一個ACK

84
00:04:02,980 --> 00:04:07,209
那你想想看這個ACK如果回來的時候被延遲

85
00:04:07,210 --> 00:04:09,380
它延遲就比較慢到

86
00:04:09,380 --> 00:04:13,650
我們以為它變比較慢到 那你可能就會先timeout

87
00:04:13,650 --> 00:04:15,480
然後那個ACK才到

88
00:04:15,480 --> 00:04:17,480
這個就是我們第四個狀況

89
00:04:17,480 --> 00:04:19,580
這個狀況呢是稍微有點複雜

90
00:04:19,579 --> 00:04:21,979
我們來看一下右邊的這個動畫

91
00:04:21,980 --> 00:04:24,80
我們右邊這個case、右邊這個圖就是說

92
00:04:24,80 --> 00:04:27,580
一樣sender把一個封包丟出去

93
00:04:27,580 --> 00:04:29,909
丟給receiver而且也成功收到

94
00:04:29,910 --> 00:04:32,810
這個時候這個receiver就丟這個ACK回去

95
00:04:32,810 --> 00:04:33,850
我們注意看一下

96
00:04:33,850 --> 00:04:38,80
這個ACK本身注意到這個時間點

97
00:04:38,80 --> 00:04:42,349
這個ACK送到一半或者說這個ACK還在中途

98
00:04:42,350 --> 00:04:47,850
可是因為這個ACK本身有點被延遲

99
00:04:47,850 --> 00:04:51,780
中間可能譬如說被switch放在queue裡面

100
00:04:51,780 --> 00:04:54,780
可能排隊的時候排了久一點

101
00:04:54,780 --> 00:04:57,280
所以這個ACK它就延後到

102
00:04:57,280 --> 00:04:59,280
那延後到的時候我們注意到

103
00:04:59,280 --> 00:05:02,210
這個時候因為ACK比較慢

104
00:05:02,210 --> 00:05:05,150
所以這個timeout已經先發生

105
00:05:05,150 --> 00:05:08,679
那你注意看一下接下來發生什麼事

106
00:05:08,680 --> 00:05:11,210
接下來因為sender已經timeout了

107
00:05:11,210 --> 00:05:13,510
所以sender就開始做retransmission

108
00:05:13,510 --> 00:05:15,450
而且這個retransmission已經開始了

109
00:05:15,450 --> 00:05:18,50
等一下ACK才會進來

110
00:05:18,50 --> 00:05:19,850
所以我們注意看下面這個動畫

111
00:05:19,850 --> 00:05:23,550
我們這個sender呢開始送封包

112
00:05:23,550 --> 00:05:25,380
同時ACK呢慢慢地進來

113
00:05:25,380 --> 00:05:32,350
就發現說這個封包呢已經重送出去了然後ACK才到

114
00:05:32,350 --> 00:05:33,910
那這個時候怎麼辦

115
00:05:33,910 --> 00:05:36,710
這個時候對sender來講的話

116
00:05:36,710 --> 00:05:38,710
它第一個封包丟出去

117
00:05:38,710 --> 00:05:40,280
它沒有等到ACK

118
00:05:40,280 --> 00:05:44,309
可是第二個封包剛剛重送ACK就到了

119
00:05:44,310 --> 00:05:46,680
所以對它來講反正收到ACK了

120
00:05:46,680 --> 00:05:47,950
反正收到ACK了

121
00:05:47,950 --> 00:05:49,550
你看我們對sender來講的話

122
00:05:49,550 --> 00:05:53,50
送一個封包雖然送了兩次

123
00:05:53,50 --> 00:05:54,450
可是我已經收到ACK了

124
00:05:54,450 --> 00:05:57,750
所以我就認為說我這個傳送已經結束了

125
00:05:57,750 --> 00:05:59,210
因為我雖然送了兩次

126
00:05:59,210 --> 00:06:00,680
我收到了ACK

127
00:06:00,680 --> 00:06:02,50
That’s fine.沒有問題

128
00:06:02,50 --> 00:06:04,280
但是我們要看的是receiver

129
00:06:04,280 --> 00:06:06,179
對receiver來講的話

130
00:06:06,180 --> 00:06:07,850
它比較討厭的是說

131
00:06:07,850 --> 00:06:11,510
它等一下收到第二個封包的時候它還是回一個ACK

132
00:06:11,510 --> 00:06:12,750
這個也ok

133
00:06:12,750 --> 00:06:16,80
問題在於跟剛剛前面的case一樣是說

134
00:06:16,80 --> 00:06:18,849
我們注意看receiver這邊發生了什麼事

135
00:06:18,850 --> 00:06:24,780
一樣它這個地方收到了兩份frame 都一樣的frame

136
00:06:24,780 --> 00:06:28,150
就是說它這個狀況呢、這兩個狀況是相同的

137
00:06:28,150 --> 00:06:33,450
就是receiver呢都收到了兩份一樣的封包

138
00:06:33,450 --> 00:06:36,180
我們說這個叫做frame duplication

139
00:06:36,180 --> 00:06:37,650
或者所謂的duplicated frame

140
00:06:37,650 --> 00:06:42,580
也就是說stop-and-wait是一個非常簡單的機制

141
00:06:42,580 --> 00:06:44,109
就是送一個封包等一個ACK

142
00:06:44,110 --> 00:06:46,810
那它可以做到reliable transmission

143
00:06:46,810 --> 00:06:48,50
可以做到可靠的傳輸

144
00:06:48,50 --> 00:06:51,210
但是呢當ACK

145
00:06:51,210 --> 00:06:52,849
這個ACK本身

146
00:06:52,850 --> 00:06:55,550
第一個ACK掉了，我們講這個狀況

147
00:06:55,550 --> 00:06:58,480
當ACK掉了，或者ACK被delay了

148
00:06:58,480 --> 00:07:03,80
不管是ACK不見了或者它太慢到了

149
00:07:03,80 --> 00:07:05,380
都會引發retransmission

150
00:07:05,380 --> 00:07:07,409
那這種retransmission

151
00:07:07,410 --> 00:07:09,550
receiver呢都沒辦法判斷

152
00:07:09,550 --> 00:07:13,780
這個重送的封包跟之前的封包是一樣的

153
00:07:13,780 --> 00:07:15,880
它就會把它兩個都收起來

154
00:07:15,880 --> 00:07:20,409
也就是說stop-and-wait會因為我們的ACK

155
00:07:20,410 --> 00:07:23,980
回來的時候不管是lost或delay

156
00:07:23,980 --> 00:07:27,650
而產生封包重複接收的問題

157
00:07:27,650 --> 00:07:30,549
這個是stop-and-wait最大的問題

158
00:07:30,550 --> 00:07:32,80
好，剛剛我們提到說

159
00:07:32,80 --> 00:07:39,650
Stop-and-wait本身不管這個acknowledgement是lost或delay

160
00:07:39,650 --> 00:07:44,880
那都會造成所謂的duplicate copies of frame

161
00:07:44,880 --> 00:07:49,50
就是說都會造成這個封包重複接收

162
00:07:49,50 --> 00:07:50,50
那這是一個問題

163
00:07:50,50 --> 00:07:53,380
因為receiver本身本來應該收一個封包的吼

164
00:07:53,380 --> 00:07:54,810
它現在收兩個封包

165
00:07:54,810 --> 00:07:56,580
你的內容就兩份

166
00:07:56,580 --> 00:08:01,210
那這個內容兩份本身就會造成各式各樣的可能錯誤

167
00:08:01,210 --> 00:08:03,680
好，接下來我們就來介紹說

168
00:08:03,680 --> 00:08:04,910
那這問題怎麼解

169
00:08:04,910 --> 00:08:07,610
很簡單，我們只要呢

170
00:08:07,610 --> 00:08:11,350
用一個bit，我們說叫sequence number

171
00:08:11,350 --> 00:08:14,550
我們就把那個封包把它編號的意思

172
00:08:14,550 --> 00:08:16,280
那編號變成說

173
00:08:16,280 --> 00:08:18,580
可是這個編號本身呢又只用一個bit

174
00:08:18,580 --> 00:08:22,310
那一個bit本身就只能0或1呀

175
00:08:22,310 --> 00:08:23,950
就是說  好，沒關係

176
00:08:23,950 --> 00:08:28,180
那就把這個封包給它編0、1、0 、1

177
00:08:28,180 --> 00:08:29,480
因為我只有一個bit嘛

178
00:08:29,480 --> 00:08:31,750
所以也只能寫0或寫1

179
00:08:31,750 --> 00:08:36,679
好，也就是說因為我們有編號0或1拉

180
00:08:36,679 --> 00:08:40,10
也就是說當sender它retransmit frame 0

181
00:08:40,10 --> 00:08:42,280
重送的時候

182
00:08:42,280 --> 00:08:44,880
因為上面有編號0或1嘛

183
00:08:44,880 --> 00:08:46,250
所以我開始送0

184
00:08:46,250 --> 00:08:51,80
那剛提到可能我這個ACK不管是lost或者是delay了

185
00:08:51,80 --> 00:08:52,250
我會retransmit

186
00:08:52,250 --> 00:08:53,850
你重送的時候呢

187
00:08:53,850 --> 00:08:58,210
上面的編號呢跟之前你傳送的封包編號是一樣的

188
00:08:58,210 --> 00:09:00,710
譬如說一開始封包是0、編號是0

189
00:09:00,710 --> 00:09:01,510
你重送還是0

190
00:09:01,510 --> 00:09:03,480
那receiver收到的時候

191
00:09:03,480 --> 00:09:05,410
它看這個編號它就知道

192
00:09:05,410 --> 00:09:07,50
這個跟剛剛前面是一樣的

193
00:09:07,50 --> 00:09:09,380
所以它就會把它丟掉

194
00:09:09,380 --> 00:09:11,210
那這樣就解掉了我們所謂的

195
00:09:11,210 --> 00:09:14,450
所謂的封包重複接收的問題

196
00:09:14,450 --> 00:09:16,850
我們來看一下這個例子

197
00:09:16,850 --> 00:09:21,580
我們看，我們左邊呢是sender、右邊是receiver

198
00:09:21,580 --> 00:09:25,280
那首先sender送一個封包

199
00:09:25,280 --> 00:09:26,709
我們給它編號0

200
00:09:26,710 --> 00:09:28,480
那我就回一個ACK 0

201
00:09:28,480 --> 00:09:31,380
就是我們封包有編號

202
00:09:31,380 --> 00:09:33,480
我們只有0、1、0、1

203
00:09:33,480 --> 00:09:34,550
因為只用一個bit

204
00:09:34,550 --> 00:09:37,380
好，所以第一個呢我們把它frame編號0

205
00:09:37,380 --> 00:09:38,180
然後ACK 0

206
00:09:38,180 --> 00:09:39,880
然後接下來就是frame 1

207
00:09:39,880 --> 00:09:41,450
然後ACK 1

208
00:09:41,450 --> 00:09:45,680
再來frame 0、ACK 0就這樣

209
00:09:45,680 --> 00:09:51,709
就是編號0、0、1、1、0、0、1、1這樣子

210
00:09:51,710 --> 00:09:53,480
那這樣的話我們剛剛提到說

211
00:09:53,480 --> 00:09:56,280
那即使封包你重送的時候

212
00:09:56,280 --> 00:09:57,350
我們剛剛提到

213
00:09:57,350 --> 00:09:59,50
重送的時候我們怎麼解呢

214
00:09:59,50 --> 00:10:00,479
我們自然就解掉了

215
00:10:00,480 --> 00:10:04,480
你看這兩個、萬一假設這個地方我們講它壞掉

216
00:10:04,480 --> 00:10:06,980
那你壞掉重送的時候這個地方就是0

217
00:10:06,980 --> 00:10:09,80
那我們如果重送是0的話

218
00:10:09,80 --> 00:10:10,980
那這兩個封包我們一看

219
00:10:10,980 --> 00:10:13,110
Frame都是編號0跟0

220
00:10:13,110 --> 00:10:14,950
所以我們第二個封包就不會要

221
00:10:14,950 --> 00:10:16,580
我們只會要第一個封包

222
00:10:16,580 --> 00:10:21,450
那這樣我們就把那個所謂的重複的問題把它解決掉了

223
00:10:21,450 --> 00:10:22,510
就是說我們可以用

224
00:10:22,510 --> 00:10:25,910
Frame加上sequence number

225
00:10:25,910 --> 00:10:29,180
而且只用1個bit的sequence number就可以解這個問題

226
00:10:29,180 --> 00:10:32,750
好，但是呢這個方法是很簡單

227
00:10:32,750 --> 00:10:34,710
但是它又引發了另外一個問題

228
00:10:34,710 --> 00:10:36,650
就是說這個stop-and-wait

229
00:10:36,650 --> 00:10:39,910
它的一個比較大的致命傷在於說

230
00:10:39,910 --> 00:10:42,510
既然叫做stop-and-wait

231
00:10:42,510 --> 00:10:45,110
就是送一個封包要等一個ACK

232
00:10:45,110 --> 00:10:47,550
好，那我們就說同一個時間

233
00:10:47,550 --> 00:10:53,579
同一個時間最多只有一個我們叫做outstanding

234
00:10:53,580 --> 00:10:58,210
Outstanding的frame就是在外面跑的封包只有一個

235
00:10:58,210 --> 00:11:00,380
就是我們sender跟receiver

236
00:11:00,380 --> 00:11:02,50
我們中間有一個link嘛

237
00:11:02,50 --> 00:11:05,410
那這個link上面因為你丟一個封包

238
00:11:05,410 --> 00:11:09,50
就必須等它的acknowledgement、必須等ACK

239
00:11:09,50 --> 00:11:10,680
所以這個封包就是說送到對方去

240
00:11:10,680 --> 00:11:12,380
然後等ACK回來

241
00:11:12,380 --> 00:11:14,750
然後再來送下一個封包

242
00:11:14,750 --> 00:11:18,50
也就是說它整個我們講throughput其實不夠好

243
00:11:18,50 --> 00:11:21,750
就是一個來回的時間只送一個封包

244
00:11:21,750 --> 00:11:23,780
就是來回是一個時間嘛

245
00:11:23,780 --> 00:11:27,280
這個在那麼長的時間之內我們只送一個封包

246
00:11:27,280 --> 00:11:33,250
那我們說這樣呢我們其實沒有把這個link所謂的capacity

247
00:11:33,250 --> 00:11:37,180
沒有把link的這個能量或者容量呢把它充分利用

248
00:11:37,180 --> 00:11:42,79
那我們說這個對整個link的使用率會比較差

249
00:11:42,80 --> 00:11:43,610
整個throughput就會比較差

250
00:11:43,610 --> 00:11:44,710
我們看一個例子

251
00:11:44,710 --> 00:11:46,650
假設呢我們有一個link

252
00:11:46,650 --> 00:11:49,880
它的傳送的速度呢是2 Mbps

253
00:11:49,880 --> 00:11:52,350
就是蠻典型的就是有一個link

254
00:11:52,350 --> 00:11:55,680
我們傳輸的速率呢是2 Mbps

255
00:11:55,680 --> 00:11:59,209
那我們假設這個link呢訊號來回

256
00:11:59,210 --> 00:12:02,680
我們講它的round-trip time是40個ms

257
00:12:02,680 --> 00:12:04,609
那我們有說過啊

258
00:12:04,610 --> 00:12:07,450
一個link本身它有傳送速度

259
00:12:07,450 --> 00:12:08,810
它有來回的時間

260
00:12:08,810 --> 00:12:11,50
相當於一個pipe、一個管線

261
00:12:11,50 --> 00:12:14,410
這個管本身來回時間相當於原來長度

262
00:12:14,410 --> 00:12:16,410
它的bandwidth相當於它的面積

263
00:12:16,410 --> 00:12:19,310
這兩個相乘代表說在這個link上面

264
00:12:19,310 --> 00:12:24,250
你最多同時可以放多少個資料量在這個pipe上面

265
00:12:24,250 --> 00:12:28,480
我們希望讓這個pipe可以塞得越滿

266
00:12:28,480 --> 00:12:30,650
代表說這個throughput得越好

267
00:12:30,650 --> 00:12:34,880
那我們說我們就把這個bandwidth就是2 Mbps

268
00:12:34,880 --> 00:12:37,680
Delay就是40個ms

269
00:12:37,680 --> 00:12:42,109
把delay乘上bandwidth就是相當於80 Kb拉

270
00:12:42,110 --> 00:12:43,680
相當於8 KB

271
00:12:43,680 --> 00:12:45,150
也就是說這樣的一個link

272
00:12:45,150 --> 00:12:48,810
我們如果讓sender可以一直送、一直送的話

273
00:12:48,810 --> 00:12:50,609
第一個bit送進去

274
00:12:50,610 --> 00:12:52,750
然後第一個bit就開始跑

275
00:12:52,750 --> 00:12:55,310
花了20個ms到對方嘛

276
00:12:55,310 --> 00:12:58,349
我們如果說來回40個ms嘛

277
00:12:58,350 --> 00:12:59,950
就是20個ms到對方

278
00:12:59,950 --> 00:13:04,710
那這個中間的時間可以塞多少資料量

279
00:13:04,710 --> 00:13:07,150
假設我們長度算40個ms的話

280
00:13:07,150 --> 00:13:13,110
它可以送到所謂的8 KB的這麼多的資料

281
00:13:13,110 --> 00:13:18,850
好，那我們說假設這個sender送的這個封包

282
00:13:18,850 --> 00:13:20,410
它的size是1 KB

283
00:13:20,410 --> 00:13:23,79
因為在一個RTT的時間

284
00:13:23,80 --> 00:13:27,110
就是在40個ms的這個時間呢

285
00:13:27,110 --> 00:13:28,580
它只能送一個byte

286
00:13:28,580 --> 00:13:31,680
對不起，只能送一個frame、送一個封包

287
00:13:31,680 --> 00:13:34,949
我們講假設呢這個封包的長度呢是一KB

288
00:13:34,950 --> 00:13:36,810
所以我們可以把它算成說

289
00:13:36,810 --> 00:13:38,349
那它的throughput到底有多好

290
00:13:38,350 --> 00:13:44,550
就是說在40個ms來回的時間你只能送一個封包

291
00:13:44,550 --> 00:13:47,209
而這個封包假設它的size是1 KB

292
00:13:47,210 --> 00:13:52,50
就相當於說在40個ms裡面你只能送1 KB嘛

293
00:13:52,50 --> 00:13:53,880
那這個throughput怎麼算

294
00:13:53,880 --> 00:13:57,250
就是1 KB除以40個ms

295
00:13:57,250 --> 00:14:00,50
就是這樣子算來、這樣子算

296
00:14:00,50 --> 00:14:05,780
這樣算的結果就是說我的throughput是200 Kbps

297
00:14:05,780 --> 00:14:09,350
就是說你在40個ms裡面只送了1 KB

298
00:14:09,350 --> 00:14:12,710
1 KB就是8Kb的這個資料量

299
00:14:12,710 --> 00:14:14,380
所以一除我們就知道說

300
00:14:14,380 --> 00:14:19,880
它這個整個速率或者throughput就是200 Kbps

301
00:14:19,880 --> 00:14:22,150
可是我們這個link的速度有多快

302
00:14:22,150 --> 00:14:24,680
我們剛提到說我們link的速度是2 Mbps

303
00:14:24,680 --> 00:14:30,709
2 Mbps的速率我們現在只用到了200 Kbps

304
00:14:30,710 --> 00:14:33,310
相當於說我們只用到了這個link

305
00:14:33,310 --> 00:14:38,410
這個link本身頻寬我們只用了十分之一的意思

306
00:14:38,410 --> 00:14:42,910
也就是說stop-and-wait本身它有一個比較嚴重的問題

307
00:14:42,910 --> 00:14:45,780
就是說在整體的效能上是不佳的

308
00:14:45,780 --> 00:14:51,209
因為我們送一個封包就必須等ACK

309
00:14:51,280 --> 00:14:53,380
然後在等待ACK的過程當中

310
00:14:53,380 --> 00:14:55,310
不能送下一個封包

311
00:14:55,310 --> 00:14:57,449
所以這個link我們等於說

312
00:14:57,450 --> 00:15:01,410
其實我們並沒有讓這個link的整個所謂的capacity

313
00:15:01,410 --> 00:15:05,880
整個的容量沒有讓它真正的發揮出來

314
00:15:05,880 --> 00:15:09,710
因為送一個封包就必須等ACK

315
00:15:09,710 --> 00:15:13,350
等ACK的過程當中呢幾乎什麼事都不能用

316
00:15:13,350 --> 00:15:15,150
那依這個例子來講的話

317
00:15:15,150 --> 00:15:20,110
甚至於我們只用到了原來link的十分之一

318
00:15:20,110 --> 00:15:23,780
那其實是算是可以用的protocol

319
00:15:23,780 --> 00:15:25,910
Stop-and-wait很簡單，可以用

320
00:15:25,910 --> 00:15:28,480
那但是呢它可能造成

321
00:15:28,480 --> 00:15:31,110
剛剛講這個ACK delay或lost

322
00:15:31,110 --> 00:15:34,210
會造成所謂的frame duplication、重複接收

323
00:15:34,210 --> 00:15:36,150
好，我們加上sequence number

324
00:15:36,150 --> 00:15:37,250
0、1、0、1的

325
00:15:37,250 --> 00:15:40,780
我們解掉了這個所謂的重複接收的問題

326
00:15:40,780 --> 00:15:42,980
但是呢又引發了另外一個問題

327
00:15:42,980 --> 00:15:44,350
就是效能不佳

328
00:15:44,350 --> 00:15:49,450
就是因為在一個round-trip time時間我們只能送一個封包

329
00:15:49,450 --> 00:15:51,880
所以剛剛這個例子告訴我們說

330
00:15:51,880 --> 00:15:53,980
這個整個throughput是不夠好

331
00:15:53,980 --> 00:15:56,650
那我們等一下就會來介紹說

332
00:15:56,650 --> 00:16:00,750
所謂的sliding window它就把這些問題通通都一併解決掉

333
00:16:00,750 --> 00:16:02,750


