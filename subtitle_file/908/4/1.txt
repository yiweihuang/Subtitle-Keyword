1
00:00:08,099 --> 00:00:11,026
好 那接下來我們來看一個

2
00:00:11,026 --> 00:00:13,049
所謂的B LAN的例子

3
00:00:13,049 --> 00:00:16,009
在這個圖上面呢 我們可以看到說

4
00:00:16,009 --> 00:00:19,053
我們大概有六個LAN LAN1到LAN6

5
00:00:19,053 --> 00:00:24,030
然後我們有四個bridge 就是bridge1 2 3 4

6
00:00:24,030 --> 00:00:26,017
那我們用四個bridge呢

7
00:00:26,017 --> 00:00:30,014
把六個LAN連接成這個圖上面的這樣的一個結構

8
00:00:30,014 --> 00:00:32,014
那這個叫所謂的一個B LAN

9
00:00:32,014 --> 00:00:34,048
因為我們用bridge呢 把一些LAN

10
00:00:34,048 --> 00:00:36,001
六個LAN把它連起來

11
00:00:36,001 --> 00:00:38,032
那這個連法呢 比較特別就是說

12
00:00:38,032 --> 00:00:41,019
我們叫做without loop 就是說沒有迴路

13
00:00:41,019 --> 00:00:44,049
等於說注意看一下這個結構裡面是沒有迴圈的

14
00:00:44,049 --> 00:00:47,013
那沒有迴圈呢 其實他就一個routing

15
00:00:47,013 --> 00:00:50,093
最簡單的問題就是說 如果他沒有迴圈的話

16
00:00:50,093 --> 00:00:54,010
我們會發現 任何兩個station之間呢

17
00:00:54,010 --> 00:00:57,084
他只有我們唯一的路徑 在這個結構上呢

18
00:00:57,084 --> 00:01:00,037
我們可以找到唯一的路徑 我們來看一下例子

19
00:01:00,037 --> 00:01:04,074
譬如說 我們假設C跟F呢想要通訊的話

20
00:01:04,074 --> 00:01:09,008
那他就必須走 這個路 看一下這個

21
00:01:15,039 --> 00:01:17,002
從這個圖呢 我們就看得到說

22
00:01:17,002 --> 00:01:19,016
C跟F呢 他就會走這條路

23
00:01:19,016 --> 00:01:22,073
因為我們在一個沒有迴圈的這個結構之下

24
00:01:22,073 --> 00:01:25,053
任何兩點之間只有唯一的路徑

25
00:01:25,053 --> 00:01:27,097
所以既然是唯一的路徑呢

26
00:01:27,097 --> 00:01:30,054
其實他也幫我們解決了routing了問題

27
00:01:30,054 --> 00:01:33,057
就是我們這個routing就簡單了 因為他只有唯一的路徑

28
00:01:33,057 --> 00:01:38,008
那我們來看下一個例子 那這個例子比較複雜一點

29
00:01:38,008 --> 00:01:41,018
就是說我們這個LAN呢還是一樣有六個

30
00:01:41,018 --> 00:01:44,005
可是我們的bridge呢有七個

31
00:01:44,005 --> 00:01:46,072
就是說我們用比較多的bridge把他接起來

32
00:01:46,072 --> 00:01:49,069
我們為什麼要用這麼多bridge把這些LAN接起來呢

33
00:01:49,069 --> 00:01:52,072
當然是因為我們可以增加可靠度嘛

34
00:01:52,072 --> 00:01:54,099
譬如說 萬一網路不穩定啊

35
00:01:54,099 --> 00:01:57,000
有這個斷線的情況的時候呢

36
00:01:57,000 --> 00:01:59,000
我們這個網路是比較可靠的

37
00:01:59,000 --> 00:02:03,027
所以我可以用比較多的bridge 把網路連起來

38
00:02:03,027 --> 00:02:05,040
提高我的可靠度 但是呢

39
00:02:05,040 --> 00:02:08,057
我們bridge連的比較多的時候 就出現一個問題

40
00:02:08,057 --> 00:02:11,031
就現在我看到這個網路上面 我們有迴圈了

41
00:02:11,031 --> 00:02:14,008
我們loop我們先看一下在哪裡呢

42
00:02:14,008 --> 00:02:17,028
首先看這個 這個綠色的這個地方

43
00:02:17,028 --> 00:02:20,072
這就是第一個loop 等於說我們有這個loop本身

44
00:02:20,072 --> 00:02:24,049
把三個bridge 還有幾個LAN把他接起來

45
00:02:24,049 --> 00:02:27,083
這是第一個 在左邊 這邊就有一個迴圈

46
00:02:27,083 --> 00:02:31,096
那我們再來看下一個 這也是另外一個bridge

47
00:02:31,096 --> 00:02:33,050
對不起 另外一個loop

48
00:02:33,050 --> 00:02:37,064
就是說 我們因為用的可能比較多的bridge

49
00:02:37,064 --> 00:02:42,011
網路連起來的時候呢 就難免會形成所謂的迴路啦

50
00:02:42,011 --> 00:02:44,011
那這個迴路我們就會比較頭痛啦

51
00:02:44,011 --> 00:02:46,091
因為當我封包要送的時候呢

52
00:02:46,091 --> 00:02:49,068
我的路徑有很多個 路徑很多的時候呢

53
00:02:49,068 --> 00:02:53,042
就會造成這個封包 在網路上面可能就會被重複了

54
00:02:53,042 --> 00:02:57,076
就是他跑到不應該跑的地方去了 或者說我們會收到

55
00:02:57,076 --> 00:03:01,016
譬如說兩筆 或兩筆以上的封包

56
00:03:01,016 --> 00:03:05,036
就他會重複接收 那重複接收會造成我們的這個困擾

57
00:03:05,036 --> 00:03:08,080
而且甚至我們在做address learning的時候

58
00:03:08,080 --> 00:03:13,031
因為我們有提到說 我們這個bridge呢會自動地學習

59
00:03:13,031 --> 00:03:16,021
這個station到底在什麼地方

60
00:03:16,021 --> 00:03:18,024
可是當我們有迴圈的時候呢

61
00:03:18,024 --> 00:03:21,015
這個封包一下從左邊來 一下從右邊來

62
00:03:21,015 --> 00:03:23,005
那我們可能就會學習錯誤啦

63
00:03:23,005 --> 00:03:25,092
就是說 我們一定 為了可靠度

64
00:03:25,092 --> 00:03:29,072
我們可以連接成loop 可是當他在運作的時候

65
00:03:29,072 --> 00:03:33,066
是不可以有loop的 那這就是為什麼

66
00:03:33,066 --> 00:03:35,049
我們要有spanning tree algorithm

67
00:03:35,049 --> 00:03:37,050
spanning tree algorithm就是讓這個

68
00:03:37,050 --> 00:03:39,056
bridge上面呢跑一個演算法

69
00:03:39,056 --> 00:03:42,017
分散式的演算法 自動的演算法

70
00:03:42,017 --> 00:03:45,047
反正跑了半天之後呢 就是讓這個迴圈被打破

71
00:03:45,047 --> 00:03:47,021
就不要有迴圈的存在

72
00:03:47,021 --> 00:03:51,018
然後 一個所謂的spanning tree的結構

73
00:03:51,018 --> 00:03:52,098
然後有了這個spanning tree之後呢

74
00:03:52,098 --> 00:03:54,091
這個routing就幫我們解決掉了

75
00:03:54,091 --> 00:03:58,058
所以這個是很重要的一個這個spanning tree的目的

76
00:03:58,058 --> 00:04:03,002
好 那底下呢我們用一個圖呢來介紹說

77
00:04:03,002 --> 00:04:06,046
這個bridge本身到底怎麼來運作啦

78
00:04:06,046 --> 00:04:08,023
那我們一開始有提到說

79
00:04:08,023 --> 00:04:12,030
一個bridge呢 他是一個所謂的layer2的設備

80
00:04:12,030 --> 00:04:14,057
就是所謂的MAC layer的設備

81
00:04:14,057 --> 00:04:17,024
意思就是說 這個bridge本身呢

82
00:04:17,024 --> 00:04:22,047
他只處理這個封包裡面的layer2的資訊 就是MAC address

83
00:04:22,047 --> 00:04:25,081
所以我們用這個圖來看 這個圖裡面我們假設呢

84
00:04:25,081 --> 00:04:30,055
有一個bridge在中間 然後我們左邊呢有一個LAN1

85
00:04:30,055 --> 00:04:33,079
右邊有一個LAN2 就兩個LAN在旁邊

86
00:04:33,079 --> 00:04:36,072
然後各有station A B C D

87
00:04:36,072 --> 00:04:38,059
就這樣的一個結構上面

88
00:04:38,059 --> 00:04:42,033
那我們怎麼來介紹這個bridge的運作的模式呢

89
00:04:42,033 --> 00:04:46,050
我們注意到我們上面有t1 t2 t3 到t8

90
00:04:46,050 --> 00:04:49,047
就是那個時間啦 t1代表在第一個時間

91
00:04:49,047 --> 00:04:52,004
那我們看 在第一個時間呢

92
00:04:54,004 --> 00:04:57,044
在第一個時間 我們看到那個t1的時候呢

93
00:04:57,044 --> 00:05:00,001
就是那個藍色的 就是我們這個時候呢

94
00:05:00,001 --> 00:05:06,048
只有這個 看一下 藍色的時候呢 就這個

95
00:05:06,048 --> 00:05:09,065
這個叫所謂的 在t1的時候我們有一個data

96
00:05:09,065 --> 00:05:13,009
這個data就相當於從這個地方送下來的意思

97
00:05:13,009 --> 00:05:16,039
這個使用者呢 user

98
00:05:16,039 --> 00:05:19,096
他把這個data丟給了所謂的LLC

99
00:05:19,096 --> 00:05:22,070
這一層啦 那LLC呢

100
00:05:22,070 --> 00:05:25,077
在t2的時候呢 就加上LLC的header

101
00:05:25,077 --> 00:05:30,011
這個地方 就這個header呢是L2他加上去的

102
00:05:30,011 --> 00:05:34,095
就每一層 他在收到資料 再往下送的時候呢

103
00:05:34,095 --> 00:05:37,015
他都會加上自己的header

104
00:05:37,015 --> 00:05:39,025
那有必要的時候再上一個尾巴

105
00:05:39,025 --> 00:05:41,022
就頭尾會自己加上去

106
00:05:41,022 --> 00:05:44,079
那到了t3的時候呢 就在這個時間點

107
00:05:44,079 --> 00:05:47,069
在這個時間點的時候 往下丟的時候呢

108
00:05:47,069 --> 00:05:50,080
這就是一般正統的所謂的MAC address

109
00:05:50,080 --> 00:05:54,000
就這個完整的封包 就長的這個樣子

110
00:05:54,000 --> 00:05:57,024
那這個就把這個封包 就丟到physical layer

111
00:05:57,024 --> 00:06:00,081
那這個封包往下丟到這個LAN1的時候呢

112
00:06:00,081 --> 00:06:04,004
那就從LAN1就丟到這個bridge

113
00:06:04,004 --> 00:06:07,005
所以bridge有一個很重要的特色就是說

114
00:06:07,005 --> 00:06:14,072
在他所銜接的網路上面的每一個封包 他都會收起來

115
00:06:14,072 --> 00:06:17,032
那收起來再來檢查說 這個封包裡面

116
00:06:17,032 --> 00:06:19,032
他會檢查兩個東西嘛 剛提到

117
00:06:19,032 --> 00:06:23,026
一個就是他的所謂的source的MAC address

118
00:06:23,026 --> 00:06:25,060
一個就是所謂的destination的MAC address

119
00:06:25,060 --> 00:06:27,040
這兩個都是他會檢查的

120
00:06:27,040 --> 00:06:30,027
那在t4的時候 就是說

121
00:06:30,027 --> 00:06:32,084
這個bridge呢已經把這個封包收起來了

122
00:06:32,084 --> 00:06:35,061
這個封包收起來 所以他就檢查啦

123
00:06:35,061 --> 00:06:37,061
第一個他檢查他的destination的MAC

124
00:06:37,061 --> 00:06:39,071
說 這個封包到底要到哪裡去

125
00:06:39,071 --> 00:06:43,052
依這個例子來講 我們假設是A要送給D的話

126
00:06:43,052 --> 00:06:46,089
就發現說 這個D stationD 在這個地方

127
00:06:46,089 --> 00:06:49,052
他是在 我們叫bridge的右邊啦

128
00:06:49,052 --> 00:06:51,052
所以這個封包等下是要往下送的

129
00:06:51,052 --> 00:06:55,079
是要往下送下去的 所以這個bridge的本身

130
00:06:55,079 --> 00:06:58,070
就把這個封包呢 就往另外一邊丟出去

131
00:06:58,070 --> 00:07:00,077
那丟出去之後呢 一樣

132
00:07:00,077 --> 00:07:04,030
他就還是用這個layer2的這個MAC frame

133
00:07:04,030 --> 00:07:05,077
丟到這個網路上面

134
00:07:05,077 --> 00:07:08,074
那網路在收到 這個收到之後呢

135
00:07:08,074 --> 00:07:13,085
往上送的時候 我們這個地方就是所謂的t5 t6

136
00:07:13,085 --> 00:07:16,092
這個時間點都是一樣在網路上面

137
00:07:16,092 --> 00:07:20,089
所以這個都是封包 標準的MAC封包的格式

138
00:07:20,089 --> 00:07:27,073
好 當這個stationD最後的目的地的工作站收到這個封包之後呢

139
00:07:27,073 --> 00:07:31,050
他就開始往上送 那往上送的時候就開始拆解封包

140
00:07:31,050 --> 00:07:34,080
所以最後到這個t8的時候呢 就是一樣

141
00:07:34,080 --> 00:07:37,020
藍色的data 給藍色的data

142
00:07:37,020 --> 00:07:39,010
所以我們發現這個通訊其實

143
00:07:39,010 --> 00:07:42,077
是藍色的data呢是要丟給這個藍色的data

144
00:07:42,077 --> 00:07:48,078
所以這個對等的兩方 收到或看到的內容是一樣的

145
00:07:48,078 --> 00:07:51,062
那我們特別強調就是說 這個bridge本身

146
00:07:51,062 --> 00:07:56,022
他是一個layer2的設備 所以他收到封包之後呢

147
00:07:56,022 --> 00:08:00,069
他只處理MAC layer的內容 就是source MAC address

148
00:08:00,069 --> 00:08:03,023
或者destination的MAC address

149
00:08:03,023 --> 00:08:06,063
這是bridge本身很重要的這個概念

150
00:08:06,063 --> 00:08:09,043
好 我們接下來再來看一下

151
00:08:09,043 --> 00:08:13,024
怎麼做routing 那我們剛才有介紹說

152
00:08:13,024 --> 00:08:16,061
這個bridge本身呢 有兩個很重要的功能

153
00:08:16,061 --> 00:08:19,044
一個叫做forwarding 一個叫做filtering

154
00:08:19,044 --> 00:08:22,091
那我們再來看一下 根據什麼做forwarding

155
00:08:22,091 --> 00:08:26,035
我們剛有提到 一個bridge 收到封包之後

156
00:08:26,035 --> 00:08:29,099
他會處理這個封包 根據兩個東西

157
00:08:29,099 --> 00:08:32,066
一個是所謂的destination的MAC address

158
00:08:32,066 --> 00:08:34,076
一個所謂的source MAC address

159
00:08:34,076 --> 00:08:38,076
那我們來看一下 那如果要轉送封包

160
00:08:38,076 --> 00:08:41,063
必須根據destination的MAC address

161
00:08:41,063 --> 00:08:43,063
就是我們這個destination MAC address呢

162
00:08:43,063 --> 00:08:45,084
他是我們要轉送的這個內容

163
00:08:45,084 --> 00:08:50,044
那 如果是要做這個轉送的時候呢

164
00:08:50,044 --> 00:08:51,071
做什麼事情呢 第一個

165
00:08:51,071 --> 00:08:56,092
就要看說這個bridge呢 認不認識這個destination在哪裡

166
00:08:56,092 --> 00:08:59,055
我們剛剛有提到 這個bridge本身

167
00:08:59,055 --> 00:09:01,085
他最後會自動的學到說

168
00:09:01,085 --> 00:09:05,096
他每一個網路上面的每一個station 到底在什麼地方

169
00:09:05,096 --> 00:09:09,023
那這個什麼地方 講得比較清楚一點就是說

170
00:09:09,023 --> 00:09:13,016
他到底在這個bridge的哪一個port

171
00:09:13,016 --> 00:09:17,017
或者說哪一個接口 是可以連到那個station

172
00:09:17,017 --> 00:09:19,007
他就要從那個接口送出去

173
00:09:19,007 --> 00:09:21,031
那萬一一開始我們有提到說

174
00:09:21,031 --> 00:09:25,034
這個database是空的 因為他通常是釋放一個RAM

175
00:09:25,034 --> 00:09:30,001
所以這個 我們講bridge本身一開機的時候呢

176
00:09:30,001 --> 00:09:31,078
那個table是空白的

177
00:09:31,078 --> 00:09:34,012
所以一開始他根本不知道destination在什麼地方

178
00:09:34,012 --> 00:09:36,012
也就是說bridge一開始的時候呢

179
00:09:36,012 --> 00:09:39,049
他是不知道所有的station 他一個都不知道

180
00:09:39,049 --> 00:09:41,009
到底在什麼地方

181
00:09:41,009 --> 00:09:43,066
那如果不知道這個目的地在什麼地方

182
00:09:43,066 --> 00:09:47,010
那要怎麼送給他呢 他用一個最簡單的方式

183
00:09:47,010 --> 00:09:50,017
就是廣播 就是我們叫做所謂的broadcast

184
00:09:50,017 --> 00:09:52,047
就是一個封包進來 我們就會看到說

185
00:09:52,047 --> 00:09:55,057
那他的destination到底在哪個port

186
00:09:55,057 --> 00:09:58,061
如果你知道他在哪個port 那就送給那個port

187
00:09:58,061 --> 00:10:01,081
那如果你不知道他在哪個port 那只好全部送出去

188
00:10:01,081 --> 00:10:04,005
就送到所有的連接的port

189
00:10:04,005 --> 00:10:06,005
這所謂的broadcast

190
00:10:06,005 --> 00:10:08,082
那同時說 一個這個bridge呢

191
00:10:08,082 --> 00:10:10,089
他會maintain 剛提到這個database

192
00:10:10,089 --> 00:10:13,052
database裡面的內容是什麼呢

193
00:10:13,052 --> 00:10:15,049
我們等下也會比較完整的例子

194
00:10:15,049 --> 00:10:17,066
不過這個地方我們先講一下

195
00:10:17,066 --> 00:10:20,010
至少第一個 要有他的address

196
00:10:20,010 --> 00:10:24,004
就是 每一個工作站跟網卡的位置

197
00:10:24,004 --> 00:10:26,097
我們叫做MAC address 這個address 48個bit

198
00:10:26,097 --> 00:10:28,097
就是6個byte的長度

199
00:10:28,097 --> 00:10:31,038
第一個 是這個address是什麼

200
00:10:31,038 --> 00:10:33,075
那第二個就是他在哪一個port

201
00:10:33,075 --> 00:10:36,048
就是他這個封包是從哪個port進來

202
00:10:36,048 --> 00:10:39,022
收到的意思啦 代表說他就是在那個port

203
00:10:39,022 --> 00:10:43,029
然後這個 收到的多久 因為

204
00:10:43,029 --> 00:10:46,049
每一個database的每一個這個entry嘛

205
00:10:46,049 --> 00:10:50,046
他有時效性 就是有效期限就是大概300秒

206
00:10:50,046 --> 00:10:52,036
標準裡面大概 300就是5分鐘

207
00:10:52,036 --> 00:10:55,047
就是5分鐘之內 如果他沒有更新

208
00:10:55,047 --> 00:10:58,074
或者沒有再收過同樣的封包

209
00:10:58,074 --> 00:11:03,044
好 那這個database 這個entry呢 就會被刪除

210
00:11:03,044 --> 00:11:05,098
因為他是有時效性的 這主要就是說

211
00:11:05,098 --> 00:11:09,098
因為我們工作站可能 因為現在常常會有所謂的筆電嘛

212
00:11:09,098 --> 00:11:12,032
我們會移動 我在這個地方接上網路

213
00:11:12,032 --> 00:11:15,012
送了封包之後 可能我等下就會移走了

214
00:11:15,012 --> 00:11:18,012
那你移走之後 你當然就不存在這個網路啦

215
00:11:18,012 --> 00:11:22,019
那你這個entry呢 就要在這個database裡面 被刪除

216
00:11:22,019 --> 00:11:25,050
他會自動的有一個時效性

217
00:11:25,050 --> 00:11:28,073
標準裡面大概就是訂五分鐘 那這個是講

218
00:11:28,073 --> 00:11:32,084
我們在做這個frame的forwarding跟filtering的時候

219
00:11:32,084 --> 00:11:38,098
那 forwarding 就是根據destination的MAC address

220
00:11:38,098 --> 00:11:42,065
filtering呢 也是根據 destination的MAC address

221
00:11:42,065 --> 00:11:45,075
那接下來我們看另外一個叫做address learning

222
00:11:45,075 --> 00:11:48,065
我們看一下 那address learning呢

223
00:11:48,065 --> 00:11:51,022
就是必須根據source那個address

224
00:11:51,022 --> 00:11:53,022
就是說 最主要就是說

225
00:11:53,022 --> 00:11:58,003
因為我要知道這個封包從哪一個接口收進來

226
00:11:58,003 --> 00:12:03,007
那當然就知道說 那送這個封包的station應該就在這個接口

227
00:12:03,007 --> 00:12:05,024
這個方向的意思啦

228
00:12:05,024 --> 00:12:07,024
所以我們收到一個封包之後呢

229
00:12:07,024 --> 00:12:09,081
把封包轉送完 或者過濾完之後

230
00:12:09,081 --> 00:12:12,028
還要做一件事情 我就開始學習說

231
00:12:12,028 --> 00:12:14,098
那這個封包的這個source呢

232
00:12:14,098 --> 00:12:18,022
到底在什麼地方 那我們剛一直在強調

233
00:12:18,022 --> 00:12:22,049
所謂在什麼地方 事實上只是說他接在哪一個接口

234
00:12:22,049 --> 00:12:24,059
就是在哪一個port的意思啦

235
00:12:24,059 --> 00:12:27,043
所以我們會用所謂的source MAC address啦

236
00:12:27,043 --> 00:12:30,016
來做這個學習的這個對象

237
00:12:30,016 --> 00:12:33,043
就是把這個source MAC address檢查看看說

238
00:12:33,043 --> 00:12:35,037
他是不是我們之前有學過

239
00:12:35,037 --> 00:12:39,057
如果有學過的話 是不是他的port還是一樣

240
00:12:39,057 --> 00:12:42,051
一開始可能從這個port送封包進來

241
00:12:42,051 --> 00:12:46,074
因為我們知道說 這個我們的工作站可能譬如說是一個點

242
00:12:46,074 --> 00:12:50,041
他是移動性的 他今天在這個教室送一個封包

243
00:12:50,041 --> 00:12:52,062
有可能五分鐘之後他跑到另外一個教室

244
00:12:52,062 --> 00:12:54,009
我們送另外一個封包

245
00:12:54,009 --> 00:12:57,049
所以 是有可能同樣一個source呢

246
00:12:57,049 --> 00:13:01,049
他在不同的時間 送了不同的封包

247
00:13:01,049 --> 00:13:03,043
會從不同的接口進來

248
00:13:03,043 --> 00:13:05,056
所以我們在做學習的時候呢

249
00:13:05,056 --> 00:13:08,097
要看這個source MAC有沒有在我的database裡面

250
00:13:08,097 --> 00:13:10,057
如果沒有 就把它學起來

251
00:13:10,057 --> 00:13:12,040
如果有 就代表有學過

252
00:13:12,040 --> 00:13:14,061
但是我還要檢查說 他是不是有

253
00:13:14,061 --> 00:13:17,001
譬如說他更換他的接口

254
00:13:17,001 --> 00:13:19,088
如果更換他的port 我們就更新那個port

255
00:13:19,088 --> 00:13:22,028
然後同時呢 我們把他的時間

256
00:13:22,028 --> 00:13:25,068
再調到最上限 譬如說300秒

257
00:13:25,068 --> 00:13:27,079
等於說 我們叫做refresh

258
00:13:27,079 --> 00:13:30,022
就重新給他一個 更 一樣

259
00:13:30,022 --> 00:13:31,076
跟原來一樣長的時間

260
00:13:31,076 --> 00:13:33,076
他可能說 譬如說 第一個封包進來

261
00:13:33,076 --> 00:13:36,039
我學到之後呢 我給他300秒的有效期

262
00:13:36,039 --> 00:13:40,036
那可能經過了200多秒之後呢 第二個封包再進來

263
00:13:40,036 --> 00:13:43,050
那我們再給他300秒的有效期

264
00:13:43,050 --> 00:13:45,090
就是說他只要封包不斷的送的話

265
00:13:45,090 --> 00:13:49,011
那他這個就一直會在我們的database裡面

266
00:13:49,011 --> 00:13:53,024
被學起來 那被學起來有一個最大的好處就是剛剛提到

267
00:13:53,024 --> 00:13:56,061
在做封包的轉送或過濾的時候呢

268
00:13:56,061 --> 00:13:58,002
我需要這個address

269
00:13:58,002 --> 00:14:02,042
因為我如果沒有這個資料在資料庫裡面的話

270
00:14:02,042 --> 00:14:06,092
我就會做廣播 那廣播其實有兩個最大的問題

271
00:14:06,092 --> 00:14:09,009
我們做廣播的時候 第一個問題

272
00:14:09,009 --> 00:14:12,043
你浪費頻寬 就是因為你不知道對方在哪裡

273
00:14:12,043 --> 00:14:14,090
所以你做廣播 那就到處都送

274
00:14:14,090 --> 00:14:17,027
到處都送 就是吃掉頻寬

275
00:14:17,027 --> 00:14:19,017
第二個安全的問題就是說

276
00:14:19,017 --> 00:14:21,091
當你把封包到處都送出去的時候呢

277
00:14:21,091 --> 00:14:26,048
如果有駭客在裡面 他就自然收到你送給他的封包

278
00:14:26,048 --> 00:14:30,048
就他不用刻意去竊聽 你就送上門給他了

279
00:14:30,048 --> 00:14:35,032
一旦有廣播的時候 第一個會造成頻寬浪費的問題

280
00:14:35,032 --> 00:14:38,002
第二個就會造成安全的問題

281
00:14:38,002 --> 00:14:41,013
所以我們希望 在這個所謂的bridge LAN

282
00:14:41,013 --> 00:14:43,090
在通訊的時候 盡量不要廣播

283
00:14:43,090 --> 00:14:47,043
那不要廣播就是要靠 這個address learning要做得很好

284
00:14:47,043 --> 00:14:51,090
接下來我們就來看所謂的filtering database的例子

285
00:14:51,090 --> 00:14:54,004
我們這個圖裡面 我們可以看得到

286
00:14:54,004 --> 00:14:57,071
我們有兩個bridge 然後有四個LAN

287
00:14:57,071 --> 00:15:02,001
那我們有六個工作站 ABCDEF

288
00:15:02,001 --> 00:15:04,005
我們假設就這麼一個連接

289
00:15:04,005 --> 00:15:06,005
就連接成這樣的一個結構

290
00:15:06,005 --> 00:15:09,005
那這個結構呢 我們發現他其實是沒有root的

291
00:15:09,005 --> 00:15:13,072
那 我們就說 這個封包可能不管是誰送

292
00:15:13,072 --> 00:15:17,003
我們假設 經過一陣子之後呢 他就會學到這個東西

293
00:15:17,003 --> 00:15:19,080
我們先看第一個 這個就是bridge1

294
00:15:19,080 --> 00:15:22,070
就是bridge1的他的database

295
00:15:22,070 --> 00:15:24,047
他的database裡面到底長什麼樣子呢

296
00:15:24,047 --> 00:15:26,014
這個黃色的這個table

297
00:15:26,014 --> 00:15:29,077
首先 他會慢慢的學習 發現到

298
00:15:29,077 --> 00:15:34,071
我們有六個工作站嘛 就分別是ABCDEF

299
00:15:34,071 --> 00:15:38,052
那我們注意到 這個對bridge來講 bridge1來講

300
00:15:38,052 --> 00:15:41,019
E跟F在左上角

301
00:15:41,019 --> 00:15:45,089
EF其實是連到bridge1的port1

302
00:15:45,089 --> 00:15:49,046
所以對EF來講 對這個bridge1來講的話

303
00:15:49,046 --> 00:15:52,016
他事實上就是在這個port1的地方

304
00:15:52,016 --> 00:16:00,007
那其他的ABCD 對bridge1來講的話都是從port2連接過去的

305
00:16:00,007 --> 00:16:03,074
所以我們發現到說 這個ABCD呢

306
00:16:03,074 --> 00:16:06,018
在這個database裡面 都是在port2

307
00:16:06,018 --> 00:16:08,011
然後最右邊那個欄位

308
00:16:08,011 --> 00:16:10,078
我們說那個就是所謂的時間

309
00:16:10,078 --> 00:16:13,065
就我們假設他有一些時間還在裡面嘛

310
00:16:13,065 --> 00:16:15,009
那時間到了就要清掉

311
00:16:15,009 --> 00:16:17,025
那時間還沒到之前 就是有一個

312
00:16:17,025 --> 00:16:21,006
這個剩餘的有效期限 那我們同樣的

313
00:16:21,006 --> 00:16:24,083
我們來看一下 對bridge2來講的話 他不一樣

314
00:16:24,083 --> 00:16:26,070
對bridge2來講 我們發現

315
00:16:26,070 --> 00:16:31,030
ABEF 就是上面的四個station

316
00:16:31,030 --> 00:16:34,047
對bridge2來講的話 都是在port1

317
00:16:34,047 --> 00:16:38,021
就是port1才有辦法連到這四個station

318
00:16:38,021 --> 00:16:41,081
所以對這個bridge2來講的話 ABCD呢

319
00:16:41,081 --> 00:16:48,075
ABEF呢 都在port1 那C呢 是連在port2

320
00:16:48,075 --> 00:16:53,076
所以C對這個bridge2來講 他就是在port2這邊

321
00:16:53,076 --> 00:16:55,046
然後最後一個就是D

322
00:16:55,046 --> 00:16:58,096
D對bridge2來講 他是連在port3

323
00:16:58,096 --> 00:17:03,087
port3 所以D 本身在這個database裡面就是在port3

324
00:17:03,087 --> 00:17:07,004
就是說經過一個這個封包的轉送

325
00:17:07,004 --> 00:17:09,091
這個一個流程啦 或者一個過程

326
00:17:09,091 --> 00:17:14,058
我們最後呢 就會讓bridge1 就是學到右上角這個表

327
00:17:14,058 --> 00:17:17,042
那bridge2呢 就會學到右下角這個表

328
00:17:17,042 --> 00:17:19,082
我們特別強調 一開始的時候呢

329
00:17:19,082 --> 00:17:21,082
這個表都是空的 都沒有

330
00:17:21,082 --> 00:17:25,059
那經過封包的轉送啦 這個處理的過程之後呢

331
00:17:25,059 --> 00:17:27,083
他就會慢慢把這個表學起來

332
00:17:27,083 --> 00:17:29,083


