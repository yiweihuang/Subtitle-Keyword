1
00:00:09,8 --> 00:00:10,30
好 我們剛剛提到說

2
00:00:10,31 --> 00:00:12,21
這個所謂的collision window

3
00:00:12,21 --> 00:00:15,65
就強調於在於說我們要花多久的時間

4
00:00:15,65 --> 00:00:19,55
才可以確認說我們所送出去的封包

5
00:00:19,55 --> 00:00:21,98
到底有沒有發生collision

6
00:00:21,98 --> 00:00:23,95
我們這個叫做所謂的collision window

7
00:00:23,95 --> 00:00:25,35
那這個collision window

8
00:00:25,35 --> 00:00:30,21
他的這個在 10M ethernet的這個標準之下呢

9
00:00:30,21 --> 00:00:34,8
我們說 他就是來回的一個round-trip time

10
00:00:34,91 --> 00:00:38,11
collision window就相當於一個round-trip delay

11
00:00:38,11 --> 00:00:41,25
就是我們假設這個網路呢 最遠的兩端

12
00:00:41,25 --> 00:00:45,77
我們訊號傳遞的時間假設一邊一趟叫做A

13
00:00:45,78 --> 00:00:50,28
那我們講來回就是所謂的2A 那這個2A的時間

14
00:00:50,28 --> 00:00:54,1
就是我們要偵測有沒有發生collision的時間

15
00:00:54,1 --> 00:00:57,38
事實上 如果這個發生衝撞的兩個station

16
00:00:57,38 --> 00:01:00,17
他們越靠近的話 這個時間就越短

17
00:01:00,18 --> 00:01:04,10
因為我只要送出去 他可能在旁邊 他立刻送出來

18
00:01:04,10 --> 00:01:06,27
這兩個幾乎同時間送出去

19
00:01:06,28 --> 00:01:08,85
這個我偵測很快 因為他們很靠近

20
00:01:08,85 --> 00:01:11,11
訊號送過去很快就衝撞

21
00:01:11,11 --> 00:01:13,5
很快就回來 因為距離很短

22
00:01:13,5 --> 00:01:18,27
但是如果我們說 如果這兩個會衝撞的collision

23
00:01:18,28 --> 00:01:21,65
會衝撞這個station他們的距離比較遠的話

24
00:01:21,65 --> 00:01:24,91
那我們的訊號就要送的比較久才會到對方

25
00:01:24,91 --> 00:01:27,35
然後發生collision再回來

26
00:01:27,35 --> 00:01:30,24
這個來回的時間就會花比較長的時間

27
00:01:30,25 --> 00:01:34,58
好 那底下呢我們就用一個例子來解釋說

28
00:01:34,58 --> 00:01:36,58
這個發生collision

29
00:01:36,58 --> 00:01:40,68
在最長的這個時間狀況之下要花多久的時間

30
00:01:40,68 --> 00:01:43,98
我們看一下 我們首先說假設

31
00:01:43,98 --> 00:01:49,71
像在這個例子上面呢 我們有兩個工作站

32
00:01:49,71 --> 00:01:53,68
一個A在最左邊 B在最右邊

33
00:01:53,68 --> 00:01:56,21
那我們假設呢這個cable的這個

34
00:01:56,21 --> 00:01:58,51
我們叫做propagation delay 就是a

35
00:01:58,51 --> 00:02:00,85
就是他們最遠的這個距離呢

36
00:02:00,85 --> 00:02:04,41
就是需要花這個a的這個時間

37
00:02:04,41 --> 00:02:07,45
傳遞時間 從一邊到一邊 是a的時間

38
00:02:07,45 --> 00:02:12,21
那我們說在時間t 在time t的時候呢

39
00:02:12,21 --> 00:02:15,90
A就開始把封包丟上去

40
00:02:15,91 --> 00:02:21,5
A丟上去 好然後這個丟上去之後就開始往兩邊跑嘛

41
00:02:21,5 --> 00:02:26,45
那因為我們講 A在最邊邊嘛 所以他再往邊邊跑的呢

42
00:02:26,45 --> 00:02:29,54
當然就會被我們叫做所謂的terminator

43
00:02:29,55 --> 00:02:32,58
最邊邊就把它吸掉 把它吸收掉了啦

44
00:02:32,58 --> 00:02:36,48
但是呢 他的封包呢就會開始往右邊跑

45
00:02:36,48 --> 00:02:40,51
我們說 這個跑到最右邊

46
00:02:40,51 --> 00:02:43,45
這B 在B的這個門口

47
00:02:43,45 --> 00:02:49,7
我們這個時候叫t加a-ℇ 就是t是傳送的時間

48
00:02:49,8 --> 00:02:53,31
然後他花a的時間 這個訊號花a的時間

49
00:02:53,31 --> 00:02:56,71
然後到的最遠的另外一端 就是B

50
00:02:56,71 --> 00:02:59,1
那我們說-ℇ 就代表是說

51
00:02:59,1 --> 00:03:04,28
在這個到達B的門口之前的一個短短的時間

52
00:03:04,28 --> 00:03:08,84
代表說還沒有到達B啦 因為如果到了B  B要送

53
00:03:08,85 --> 00:03:11,58
她一聽是busy B就不能送了

54
00:03:11,58 --> 00:03:13,48
因為我們的protocol就是說

55
00:03:13,48 --> 00:03:16,55
在送之前會去聽聽看 只要是busy

56
00:03:16,55 --> 00:03:18,75
就看到訊號他就自己就不能送

57
00:03:18,75 --> 00:03:21,51
那我們現在為了要讓這個B可以送

58
00:03:21,51 --> 00:03:26,60
所以我們說這個訊號呢 只在t加a-ℇ

59
00:03:26,61 --> 00:03:30,71
然後到達這個B的門口 這個時候B就去聽聽看

60
00:03:30,71 --> 00:03:33,55
就發現說這個時候去聽的話

61
00:03:33,55 --> 00:03:36,51
當然他就是按照我們的設計

62
00:03:36,51 --> 00:03:39,77
現在去聽這個地方 他是idle的

63
00:03:39,78 --> 00:03:42,18
idle的結果呢 我們就是說好

64
00:03:42,18 --> 00:03:44,71
那idle的話呢 B就把它送上去

65
00:03:44,71 --> 00:03:48,31
就這個黃色的這個 B就把封包丟上去啦

66
00:03:48,31 --> 00:03:52,45
因為他發現他去偵測這個cable上面是idle

67
00:03:52,45 --> 00:03:57,7
那接下來就是說 這兩個呢就會撞在一起

68
00:03:57,8 --> 00:04:02,78
就是A的紫色的封包 跟這個B黃色的封包呢

69
00:04:02,78 --> 00:04:05,18
這兩個封包呢就會撞在一起

70
00:04:05,18 --> 00:04:07,98
那撞在一起的封包呢 就會開始一樣

71
00:04:07,98 --> 00:04:11,35
會擴散開來 那擴散到最右邊

72
00:04:11,35 --> 00:04:13,11
一樣他有terminator

73
00:04:13,11 --> 00:04:16,58
會把這個反正terminator就是反正所有的訊號

74
00:04:16,58 --> 00:04:19,31
到了terminator就會把它吸掉

75
00:04:19,31 --> 00:04:22,60
就沒有了沒關係 但是呢最重要的是說

76
00:04:22,60 --> 00:04:25,1
他會往另外一邊彈回去啊

77
00:04:25,1 --> 00:04:28,27
所以我們發現到這個collision的封包呢

78
00:04:28,28 --> 00:04:30,65
就會再送回給A

79
00:04:30,65 --> 00:04:35,41
所以這裡最關鍵的地方就是說 那我們看一下A

80
00:04:35,41 --> 00:04:41,98
他在t的時間開始送 在t加a的時候就快到達B的門口

81
00:04:41,98 --> 00:04:45,51
然後B這個時候送上去就collision

82
00:04:45,51 --> 00:04:51,34
然後還要再花a的時間 這個訊號傳回給A嘛

83
00:04:51,35 --> 00:04:57,25
所以最後呢在t加2a-ℇ的時候呢

84
00:04:57,25 --> 00:05:01,68
這個訊號會回到A的這個門口來

85
00:05:01,68 --> 00:05:04,80
那當然如果是t加2a就到了

86
00:05:04,81 --> 00:05:09,75
這個時候A就發現了collision 就是說你看對A來講

87
00:05:09,75 --> 00:05:13,1
事實上他是把這個封包丟出去

88
00:05:13,1 --> 00:05:15,61
然後在這個地方發生collision

89
00:05:15,61 --> 00:05:18,55
collision之後呢再送回來

90
00:05:18,55 --> 00:05:23,61
那他要這麼久的時間才知道有沒有發生collision

91
00:05:23,61 --> 00:05:27,68
也就是這個collision本身事實上 從A的角度來看

92
00:05:27,68 --> 00:05:32,31
他把封包送上去 他事實上必須經過2a的時間

93
00:05:32,31 --> 00:05:36,5
他才知道有沒有發生collision

94
00:05:36,5 --> 00:05:38,61
所以這個時間點就是說 這是跑不掉的

95
00:05:38,61 --> 00:05:43,1
因為網路的距離的關係 他一定要花2a

96
00:05:43,1 --> 00:05:45,58
2a就是訊號來回的時間

97
00:05:45,58 --> 00:05:50,15
這個是想避免 想減少 也不能減少

98
00:05:50,15 --> 00:05:54,91
因為訊號他就是一定要送給對方 然後再跑回來

99
00:05:54,91 --> 00:05:57,35
這個2a的時間是跑不掉的

100
00:05:57,35 --> 00:06:01,91
那在這個也就是說 最糟糕的情況之下

101
00:06:01,91 --> 00:06:07,68
我A送出去的封包 他要花2a的時間才會再回來

102
00:06:07,68 --> 00:06:09,75
那在這個時間之內

103
00:06:09,75 --> 00:06:12,91
我們就不可以封包送完了

104
00:06:12,91 --> 00:06:17,85
因為我要花2a的時間才能判斷封包到底有沒有collision

105
00:06:17,85 --> 00:06:21,75
那在這個還沒有確認collision之前

106
00:06:21,75 --> 00:06:25,87
我的封包不能送完

107
00:06:25,88 --> 00:06:27,71
那我們來舉一個例子說

108
00:06:27,71 --> 00:06:31,51
那如果我們把封包送完了怎麼辦

109
00:06:31,51 --> 00:06:35,68
如果說A的封包太短 我們講太短

110
00:06:35,68 --> 00:06:40,65
那假設他的封包長度只有a 我們用時間來看只有a

111
00:06:40,65 --> 00:06:42,81
那他會發生什麼事情 也就是說

112
00:06:42,81 --> 00:06:45,45
a的時候相當於在這個時間點

113
00:06:45,45 --> 00:06:50,31
我們講說 好 在t加a的時候呢我們說

114
00:06:50,31 --> 00:06:54,25
因為A的封包比較短嘛 他在t加a他已經送完了

115
00:06:54,25 --> 00:06:58,51
那送完了之後他這個封包這邊就已經 尾巴結束了嘛

116
00:06:58,51 --> 00:07:01,61
一開始在這邊送 到了t加a的時候呢

117
00:07:01,61 --> 00:07:03,41
他封包已經送完了

118
00:07:03,41 --> 00:07:05,55
所以送完了之後對A來講

119
00:07:05,55 --> 00:07:09,38
他已經送完啦 可是送完之後發現

120
00:07:09,38 --> 00:07:13,5
送完之後在t加2a 已經送完了喔

121
00:07:13,5 --> 00:07:16,48
送完之後經過A的時候才發現collision跑回來了

122
00:07:16,48 --> 00:07:21,78
這個時候A他就會所謂的confuse啦 他就會不知道說

123
00:07:21,78 --> 00:07:26,15
那我現在我的封包在t加a就已經送完了

124
00:07:26,15 --> 00:07:30,58
可是我在t加2a的時候我偵測到一個collision

125
00:07:30,58 --> 00:07:34,91
這個collision是我當時送那個封包的collision嗎？

126
00:07:34,91 --> 00:07:38,51
不一定喔 就不一定囉 就有可能說

127
00:07:38,51 --> 00:07:42,45
譬如說我送完之後像這個封包 我可能送完了

128
00:07:42,45 --> 00:07:47,38
我這個cable就乾淨了 因為封包訊號就流過去了嘛

129
00:07:47,38 --> 00:07:50,88
那說不定在他的旁邊的兩個工作站

130
00:07:50,88 --> 00:07:53,35
在這個封包流過去之後呢

131
00:07:53,35 --> 00:07:57,95
他們都發現這個封包 這個cable已經變成idle了嘛

132
00:07:57,95 --> 00:07:59,75
那他們這兩個都把他送上去

133
00:07:59,75 --> 00:08:02,15
就collision 然後再送回來

134
00:08:02,15 --> 00:08:06,38
也就是說如果我們在t加a把封包送完

135
00:08:06,38 --> 00:08:10,91
那我發現在t加2a的時候呢發生的collision的訊號回來

136
00:08:10,91 --> 00:08:13,98
其實我不知道這個collision

137
00:08:13,98 --> 00:08:16,31
是不是我之前的封包的collision

138
00:08:16,31 --> 00:08:18,78
還是說我封包已經送完了

139
00:08:18,78 --> 00:08:23,15
然後是別人的collision跑回來送到我門口來

140
00:08:23,15 --> 00:08:26,75
所以我就不知道那個封包有沒有發生collision

141
00:08:26,75 --> 00:08:30,10
那如果你的封包發生collision你會重送

142
00:08:30,11 --> 00:08:33,88
你的封包如果沒有發生collision你就不會重送啊

143
00:08:33,87 --> 00:08:35,44
這個關係很大的喔

144
00:08:35,44 --> 00:08:42,97
所以我們說為了確認每一個station在送封包的時候

145
00:08:42,97 --> 00:08:46,38
他都要有足夠的時間能夠判斷

146
00:08:46,38 --> 00:08:48,85
這個封包有沒有發生collision

147
00:08:48,85 --> 00:08:52,71
那因為偵測collision我們說

148
00:08:52,71 --> 00:08:55,68
他最多他需要2a的時間

149
00:08:55,68 --> 00:08:58,78
這是等於說為了保證

150
00:08:58,78 --> 00:09:03,7
有沒有辦法偵測到有沒有collision 保證一定要2a啦

151
00:09:03,8 --> 00:09:08,85
就是2a在我們這個標準理面呢 剛好就是51.2 µs

152
00:09:08,85 --> 00:09:10,88
我們就來看看就是說

153
00:09:10,88 --> 00:09:16,15
為了確認你的封包在傳送的時候呢有沒有發生collision

154
00:09:16,15 --> 00:09:20,64
所以你一定要聽collision window的時間

155
00:09:20,65 --> 00:09:23,88
而這個時間就是來回的時間

156
00:09:23,88 --> 00:09:28,78
阿這個時間在標準裡面 就是51.2 µs

157
00:09:28,78 --> 00:09:32,64
然後加上你送的速度 是10Mbps

158
00:09:32,65 --> 00:09:37,35
所以這個一乘起來 就是你至少要送512bits

159
00:09:37,35 --> 00:09:40,25
也就是說換算成byte就是64bytes

160
00:09:40,25 --> 00:09:42,28
就是你的封包呢不能太短

161
00:09:42,28 --> 00:09:43,91
因為如果你的封包太短

162
00:09:43,91 --> 00:09:47,25
我們剛剛提到 你可能其實你已經封包送完了

163
00:09:47,25 --> 00:09:50,7
可是你後面呢竟然又聽到一個collision

164
00:09:50,8 --> 00:09:52,78
你就不知道這個collision是不是你的封包發生collision

165
00:09:52,78 --> 00:09:55,68
還是別人的封包發生collision

166
00:09:55,68 --> 00:09:58,74
所以這個例子裡面 我們剛提到

167
00:09:58,75 --> 00:10:03,78
我們在t的時候呢 A開始送 然後在

168
00:10:03,78 --> 00:10:07,11
我們假設a 代表說一個link的latency

169
00:10:07,11 --> 00:10:10,1
就是一個link一段 他們的propagation delay

170
00:10:10,1 --> 00:10:12,68
他的時間這個要花多少時間把訊號

171
00:10:12,68 --> 00:10:15,88
從一端送到另外一端 我們叫a

172
00:10:15,88 --> 00:10:20,91
我們剛剛提到說 A在t的時間開始送

173
00:10:20,91 --> 00:10:24,75
然後在t加a的時間會到這個B的門口

174
00:10:24,75 --> 00:10:27,1
那假設呢我們說

175
00:10:27,1 --> 00:10:29,71
這個B呢這個時候開始把封包丟出去

176
00:10:29,71 --> 00:10:33,18
然後這個就會馬上collision 馬上collision之後呢

177
00:10:33,18 --> 00:10:35,65
B就偵測到了 那B偵測到

178
00:10:35,65 --> 00:10:40,21
按照我們剛剛講的 他就會送一個jam 32-bit

179
00:10:40,21 --> 00:10:41,60
讓他撞得更嚴重一點

180
00:10:41,61 --> 00:10:45,65
阿這個地方反正這個collision已經發生了嘛

181
00:10:45,65 --> 00:10:49,45
所以B可能就會再送一個32-bit讓他撞得更嚴重

182
00:10:49,45 --> 00:10:51,45
好 那同時呢

183
00:10:51,45 --> 00:10:55,91
這個衝撞的這個封包呢 就會再送回給A

184
00:10:55,91 --> 00:10:58,85
但是A沒有辦法發現這個事情

185
00:10:58,85 --> 00:11:00,65
沒有辦法發現這個事實

186
00:11:00,65 --> 00:11:05,8
一直要等到t加2a 就是這個衝撞的這個訊號呢

187
00:11:05,8 --> 00:11:08,75
也要花另外a的時間 才有辦法回到

188
00:11:08,75 --> 00:11:11,41
這個所謂的station A這邊來嘛

189
00:11:11,41 --> 00:11:13,78
所以在t加2a的時間點

190
00:11:13,78 --> 00:11:17,74
這個station A呢才有辦法偵測到

191
00:11:17,75 --> 00:11:20,1
那我們最後的結論就是說

192
00:11:20,1 --> 00:11:24,28
A呢他就必須一直送這個封包

193
00:11:24,28 --> 00:11:27,41
因為他為了偵測這個collision所以他必須一直送

194
00:11:27,41 --> 00:11:31,28
我們說A must transmit for 2a

195
00:11:31,28 --> 00:11:38,11
就是A這個工作站呢 他一定要送2a的時間 他要持續的送

196
00:11:38,11 --> 00:11:41,60
因為他要花2a的時間才有辦法偵測有沒有collision

197
00:11:41,61 --> 00:11:45,71
所以那必須至少送2a的時間 這麼久

198
00:11:45,71 --> 00:11:49,48
那送2a的時間可以送多少量

199
00:11:49,48 --> 00:11:51,85
我們說網路的長度呢

200
00:11:51,85 --> 00:11:56,71
如果是標準的所謂的2500公尺的長度

201
00:11:56,71 --> 00:12:01,8
那訊號來回的時間 大概是51.2 µs

202
00:12:01,8 --> 00:12:05,1
這是可以算得出來的 就是說事實上

203
00:12:05,1 --> 00:12:08,81
我們說200公尺遠的距離 中間可能還有repeater

204
00:12:08,81 --> 00:12:11,15
還有我們講transmitter

205
00:12:11,15 --> 00:12:14,78
還有這個我們之前介紹的像所謂的tape

206
00:12:14,78 --> 00:12:20,25
所以我們的封包從這個工作站丟進去 經過這個cable

207
00:12:20,25 --> 00:12:25,45
經過這個repeater 反正中間有一些設備都沒有關係

208
00:12:25,45 --> 00:12:27,31
訊號的轉送都算進去

209
00:12:27,31 --> 00:12:32,1
就是來回時間大概就是51.2 µs

210
00:12:32,1 --> 00:12:37,28
那我們說2a的時間就是51.2 µs

211
00:12:37,28 --> 00:12:40,61
那我們至少要送這麼長的時間

212
00:12:40,61 --> 00:12:44,25
那送這麼長的時間到底你會送多少量

213
00:12:44,25 --> 00:12:47,84
這跟什麼有關係呢？跟你的網路速度就有關了

214
00:12:47,85 --> 00:12:49,71
網路速度有關

215
00:12:49,71 --> 00:12:53,48
就是說如果我們的網路速度呢是10Mbps

216
00:12:53,48 --> 00:12:56,91
我們送了 我們必須送2a的時間

217
00:12:56,91 --> 00:13:01,61
那這個時間就是算起來 就是512bits

218
00:13:01,61 --> 00:13:04,75
就是說我們至少要送64個

219
00:13:04,75 --> 00:13:10,28
這個相當於就是等於就是64個bytes的意思

220
00:13:10,28 --> 00:13:14,18
這個我們講這就是64個bytes的由來

221
00:13:14,18 --> 00:13:15,88
就是說為什麼

222
00:13:15,88 --> 00:13:21,31
ethernet的封包最短一定要是64個bytes

223
00:13:21,31 --> 00:13:23,37
就是因為說我們考慮到說

224
00:13:23,38 --> 00:13:25,71
我們要做所謂的collision的偵測

225
00:13:25,71 --> 00:13:29,15
那collision的偵測呢一定要偵測2a的時間

226
00:13:29,15 --> 00:13:35,15
那在標準裡面 這個2a的時間來回就是51.2 µs

227
00:13:35,15 --> 00:13:37,74
那你至少要送這麼久

228
00:13:37,75 --> 00:13:42,51
那我們的速度呢又是10Mb 所以這個一乘起來

229
00:13:42,51 --> 00:13:45,78
就是說那你至少要送512bits

230
00:13:45,78 --> 00:13:48,15
至少你要送64個bytes

231
00:13:48,15 --> 00:13:50,5
這是為什麼我們講說 ethernet呢

232
00:13:50,5 --> 00:13:53,31
最短最短就是所謂64個bytes啦

233
00:13:53,31 --> 00:13:56,1
那我們當然也可以從另外一個角度來看

234
00:13:56,1 --> 00:14:00,91
就是我們為了要限制這個網路的這個latency

235
00:14:00,91 --> 00:14:02,68
就網路最長的latency呢

236
00:14:02,68 --> 00:14:07,25
我們講把他設定成51.2 假設用這樣來設計的話

237
00:14:07,25 --> 00:14:09,88
那倒過來講 就我們假設呢

238
00:14:09,88 --> 00:14:15,60
我們不希望這個網路的latency呢太長 或者太久

239
00:14:15,61 --> 00:14:17,25
所以我們先設計說

240
00:14:17,25 --> 00:14:21,74
假設我希望是51.2 µs 那用這個去倒推

241
00:14:21,75 --> 00:14:29,91
也可以推到說 那你網路呢最長就是2.5公里

242
00:14:29,91 --> 00:14:32,78
大概這個長度就是指這樣的意思

243
00:14:32,78 --> 00:14:36,64
所以不管是從先有網路的長度

244
00:14:36,65 --> 00:14:40,8
2.5公里倒推我們的這個

245
00:14:40,8 --> 00:14:44,28
所謂的round-trip time是51.2 µs

246
00:14:44,28 --> 00:14:46,28
或者說我們先設定

247
00:14:46,28 --> 00:14:50,81
我們這個來回的時間不超過51.2 µs

248
00:14:50,81 --> 00:14:55,65
我倒推網路最多呢 就是2.5公里 都可以啦

249
00:14:55,65 --> 00:14:57,51
就是說我們在標準裡面

250
00:14:57,51 --> 00:15:01,38
就是我的網路呢 最長是2.5公里

251
00:15:01,38 --> 00:15:07,65
那訊號來回 是51.2 µs 然後如果用10Mbps來送

252
00:15:07,65 --> 00:15:12,95
那得到的就是512bits 就是64bytes

253
00:15:12,95 --> 00:15:16,71
我們講這個是在ethernet裡面非常重要的一個參數

254
00:15:16,71 --> 00:15:22,21
目前有兩個很重要 一個就是封包最長1518個byte

255
00:15:22,21 --> 00:15:26,25
這是為了大家公平的使用這個cable

256
00:15:26,25 --> 00:15:31,11
不要送太長 而且送太長可能會獨佔就佔得太久

257
00:15:31,11 --> 00:15:34,58
另外一個不能送太短 就64個bytes

258
00:15:34,58 --> 00:15:37,48
那不能送太短的理由是因為

259
00:15:37,48 --> 00:15:42,21
我們要成功的偵測你送的封包有沒有發生collision

260
00:15:42,21 --> 00:15:45,50
如果你的封包送的太短就沒有辦法

261
00:15:45,51 --> 00:15:49,11
有可能沒有辦法正確偵測的這個封包是不是

262
00:15:49,11 --> 00:15:51,21
有沒有發生collision
