1
00:00:01,820 --> 00:00:04,980
我們來看一下字串比對的技術

2
00:00:04,980 --> 00:00:06,880
就是所謂的string matching algorihthms

3
00:00:07,060 --> 00:00:09,400
在這個字串比對的演算法裡面

4
00:00:09,500 --> 00:00:12,980
我們先來看看一般我們做封包內容比對

5
00:00:13,100 --> 00:00:15,740
我們講這個比對引擎的結構

6
00:00:15,960 --> 00:00:18,120
看一下這個圖我們知道說

7
00:00:18,360 --> 00:00:22,460
封包是從網路這邊進來

8
00:00:22,460 --> 00:00:23,920
就是網路的介面卡

9
00:00:23,920 --> 00:00:24,920
所謂的網卡

10
00:00:25,020 --> 00:00:27,020
我們網卡把封包收起來

11
00:00:27,020 --> 00:00:29,000
一般叫作Packet Capture

12
00:00:29,000 --> 00:00:30,940
就是抓到第一個封包

13
00:00:31,180 --> 00:00:34,860
那我們會先做一個叫Decoder的動作

14
00:00:34,900 --> 00:00:36,900
就是把封包上面的一個格式化

15
00:00:36,900 --> 00:00:37,700
就是說

16
00:00:38,040 --> 00:00:42,340
裡面可能有一些重複的特殊的字元先把它去掉

17
00:00:42,340 --> 00:00:43,880
先把它解碼

18
00:00:44,080 --> 00:00:47,260
然後我們最重要的是要把封包的內容拿出來

19
00:00:47,260 --> 00:00:49,240
把封包內容拿出來之後

20
00:00:49,400 --> 00:00:51,500
就會開始進行這個最關鍵的

21
00:00:51,500 --> 00:00:53,500
叫做Pattern Matching Engine

22
00:00:53,700 --> 00:00:56,100
這個引擎就是把封包的內容

23
00:00:56,220 --> 00:00:59,400
把它從封包裡面萃取出來

24
00:00:59,640 --> 00:01:04,420
然後跟我們剛剛提到的Patterm Data Base

25
00:01:04,600 --> 00:01:06,600
就是特徵碼資料庫

26
00:01:06,600 --> 00:01:07,980
它要做比對

27
00:01:07,980 --> 00:01:09,500
在這個地方做比對

28
00:01:09,760 --> 00:01:11,760
那比對這個動作就是由這個引擎

29
00:01:11,760 --> 00:01:13,060
可能是軟體

30
00:01:13,280 --> 00:01:15,720
也可能用硬體來協助加速

31
00:01:15,720 --> 00:01:17,200
比對之後

32
00:01:17,660 --> 00:01:19,660
可能有match

33
00:01:19,660 --> 00:01:21,440
或者可能沒有match

34
00:01:21,680 --> 00:01:25,720
我們就會把這個output結果通知剛剛提到的

35
00:01:25,720 --> 00:01:27,600
可能通知我們的系統說

36
00:01:27,600 --> 00:01:28,840
這個封包是乾淨的

37
00:01:28,980 --> 00:01:31,080
這個封包是有問題的等等

38
00:01:31,200 --> 00:01:34,060
就是封包進來先做封包的擷取

39
00:01:34,060 --> 00:01:35,560
然後整理

40
00:01:35,720 --> 00:01:37,720
然後把字串拿出來

41
00:01:37,860 --> 00:01:39,720
再把那個content

42
00:01:39,720 --> 00:01:41,040
封包的內容拿出來做比對

43
00:01:41,340 --> 00:01:43,980
比對結果就輸出

44
00:01:43,980 --> 00:01:45,800
每一個封包都要這樣做

45
00:01:45,900 --> 00:01:49,960
所以這個處理的資料量是非常大

46
00:01:49,960 --> 00:01:51,220
而且要常常做

47
00:01:51,220 --> 00:01:52,860
每一個封包都要做這件事

48
00:01:53,020 --> 00:01:55,020
我們就來看看

49
00:01:55,240 --> 00:01:57,300
那到底什麼叫做字串比對呢

50
00:01:57,480 --> 00:02:00,000
什麼叫做Patern Matching

51
00:02:00,000 --> 00:02:01,100
或者String Matching

52
00:02:01,100 --> 00:02:03,000
就是兩個字串到底一不一樣

53
00:02:03,000 --> 00:02:04,300
這個非常有名

54
00:02:04,380 --> 00:02:06,460
叫做字串比對的問題

55
00:02:06,620 --> 00:02:11,440
我們就說一個string就是一個符號

56
00:02:11,440 --> 00:02:13,340
就是一系列的符號

57
00:02:13,660 --> 00:02:18,740
比如說一系列所謂的字元所形成的叫做一個string

58
00:02:18,740 --> 00:02:20,200
那我們剛剛說

59
00:02:20,200 --> 00:02:21,780
我們會有一個data base

60
00:02:22,040 --> 00:02:26,180
就是會有一個特徵碼資料庫叫做P

61
00:02:26,180 --> 00:02:27,240
它是一個set

62
00:02:27,680 --> 00:02:29,680
它是一個a set of

63
00:02:29,860 --> 00:02:31,860
finite set of strings

64
00:02:32,060 --> 00:02:34,800
就是我每一個sting就是一個

65
00:02:34,960 --> 00:02:38,560
等於說每一個特徵碼就是一個string

66
00:02:39,140 --> 00:02:41,140
然後我有一個資料庫

67
00:02:41,140 --> 00:02:41,960
我們叫做P

68
00:02:41,980 --> 00:02:43,980
它有P1 P2到Pk

69
00:02:44,140 --> 00:02:47,660
我有k個特徵碼的意思

70
00:02:47,660 --> 00:02:49,660
假設我有k個特徵碼

71
00:02:49,660 --> 00:02:51,560
這個也可以叫做Pattern

72
00:02:52,360 --> 00:02:54,360
然後T是什麼

73
00:02:54,580 --> 00:02:56,580
T就是把它想像成封包的內容

74
00:02:56,720 --> 00:02:58,720
今天有一個封包進來

75
00:02:59,120 --> 00:03:01,400
我們說把它的封包的頭尾去掉

76
00:03:01,400 --> 00:03:03,220
把那個內容把它找出來

77
00:03:03,220 --> 00:03:04,400
這個所謂的T

78
00:03:04,620 --> 00:03:06,620
它也是一個Text String

79
00:03:06,860 --> 00:03:09,640
因為封包的內容也是一些字元

80
00:03:09,640 --> 00:03:10,760
就是字串

81
00:03:10,760 --> 00:03:12,600
那問題是什麼

82
00:03:12,600 --> 00:03:14,100
問題就是要問說

83
00:03:14,360 --> 00:03:17,340
這個T裡面就是封包的內容

84
00:03:17,540 --> 00:03:24,380
是不是含有這個特徵資料庫裡面的某一個特徵

85
00:03:24,380 --> 00:03:25,820
或者某幾個特徵

86
00:03:25,820 --> 00:03:27,660
那它們在哪裡

87
00:03:27,660 --> 00:03:29,260
就這樣的意思

88
00:03:29,260 --> 00:03:30,820
就是所謂的字串比對

89
00:03:30,820 --> 00:03:32,400
就是要比對說

90
00:03:32,760 --> 00:03:39,320
封包內容裡面是不是含有特徵資料庫裡面的某一個特徵

91
00:03:39,320 --> 00:03:40,240
在哪裡

92
00:03:40,240 --> 00:03:42,100
在哪個位置的意思

93
00:03:42,100 --> 00:03:43,500
這就是所謂的問題

94
00:03:43,800 --> 00:03:48,800
我們來看一個很直接的這種比對的演算法

95
00:03:49,020 --> 00:03:52,460
就是說我們就看說這個就是我們封包的內容

96
00:03:53,340 --> 00:03:56,600
就是我們把封包的內容已經萃取出來了

97
00:03:57,200 --> 00:03:59,200
那這個是我們的特徵碼資料庫

98
00:03:59,200 --> 00:04:01,640
就是我們這邊可能會有不同的特徵碼

99
00:04:01,640 --> 00:04:03,600
我們講特徵碼的長度

100
00:04:03,600 --> 00:04:04,880
可能有長有短

101
00:04:04,880 --> 00:04:05,480
不一定

102
00:04:05,480 --> 00:04:07,080
這就是我們的特徵碼

103
00:04:07,080 --> 00:04:08,400
我們就是要問說

104
00:04:09,660 --> 00:04:11,660
這個封包內容裡面

105
00:04:11,840 --> 00:04:14,200
有沒有包含我們某一個特徵碼

106
00:04:14,380 --> 00:04:17,200
我們就用某一個特徵碼來解釋

107
00:04:17,480 --> 00:04:19,860
比如說我們用這個紫色的特徵碼

108
00:04:19,860 --> 00:04:21,360
比如說這個特徵碼是這樣

109
00:04:21,820 --> 00:04:24,840
等下這個紫色的特徵碼你要說

110
00:04:25,140 --> 00:04:29,100
這個字串裡面有沒有含這個紫色的特徵碼

111
00:04:29,700 --> 00:04:31,700
我們的做法可以很簡單

112
00:04:31,700 --> 00:04:33,080
就是把特徵碼移過來

113
00:04:33,360 --> 00:04:35,600
就是我們這邊把它對齊

114
00:04:35,780 --> 00:04:39,260
看這個特徵碼的長度把它對齊

115
00:04:39,260 --> 00:04:40,780
然後就開始比對

116
00:04:40,780 --> 00:04:42,200
一個字一個字比

117
00:04:42,480 --> 00:04:45,500
比如說A比A B C D

118
00:04:45,500 --> 00:04:46,480
就一個一個比

119
00:04:46,560 --> 00:04:48,640
完全一樣就叫做Match

120
00:04:49,040 --> 00:04:51,040
一個不一樣就叫做不Match

121
00:04:51,040 --> 00:04:52,900
因為沒有完全一樣就不算

122
00:04:52,900 --> 00:04:53,860
也就是說

123
00:04:53,860 --> 00:04:55,960
如果說這上面的這些內容

124
00:04:56,420 --> 00:04:59,240
跟這上面的內容是一模一樣的

125
00:04:59,240 --> 00:05:00,740
我們就說

126
00:05:00,740 --> 00:05:01,980
這就是Match的意思

127
00:05:01,980 --> 00:05:03,980
如果這個沒有Match

128
00:05:03,980 --> 00:05:05,820
萬一沒有Match

129
00:05:06,100 --> 00:05:08,400
我們就移一格

130
00:05:08,400 --> 00:05:09,540
就是移一個byte

131
00:05:09,860 --> 00:05:14,000
就看這裡沒有比對那這裡是不是可以比對

132
00:05:14,000 --> 00:05:14,860
比這裡

133
00:05:14,860 --> 00:05:16,640
那是比這裡

134
00:05:16,840 --> 00:05:19,460
一樣再檢查一次

135
00:05:19,460 --> 00:05:21,400
不管有沒有

136
00:05:21,400 --> 00:05:22,240
繼續往前

137
00:05:22,240 --> 00:05:23,600
就是一個一個一個這樣子

138
00:05:23,600 --> 00:05:24,740
就是shift

139
00:05:24,740 --> 00:05:25,480
我們叫做shift

140
00:05:25,760 --> 00:05:27,940
往右位移這樣子

141
00:05:28,140 --> 00:05:30,380
然後一直到最後面

142
00:05:30,380 --> 00:05:31,680
最後面就是說

143
00:05:31,820 --> 00:05:34,400
讓右邊對齊

144
00:05:34,560 --> 00:05:36,560
然後左邊這樣子

145
00:05:36,560 --> 00:05:38,280
看看這裡面的內容

146
00:05:38,460 --> 00:05:41,880
和這裡面的內容是不是完全一樣

147
00:05:41,880 --> 00:05:43,680
這是一個等於說

148
00:05:43,820 --> 00:05:47,000
最直接最簡單的一個演算法

149
00:05:47,540 --> 00:05:49,540
就是說從左邊對齊開始

150
00:05:49,540 --> 00:05:50,360
開始比

151
00:05:50,360 --> 00:05:52,040
不管有沒有

152
00:05:52,280 --> 00:05:54,700
下一個就移一個移一個

153
00:05:55,100 --> 00:05:59,540
移到最右邊對齊然後再比對

154
00:05:59,720 --> 00:06:05,100
這個是一個很簡單的我們講字串比對的演算法

155
00:06:05,100 --> 00:06:07,720
但這個演算法有一個最大的問題

156
00:06:07,720 --> 00:06:09,120
就是它非常的慢

157
00:06:09,160 --> 00:06:11,160
這邊要比一次

158
00:06:11,160 --> 00:06:12,620
這個要比一次

159
00:06:12,620 --> 00:06:14,480
然後這也要比一次

160
00:06:14,700 --> 00:06:16,940
所以等於說這裡這裡有幾次

161
00:06:16,940 --> 00:06:18,040
你就要比幾次

162
00:06:18,220 --> 00:06:21,180
就等於說像這樣就是比一次

163
00:06:21,180 --> 00:06:22,340
這樣又比一次

164
00:06:22,520 --> 00:06:24,520
那每次比一次就要比什麼

165
00:06:24,680 --> 00:06:26,900
就要比這個裡面有多少字

166
00:06:27,060 --> 00:06:29,580
等於說要比這個長度

167
00:06:29,580 --> 00:06:31,120
這個都要比

168
00:06:31,480 --> 00:06:33,800
所以這個整個乘起來的話

169
00:06:33,800 --> 00:06:35,380
可能就非常的慢

170
00:06:35,380 --> 00:06:36,840
而且我們剛剛說

171
00:06:36,920 --> 00:06:41,200
這個是比紫色這個字串而已

172
00:06:41,200 --> 00:06:42,620
紫色這個特徵碼

173
00:06:42,620 --> 00:06:43,980
那我的特徵碼

174
00:06:44,280 --> 00:06:46,280
還有這麼多個

175
00:06:46,280 --> 00:06:47,960
可能是幾千個

176
00:06:47,960 --> 00:06:48,920
可能幾萬個

177
00:06:48,920 --> 00:06:50,600
每一個都這麼比下去

178
00:06:50,760 --> 00:06:52,760
然後每一個都要這樣比

179
00:06:53,240 --> 00:06:56,860
這個時間我們講乘起來的話是非常非常可觀

180
00:06:56,860 --> 00:06:58,160
而且非常的慢

181
00:06:58,800 --> 00:07:02,300
所以這種演算法基本上是不能用的

182
00:07:02,520 --> 00:07:04,520
是最直接最簡單

183
00:07:04,520 --> 00:07:06,100
一般而言叫做暴力法

184
00:07:06,340 --> 00:07:09,540
它把所有可能都把它走過一遍

185
00:07:09,540 --> 00:07:11,480
可是是沒有效率的

186
00:07:11,480 --> 00:07:12,580
這太慢了

187
00:07:12,580 --> 00:07:13,640
我們說

188
00:07:13,840 --> 00:07:17,060
所以字串比對演算法的挑戰在哪裡

189
00:07:17,060 --> 00:07:18,200
就是說

190
00:07:18,200 --> 00:07:19,500
因為我們做字串比對

191
00:07:19,620 --> 00:07:24,820
我們要match每一個payload against all patterns

192
00:07:24,820 --> 00:07:26,320
因為封包很多

193
00:07:26,440 --> 00:07:28,440
每一個封包都要比對

194
00:07:28,440 --> 00:07:29,620
每一個封包

195
00:07:29,940 --> 00:07:33,060
那每一個封包要比對的pattern又這麼多

196
00:07:33,220 --> 00:07:36,060
你看這個乘起來非常非常的可怕

197
00:07:36,060 --> 00:07:37,500
而且我們說

198
00:07:37,500 --> 00:07:39,140
這個pattern本身

199
00:07:39,300 --> 00:07:42,760
就是特徵碼的長度不是固定的

200
00:07:42,880 --> 00:07:44,880
它可能有的長有的短

201
00:07:45,200 --> 00:07:47,920
比如說有一個Snort非常有名

202
00:07:48,260 --> 00:07:50,800
這個Snort就是一格非常有名的IDS

203
00:07:50,800 --> 00:07:52,660
它既然是IDS

204
00:07:52,820 --> 00:07:55,740
所以它一定有它的特徵碼資料庫

205
00:07:56,120 --> 00:07:58,120
在它的特徵碼資料庫裡面

206
00:07:58,120 --> 00:07:59,580
那個特徵碼

207
00:07:59,580 --> 00:08:00,820
我們說它的長度

208
00:08:00,820 --> 00:08:02,280
因為不同的惡意程式

209
00:08:02,800 --> 00:08:07,960
我們找到它的特徵的字串可能長度是不一樣

210
00:08:07,960 --> 00:08:09,200
可能會不相同

211
00:08:09,680 --> 00:08:13,320
它的特徵碼可以從一個byte到一百二十二個byte

212
00:08:13,320 --> 00:08:14,260
都有

213
00:08:14,260 --> 00:08:15,180
這個很特別

214
00:08:15,420 --> 00:08:17,500
就是它那個特徵碼資料庫裡面有很多很多特徵碼

215
00:08:17,640 --> 00:08:19,640
有的是一個byte

216
00:08:19,940 --> 00:08:21,940
有的是一百二十二個byte

217
00:08:21,940 --> 00:08:23,440
所以不一定

218
00:08:23,440 --> 00:08:24,760
比如說這個

219
00:08:25,760 --> 00:08:30,240
GET/script/root.exe一個問號

220
00:08:30,500 --> 00:08:34,340
這個就是IDS裡面的一個特徵碼

221
00:08:34,340 --> 00:08:36,000
它的長度去算

222
00:08:36,000 --> 00:08:37,480
一二三四五六七八九

223
00:08:37,760 --> 00:08:39,900
大概二三十個byte的意思

224
00:08:40,560 --> 00:08:46,120
也就是說這個pattern可能會出現在payload裡面的任何一個地方

225
00:08:46,120 --> 00:08:47,460
我們剛剛提到

226
00:08:47,700 --> 00:08:50,900
可能會出現在這個pattern的最前面

227
00:08:50,900 --> 00:08:52,640
或者中間或者最後面

228
00:08:52,880 --> 00:08:54,880
所以你沒有把它全部比完

229
00:08:54,900 --> 00:08:56,900
你就不知道是不是出現

230
00:08:56,960 --> 00:09:02,380
就是它的位置可能是在封包內容裡面的任何一個地方

231
00:09:02,380 --> 00:09:03,720
這個也是困難的地方

232
00:09:04,180 --> 00:09:08,540
所以我們說總共的pattern通常也很多

233
00:09:09,160 --> 00:09:11,160
在IDS裡面是數千個

234
00:09:11,640 --> 00:09:17,000
它數千因為它是針對一些特定的惡意程式蒐集的

235
00:09:17,480 --> 00:09:19,640
也就是說pattern的數量很多

236
00:09:19,940 --> 00:09:21,940
然後pattern的長度不一

237
00:09:22,720 --> 00:09:26,180
然後每一個封包進來都要跟這些pattern做比對

238
00:09:26,560 --> 00:09:30,520
所以這個挑戰就是說它的速度的挑戰是非常大的

239
00:09:30,520 --> 00:09:32,420
我們來看一下說

240
00:09:32,420 --> 00:09:34,140
像在這個Snort

241
00:09:34,600 --> 00:09:38,100
這個所謂的open source的這個IDS

242
00:09:38,260 --> 00:09:41,880
它有四個最大的所謂的routine

243
00:09:41,880 --> 00:09:43,740
就是它裡面有四個最大的程式

244
00:09:44,280 --> 00:09:46,280
比如說做字串比對的

245
00:09:46,280 --> 00:09:47,840
做封包分類的

246
00:09:48,000 --> 00:09:50,440
這個也是封包分類裡面的一個routine

247
00:09:50,440 --> 00:09:52,000
其他的matching

248
00:09:52,200 --> 00:09:54,660
其中這個字串比對

249
00:09:55,180 --> 00:09:57,900
要佔掉31%的運算

250
00:09:57,900 --> 00:09:59,560
可以看得出來說

251
00:10:00,060 --> 00:10:02,940
像Snort這樣開源的軟體

252
00:10:03,520 --> 00:10:07,000
它裡面負擔最重的就是在做字串比對

253
00:10:07,000 --> 00:10:08,680
佔掉31%的意思

254
00:10:08,680 --> 00:10:10,400
所以我們說

255
00:10:10,840 --> 00:10:13,200
這個pattern matching這個routine

256
00:10:13,500 --> 00:10:18,120
是IDS裡面最耗資源

257
00:10:18,280 --> 00:10:20,280
我們叫resorce-intensive的task

258
00:10:20,280 --> 00:10:22,060
就它自己耗得最多

259
00:10:22,280 --> 00:10:25,160
因為它要花掉31%在做這個字串比對的工作

260
00:10:25,620 --> 00:10:30,280
我們需要非常有效率的pattern matching的work的意思

261
00:10:30,280 --> 00:10:33,080
所以我們如果在字串比對上面沒有好的演算法

262
00:10:33,380 --> 00:10:37,920
這個地方會拖累這個IDS的功能

263
00:10:37,920 --> 00:10:39,860
因為它會變慢

264
00:10:40,120 --> 00:10:42,120
我們知道說變慢也會出問題

265
00:10:42,120 --> 00:10:44,000
不夠快也是問題

266
00:10:44,000 --> 00:10:45,900
那我們再來看看說

267
00:10:46,080 --> 00:10:51,060
現在會使用字串比對的軟體到底有哪一些

268
00:10:51,160 --> 00:10:53,160
我們剛剛講的是叫做Snort

269
00:10:53,460 --> 00:10:55,460
Snort是非常有名的IDS

270
00:10:55,700 --> 00:11:01,280
那它把全部這種字串比對的工作全部加起來

271
00:11:01,520 --> 00:11:04,880
大概有62%在做字串比對

272
00:11:05,340 --> 00:11:07,880
另外還有一個很有名的叫ClamAV

273
00:11:07,880 --> 00:11:09,860
ClamAV

274
00:11:10,120 --> 00:11:13,580
AV就是防病毒

275
00:11:13,580 --> 00:11:15,560
就是antivirus

276
00:11:15,560 --> 00:11:16,920
就是防毒軟體

277
00:11:16,920 --> 00:11:18,920
它也是一個open source開源程式

278
00:11:19,120 --> 00:11:25,180
就是說這個ClamAV本身大概有90%是在做pattern matching

279
00:11:25,180 --> 00:11:27,400
因為它做防毒

280
00:11:27,400 --> 00:11:29,140
就是病毒

281
00:11:29,340 --> 00:11:32,440
那病毒一樣我們都是用字串來代表某一個病毒

282
00:11:32,640 --> 00:11:35,560
它在比對的時候也要佔掉非常大的比例

283
00:11:35,820 --> 00:11:37,820
另外一個是防垃圾郵件的

284
00:11:38,040 --> 00:11:38,780
叫做Spam

285
00:11:38,780 --> 00:11:40,040
也就是說垃圾郵件本身

286
00:11:40,500 --> 00:11:44,340
垃圾郵件裡面也是因為它的字太多廣告

287
00:11:44,560 --> 00:11:46,560
太多連結

288
00:11:46,700 --> 00:11:49,000
所以它也會做很大的字串比對

289
00:11:49,320 --> 00:11:51,320
大概花掉75%

290
00:11:51,360 --> 00:11:55,900
我們可以看到說幾個比較有名的防垃圾的

291
00:11:56,040 --> 00:11:58,040
防病毒的

292
00:11:58,840 --> 00:12:00,840
這個IDS入侵偵測系統

293
00:12:01,060 --> 00:12:05,680
其實你看這個字串比對這個比例都非常的高

294
00:12:05,740 --> 00:12:12,220
最後我們看一下這個字串比對他的時間代價是非常昂貴的

295
00:12:12,640 --> 00:12:17,660
這個是Intel所提供的一個從layer 2到layer7

296
00:12:17,880 --> 00:12:21,000
不同的功能他要花多少時間

297
00:12:21,100 --> 00:12:23,100
我們來這麼看

298
00:12:23,260 --> 00:12:25,920
縱軸是這個應用軟體的複雜度

299
00:12:25,980 --> 00:12:30,460
就是你要處理越多內容就越複雜

300
00:12:31,100 --> 00:12:38,520
橫軸是說一個封包大概你需要幾個指令把這個封包處理完

301
00:12:38,520 --> 00:12:40,000
就是這個封包進來

302
00:12:40,200 --> 00:12:41,820
我們講去頭去尾開始做檢查

303
00:12:41,820 --> 00:12:43,620
最後把它送出去

304
00:12:43,900 --> 00:12:47,920
封包從進到這個設備到從這個設備離開

305
00:12:48,740 --> 00:12:52,900
中間要花多少指令來處理它的意思

306
00:12:53,140 --> 00:12:55,880
我們說一般Switching是說

307
00:12:56,280 --> 00:12:58,280
像Layer 2的交換器

308
00:12:58,440 --> 00:12:59,580
交換器是最簡單

309
00:12:59,580 --> 00:13:01,200
因為它只處理到我們叫做Layer 2

310
00:13:01,340 --> 00:13:03,340
處理到Mac Layer

311
00:13:03,340 --> 00:13:05,020
所以他大概是說

312
00:13:05,180 --> 00:13:07,820
一個1500個byte的封包

313
00:13:08,000 --> 00:13:10,000
這是封包的大小

314
00:13:10,260 --> 00:13:14,000
一般ethernet就是1500個byte 就是一個封包的長度就是1500個byte

315
00:13:14,860 --> 00:13:16,860
大概需要花50個指令

316
00:13:17,160 --> 00:13:20,020
就一個封包進來大概花50個

317
00:13:20,220 --> 00:13:22,960
比如說加減移檢查

318
00:13:23,080 --> 00:13:27,380
大概是50個指令可以把一個封包處理完的意思

319
00:13:27,380 --> 00:13:33,440
因為它比較簡單隨著網路設備的功能從最簡單的交換機

320
00:13:33,440 --> 00:13:34,800
會到路由器Routing

321
00:13:34,960 --> 00:13:37,740
它就會處理IP位置了

322
00:13:39,140 --> 00:13:41,140
QoS就是服務品質

323
00:13:41,400 --> 00:13:45,460
可能會處理到IP 加上TCP/ UDP 的port number

324
00:13:45,960 --> 00:13:49,580
再往上 網路監控 附載平衡

325
00:13:50,400 --> 00:13:53,300
還有我們看到的防火牆 VPN

326
00:13:53,300 --> 00:13:57,560
這裡入侵偵測跟這個防毒

327
00:13:57,800 --> 00:14:00,080
這個Virus Scan就是掃毒

328
00:14:00,380 --> 00:14:02,780
這兩個工作是非常複雜的

329
00:14:02,780 --> 00:14:04,340
我們看一下

330
00:14:04,380 --> 00:14:06,660
到了最頂級的這個

331
00:14:06,820 --> 00:14:10,180
我們所謂的入侵偵測跟這個病毒的掃毒

332
00:14:10,520 --> 00:14:14,560
它要花多少的功夫來處理這個封包呢

333
00:14:14,840 --> 00:14:19,920
我們說這個是一個byte就要30個指令

334
00:14:20,240 --> 00:14:24,780
因為它要做剛剛提到的比對他要做很多這種比對的動作

335
00:14:25,140 --> 00:14:27,140
所以相對的負擔就大很多

336
00:14:27,380 --> 00:14:31,700
一個byte就要30個指令才能比對完成

337
00:14:31,960 --> 00:14:37,200
一樣 所以一個1500byte的封包

338
00:14:37,540 --> 00:14:40,180
就是一個大封包 這個乘起來就是30乘上1000

339
00:14:40,760 --> 00:14:46,220
大概要45K的指令 這只有50的指令

340
00:14:46,220 --> 00:14:47,380
這是45K的指令

341
00:14:48,480 --> 00:14:51,080
所以你可以看到說 一個封包進來

342
00:14:51,480 --> 00:14:53,480
從最簡單的Layer2得交換機

343
00:14:53,480 --> 00:14:55,140
就很快就出去了

344
00:14:55,200 --> 00:14:58,040
因為它處理這個封包的指令非常得少

345
00:14:58,220 --> 00:15:04,580
到我們要做入侵偵測   到這個病毒掃描的話 一個封包進來要花掉45K

346
00:15:05,060 --> 00:15:09,620
就四萬五千個指令才能把它處理完

347
00:15:10,160 --> 00:15:18,360
所以相對於說 在做字串比對來講 我們說它的時間的代價是非常的昂貴的

348
00:15:18,620 --> 00:15:23,340
這也特別顯示說 字串比對的技術是非常非常的關鍵

