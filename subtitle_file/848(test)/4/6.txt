1
00:00:00,000 --> 00:00:02,780
那接下來我們來看一下

2
00:00:02,780 --> 00:00:06,610
第二個技術所謂的Application Level Firewall

3
00:00:06,610 --> 00:00:08,810
一般叫做Application proxy

4
00:00:08,810 --> 00:00:13,610
我們說他提供幾乎是最安全的這種所謂的資料的保護

5
00:00:13,610 --> 00:00:18,410
為什麼呢 因為他會檢查每一個layer

6
00:00:18,410 --> 00:00:21,680
所有通訊的內容他都會檢查

7
00:00:21,680 --> 00:00:24,350
包含說所有的application data

8
00:00:24,350 --> 00:00:26,910
就是封包的內容他都可以檢查

9
00:00:26,910 --> 00:00:30,280
因為他會 等於說他是一個proxy

10
00:00:30,280 --> 00:00:31,880
他會把兩邊建連線

11
00:00:31,880 --> 00:00:35,680
所有連線的資料就到這個proxy

12
00:00:35,680 --> 00:00:39,150
這proxy會另外再建連線到後端的真正的server

13
00:00:39,150 --> 00:00:41,310
他介於兩者之間

14
00:00:41,310 --> 00:00:46,110
我們說 從一個client到一個server的連線

15
00:00:46,110 --> 00:00:49,380
我們說 intercepted by the proxy

16
00:00:49,380 --> 00:00:52,950
也就是說這個連線會被這個proxy所攔截

17
00:00:52,950 --> 00:00:55,950
可是呢 不是真的攔截 事實上它

18
00:00:55,950 --> 00:00:59,050
本來client要跟server建連線

19
00:00:59,050 --> 00:01:02,950
事實上等於說這個連線是先建到這個proxy

20
00:01:02,950 --> 00:01:05,550
然後由proxy再到這個server

21
00:01:05,550 --> 00:01:08,380
所以他等於是介於client跟server之間

22
00:01:08,380 --> 00:01:11,010
所有的連線都經過他的意思

23
00:01:11,010 --> 00:01:12,810
我們來看一下 首先呢

24
00:01:12,810 --> 00:01:17,450
這個封包的檢查是在application layer來檢查

25
00:01:17,450 --> 00:01:21,110
不像我們剛剛提到的第一種packet filter的技術

26
00:01:21,110 --> 00:01:24,880
封包的檢查是在network layer

27
00:01:24,880 --> 00:01:27,610
因為他只看那個IP或者是

28
00:01:27,610 --> 00:01:31,410
頂多就到這個所謂的TCP的header

29
00:01:31,410 --> 00:01:33,410
但是這個application proxy

30
00:01:33,410 --> 00:01:35,610
或者簡稱application gateway

31
00:01:35,610 --> 00:01:40,880
他是在application layer來檢查 也就是說

32
00:01:40,880 --> 00:01:46,580
封包送到這個網路是到application layer來

33
00:01:46,580 --> 00:01:49,510
檢查完之後呢再往下送到

34
00:01:49,510 --> 00:01:53,050
所謂的我們講如果是client到server的話

35
00:01:53,050 --> 00:01:56,850
等於說他是要經過這個application layer的檢查

36
00:01:56,850 --> 00:01:58,380
這是比較不一樣的地方

37
00:01:58,380 --> 00:02:03,450
然後這個他就可以看這個封包的內容

38
00:02:03,450 --> 00:02:06,580
所以他的這個檢查的這個精準度就更高

39
00:02:06,580 --> 00:02:13,010
譬如說我們可以避免說SNMP set command

40
00:02:13,010 --> 00:02:15,050
也就是說我們如果的策略裡面是說

41
00:02:15,050 --> 00:02:20,050
因為我這裡面的設備假設有用網管

42
00:02:20,050 --> 00:02:22,250
SNMP protocol來管理

43
00:02:22,250 --> 00:02:25,410
但是 如果你要做set 做設定

44
00:02:25,410 --> 00:02:27,180
我們說這個是不可以的

45
00:02:27,180 --> 00:02:29,550
這是我們管理的一個策略

46
00:02:29,550 --> 00:02:33,880
就是我們網路的設備是可以用SNMP來管理

47
00:02:33,880 --> 00:02:37,080
但是不可以被人家設定的意思

48
00:02:37,080 --> 00:02:41,910
那如果我們用剛剛提到的packet filter你就做不到

49
00:02:41,910 --> 00:02:43,580
因為我們只看header

50
00:02:43,580 --> 00:02:47,610
但如果說像這個所謂的application的proxy我就做的到

51
00:02:47,610 --> 00:02:50,610
因為他知道你現在你的封包是SNMP

52
00:02:50,610 --> 00:02:52,650
然後他會看封包的內容

53
00:02:52,650 --> 00:02:56,080
發現有一個set這個指令 然後就把它濾掉

54
00:02:56,080 --> 00:03:00,080
也就是說他會從application level這邊來做檢查

55
00:03:00,080 --> 00:03:04,610
我們就來看一下說 他的做法是怎麼樣

56
00:03:04,610 --> 00:03:07,650
也就是說如果這個proxy說

57
00:03:07,650 --> 00:03:09,980
這個連線是可以被允許的

58
00:03:09,980 --> 00:03:13,850
因為有時候連線是不被允許的就直接就擋掉了

59
00:03:13,850 --> 00:03:15,750
假設這個連線

60
00:03:15,750 --> 00:03:19,880
我們講這個連線是 我們叫可以通過的

61
00:03:19,880 --> 00:03:24,480
那他就會再建立所謂的第二個連線給server

62
00:03:24,480 --> 00:03:29,980
也就是說client本身可能先跟這個proxy先建連線

63
00:03:29,980 --> 00:03:34,550
然後proxy再到server 這是他的基本的model

64
00:03:34,550 --> 00:03:37,710
也就是說這個

65
00:03:37,710 --> 00:03:41,780
我們說這個data portion of each packet

66
00:03:41,780 --> 00:03:45,250
就是說因為你把連線建起來之後

67
00:03:45,250 --> 00:03:50,850
代表是說 所有的data部分都要把它拿出來

68
00:03:50,850 --> 00:03:54,680
因為要把這個data從一個連線裡面

69
00:03:54,680 --> 00:03:59,410
把它抓出來以後把它塞到第二個連線

70
00:03:59,410 --> 00:04:02,680
也就是說所有的這個每一個封包的data

71
00:04:02,680 --> 00:04:09,180
通通要被萃取出來 要檢查 甚至重新再built

72
00:04:09,180 --> 00:04:13,250
等於要從一個連線搬到另外一個連線的意思

73
00:04:13,250 --> 00:04:18,650
也就是說 要把這個data從原來的封包裡面把他抓出來

74
00:04:18,650 --> 00:04:23,180
經過層層處理之後 要把他送到第二個連線去

75
00:04:23,180 --> 00:04:26,980
這是所謂的proxy該做的事情

76
00:04:26,980 --> 00:04:30,150
那我們說這樣的檢查

77
00:04:30,150 --> 00:04:34,780
他可以非常非常嚴謹的來處理這個封包

78
00:04:34,780 --> 00:04:41,050
也就是說這個proxy的firewall它有非常高度的安全性

79
00:04:41,050 --> 00:04:43,910
而且我們講非常的慢

80
00:04:43,910 --> 00:04:49,180
因為他要把連線上面的每一個資料

81
00:04:49,180 --> 00:04:52,750
每一個data、每一個內容通通把它拿出來

82
00:04:52,750 --> 00:04:57,580
然後做檢查 然後再把它塞到另外一個連線的封包裡面去

83
00:04:57,580 --> 00:04:58,980
那這個檢查的過程當中

84
00:04:58,980 --> 00:05:02,510
因為所有的內容都可以看、都可以檢查

85
00:05:02,510 --> 00:05:08,110
所以我們說他有非常高的這個安全度 very secure

86
00:05:08,110 --> 00:05:12,180
但是也相對的 因為這樣處理的話

87
00:05:12,180 --> 00:05:13,780
他要花掉更多的資源

88
00:05:13,780 --> 00:05:17,210
我們說他的速度通常會比較慢一點點

89
00:05:17,210 --> 00:05:21,680
我們再來看說 那這種proxy本身

90
00:05:21,680 --> 00:05:24,080
因為他是做到application layer

91
00:05:27,950 --> 00:05:27,980
所以他就必須去懂這個application layer的這個應用

92
00:05:27,980 --> 00:05:32,110
就是proxy本身她必須了解這個application layer

93
00:05:32,110 --> 00:05:36,150
就不同的application有不同的protocol

94
00:05:36,150 --> 00:05:38,410
有不同的應用有不同的自己的這個協議

95
00:05:38,410 --> 00:05:41,150
所以變成說這個proxy本身

96
00:05:41,150 --> 00:05:45,710
要去了解每一個他想要所謂的代理的這個應用

97
00:05:45,710 --> 00:05:50,910
如果說未來有一個新的protocol重新被開發出來

98
00:05:50,910 --> 00:05:54,350
那我們就必須有新的proxy的意思

99
00:05:54,350 --> 00:05:58,410
也就是說application A的這個proxy

100
00:05:58,410 --> 00:06:02,050
不能給application B來使用

101
00:06:02,050 --> 00:06:05,280
因為不同的application他的protocol是不一樣的

102
00:06:05,280 --> 00:06:08,780
也就如果有新的protocol被開發出來

103
00:06:08,780 --> 00:06:10,780
那我們就必須有新的proxy

104
00:06:10,780 --> 00:06:14,480
這個是他的一個等於說將來在擴充上面

105
00:06:14,480 --> 00:06:15,880
會碰到一個困難

106
00:06:15,880 --> 00:06:19,010
因為不同的application會有不同的這個應用

107
00:06:19,010 --> 00:06:21,810
我們來看譬如說像

108
00:06:21,810 --> 00:06:25,480
常看的像Web Proxy Server 就是網站

109
00:06:25,480 --> 00:06:27,510
我們會有很多很多網站

110
00:06:27,510 --> 00:06:31,110
那每一個這個Web都可以有一個Proxy server

111
00:06:31,110 --> 00:06:33,250
代表說我們本來應該連到網站的

112
00:06:33,250 --> 00:06:37,350
網站的伺服器我們可能就連到這個proxy

113
00:06:37,350 --> 00:06:41,080
那或者是說假設有其他的應用

114
00:06:41,080 --> 00:06:43,280
我們叫做Application Proxy Server

115
00:06:43,280 --> 00:06:46,280
不同的應用可以有不同的proxy

116
00:06:46,280 --> 00:06:47,980
譬如說mail server

117
00:06:47,980 --> 00:06:52,880
他就是一個application gateway的一個例子

118
00:06:52,880 --> 00:06:55,010
也就是通常我們在寄mail的時候

119
00:06:55,010 --> 00:06:57,250
我們常常先寄給mail server

120
00:06:57,250 --> 00:06:59,480
那mail server再幫我們轉寄到

121
00:06:59,480 --> 00:07:03,550
真正的所謂的使用者的這個信箱裡頭去

122
00:07:03,550 --> 00:07:08,880
那這個application proxy我們說他就是

123
00:07:08,880 --> 00:07:11,880
防火牆裡面的第二代的這個技術

124
00:07:11,880 --> 00:07:15,080
第二代的技術本身我們說

125
00:07:15,080 --> 00:07:21,210
他是幫client跟server之間建連線

126
00:07:21,210 --> 00:07:26,150
也就是我們會替這個client跟server建立這個連線

127
00:07:26,150 --> 00:07:29,710
那當然他沒有非常的有彈性

128
00:07:29,710 --> 00:07:33,610
我們說not flexible是因為說這個proxy本身

129
00:07:33,610 --> 00:07:37,780
他必須懂得這個所謂的application

130
00:07:37,780 --> 00:07:41,180
那如果有新的application protocol出來的時候

131
00:07:41,180 --> 00:07:43,210
我們就要重新再開發一個

132
00:07:43,210 --> 00:07:44,980
所謂的新的這個proxy

